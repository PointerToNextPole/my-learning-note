# 前端面试点总结



## HTML & CSS



> 摘自：[全面系统讲解CSS 工作应用+面试一步搞定](https://coding.imooc.com/class/chapter/164.html)

#### html常见元素

- \<header> 中的元素包含：meta、title、style、link、script、base；这些元素不会在页面上直接留下内容，主要是页面相关的资源和信息描述
  - meta 中 viewport表示：手机屏幕代表页面的多大尺寸，即设置 viewport 的宽度等于屏幕的宽度。用于设配移动端，<font color=FF0000> 这是第一步，也是最重要的一步</font>。
- \<body> 中的元素主要包含（这里不全）：
  - div / section / article / aside / header / footer
  - 段落：p
  - 行内元素：span / em / strong
  - 表格：table / thead / body / tr / td
  - 列表：ul / ol / li /dl / dt/ dd
  - 链接：a
  - 表单：form / input / select / textarea / button



#### HTML的重要属性

- table td[colspan, rowspan]：用于合并单元格

- form[target, method, enctype]：

  - target：表示表单要提交到哪里
  - method：用什么方式提交，一般是get / post
  - enctype：用什么编码方式提交，主要针对post方式。主要有两种编码：1. url encode 2.formdata（用formdata 可以用于上传文件）

- input type="radio"[name]：当多个radio（单选框）在一起时，通过<font color=FF0000> 设置同样的 name，表明它们是一组的，只能选择其中一个</font>

- button[type]：用于指定按钮的类型

  - <font color=FF0000 size=4>**问题：**</font>在表单中，比如使用AJAX，不通过 \<button type="submit"> 去提交代码，是否可以不加上 \<form> 标签？

    答：技术上讲是可以不使用 form 元素的，但是使用 form 有如下优点：

    - 使用 \<form> 可以利用 \<button type="submit">、\<button type="reset"> 等特性，方便开发，如果没有 form 元素，将无法使用。
    - 使用 form 元素，可以通过一些方式批量获取表单
    - 使用 form 元素，可以与框架结合，或者与验证组件结合，做表单验证
    - 使用 form 元素，浏览器或密码管理工具会记住用户名和密码，方便用户，提升用户体验



#### 理解HTML，HTML是什么

- HTML 是一个文档（HTML5 加入语义化的标签，就是为了让html文档结构更清晰，语意更明显）
- 有描述文档的结构
- 有区块有大纲

可以使用 h5o.github.io 查看文档结构，可以用于优化 SEO



#### HTML 版本

| HTML4                                     | XHTML               | HTML5                                     |
| ----------------------------------------- | ------------------- | ----------------------------------------- |
| <font color=FF0000> 标签允许不结束</font> | 标签必须结束        | <font color=FF0000> 标签允许不结束</font> |
| 属性不用带引号                            | 属性必须带引号      | 属性不用带引号                            |
| 标签属性可大写                            | 标签属性必须小写    | 标签属性可大写                            |
| Boolean属性可省略值                       | Boolean属性必须写值 | Boolean属性可省略值                       |


可以使用 http://validator.w3.org/ 来验证 html 页面书写是否规范



#### HTML5 新增内容

- 新的区块标签：section / article / nav / aside
- 表单增强：
  - 日期、时间、搜索（type="search"）
  - 表单验证
    - require属性
    - min / max
    - pattern 指定正则表达式，检测输入是否如何
  - placeholder、自动聚焦（autofocus）
- 语意：
  - header /  footer：表示头尾
  - section / article：表示区域，其中如果是一篇文章，用article
  - nav：导航
  - aside：表示不重要的内容
  - em / strong：强调
  - i：在HTML4中表示斜体，但是由于用作图标的使用广泛，所以在 HTML5 中表示 icon



#### HTML 元素分类

- **按默认样式分类：**

  - 块级 block
  - 行内 inline，与文本相关的元素：span、em、strong等
  - 行内块级 inline-block，一些表单元素，比如下拉框

- **按照内容分类：**

  <img src="https://i.loli.net/2021/09/30/3ci2lqYuyWfd7VR.png" alt="image-20210930102712739" style="zoom:50%;" />

  - **Flow：**在文档流中有影响的元素，大部分可见的元素都是Flow元素
  - **metadata：**部分是在Flow之外的（如图），比如 head 中的 title base script，不占据文档流，所以在Flow之外
  - **heading：**标题 h1 - h6
  - **sectioning：**分区的元素， section、article、aside、nav
  - **interactive：**与用户有交互的元素
  - **phrasing：**短语，不是完整的句子、不是一个完整的段落。如em、strong
  - **embedded：**嵌入的资源，如audio、vedio

  更多的：可以看 https://html.spec.whatwg.org/multipage/dom.html#kinds-of-content



#### HTML的嵌套关系

- 块级元素可以包含行内元素
- 块级元素<font color=FF0000> 不一定</font>能包含块级元素，如 p 不能包含 div，因为它是一个段落
- 行内元素<font color=FF0000> 一般不能</font>包含块级元素，比如 anchor 元素可以包含块级元素（a > div）补充：anchor是透明的（transport的内容模型，即在计算内容模型时，透明的元素是不参与计算的。）



#### HTML元素默认样式

- 默认样式的意义：带有默认样式，简化工作量
- 默认样式带来的问题
  - 有些默认样式是我们不想要的
  - html也是有样式的，所以在修改样式时，可以从html元素改起
  - body默认是有 margin 的
- 由于默认样式可能会有问题，所以可以使用 css reset，比如 normalize.css



#### HTML 面试真题

- **doctype 的意义是什么？**

  - 让浏览器以标准模式渲染（这里有一些历史因素在里面，与盒子模型相关）
  - 让浏览器知道元素的合法性（在不同版本的 html 中，代码的合法性是不同的）

- **HTML XHTML HTML5 的关系？**

  - HTML 属于 SGML
  - XHTML 属于 XML，是 HTML 进行 XML 严格化的结果
  - <font color=FF0000> HTML 5不属于 SGML 或 XML，比 XHTML 宽松</font>

- <font color=FF0000 size=4>**HTML 5有什么变化？**</font>

  - 新的语义化元素

  - 表单增强（添加日期、搜索，<font color=FF0000>添加验证功能</font> ）

  - <font color=FF0000>**新的 API ，与 JS 相关**</font>
    
    - **离线：**ApplicationCache、Service Worker。
    
      AppCache 已经过时，由 Service Worker 替代（比如 Chrome 官方的文章 [准备进行 AppCache 移除](https://web.dev/i18n/zh/appcache-removal/) ）
    
      ApplicationCache 即 AppCache。另外，一般基于建立一个基于一个新建的 `*.appcache` 文件的缓存机制，通过这个<font color=FF0000>文件上的 **解析清单** 离线存储资源</font>，这些资源就会像 cookie 一样被存储了下来。相关 html 代码为：
    
      ```html
      <html manifest="foo.appcache">
      ```
    
      另外，这里由于篇幅，更多内容略。详见：[「2021」高频前端面试题汇总之HTML篇](https://juejin.cn/post/6905294475539513352) 中的 10、11 
    
    - 音视频（ 内置 audio、video，而不是借助 flash ）
    
    - 图形（ canvas、svg，之前只能借助 flash ）
    
    - 实时通信（ websocket ）
    
    - 本地存储（ localStorage、indexedDB ）
    
    - 设备能力 （ <font color=FF0000>定位</font>，获取加速计、陀螺仪的状态 ）
    
    - Drag & Drop API、History API
    
    - DOM 操作：document.querySelect() 、document.querySelectAll()
    
  - 分类和嵌套变更

- **em 和 i 有什么区别？**

  - em 和 i 的默认样式都是斜体的
  - em 是语义化的标签，表示强调
  - i 是纯样式的标签，表斜体
  - HTML5 中 i 不推荐使用，一般用作图标

- <font color=FF0000>**语义化的意义是什么？**</font>

  - 开发者容易理解，增加代码的可读性，便于代码维护
  - 机器容易理解结构（ 搜索、盲人使用的读屏软件 ）
  - 有助于 SEO
  - semantic microdata

- <font color=FF0000>**哪些元素可以自闭合？**</font>

  - 表单元素 input
  - 图片 img
  - br hr
  - meta link

- **HTML 和 DOM 的关系**

  - HTML是“死”的，就是一串字符串，要经过浏览器解析，解析之后才变成 DOM
  - DOM由HTML解析而来，是活的
  - JS 可以维护 DOM

- **property 和 attribute 的区别**

  - attribute 更倾向于被译为“属性”是“死”的，是 HTML 上的，被浏览器解析之后变成特性。
  - propety通过getAttribute() 和 setAttribute() 进行读取与设置
  - property 更倾向于被译为“特性”
  - property 被修改，不会影响 attribute；同时，attribute 被修改也不会影响 property

  示例：

  ```html
  <input type="text" value="1" />
  ```

  这里的 value 是attribute，是属性，属性value值为1。

  而在浏览器上，选中 input 之后，在控制台中输入 `$0.value`（表示选中的元素的 value 特性），这时获得的值是特性。

  使用 `$0.setAttribute('value', 2)` 以修改属性，这时 `$0.value` 还是 1。使用 `$0.value = 2` 修改特性，这时 `$0.getAttribute('value')` 的值还是 1

  **补充：**

  **Attribute（特性）**

  <font color=FF0000>**attribute特性由HTML定义**</font>，所有出现在HTML标签内的描述节点都是attribute特性。

  ```html
  <div id="test" class="button" custom-attr="1"></div>
  ```

  ```js
  document.getElementById('test').attributes; // return: [custom-attr="hello", class="button", id="test"]
  ```

  <font color=FF0000>attribute特性的类型总是字符串类型</font>。拿上边的DIV为例，document.getElementById('test').getAttribute('custom-attr') 或者 \$('#test').attr('custom-attr')总是返回字符串类型的"1"。

  **Property（属性）**

  <font color=FF0000>property属性**属于DOM对象**</font>，DOM实质就是javascript中的对象。我们可以跟在js中操作普通对象一样获取、设置DOM对象的属性，并且<font color=FF0000>property属性可以是任意类型</font>。

  ```js
  document.getElementById('test').foo = 1; // 设置属性: foo 为 number类型: 1
  document.getElementById('test').foo; // 获取属性值, return number: 1
  $('#test').prop('foo'); // 使用jquery获取属性值, return number: 1
  ```

  ```js
  $('#test').prop('foo', {
     age: 23,
     name: 'John'
  }); // 使用jquery设置一个名为foo的对象
  document.getElementById('test').foo.age; // return number类型: 23
  document.getElementById('test').foo.name; // return string类型: "John"
  ```

  译者注：这里的property可以是任意类型指的是我们为DOM对象自定义添加的属性，对于DOM对象的原始属性，类似name属性，无论我们设置什么类型的值，最后返回的都是字符类型。

  **最佳实践**

  在javascript中我们推荐使用**property属性**因为这个属性相对**attribute**更快，更简便。尤其是有些类型本该是布尔类型的attribute特性。比如："checked", "disabled", "selected"。浏览器会自动将这些值转变成布尔值传给property属性。

  摘自：[[译\]HTML attribute与DOM property之间的区别？](https://segmentfault.com/a/1190000008781121)

- **form 的作用有哪些？**
  
  - 直接提交表单
  - 使 submit / resetii
  - 便于浏览器保存表单
  - 第三库可以整体提取值
  - 第三方库可以进行表单验证



#### HTML5 Drag & Drop API

- **drag<mark>start</mark>：**<font color=FF0000>事件主体是**被拖放元素**</font>，在开始拖放被拖放元素时触发
- **<mark style="background: fuchsia">darg</mark>：**事件主体是被 <font color=FF0000 size=4>*拖放元素*</font>，在正在拖放被拖放元素时触发
- **drag<mark style="background: aqua">enter</mark>：**事件主体是**目标元素**，在被拖放元素进入某元素时触发
- **dragover：**事件主体是**目标元素**，在被拖放在某元素内移动时触发
- **drag<mark style="background: aqua">leave</mark>：**事件主体是 **目标元素**，在被拖放元素移出目标元素是触发
- **<mark style="background: fuchsia">drop</mark>：**事件主体是 <font color=FF0000 size=4>*目标元素*</font>，在目标元素完全接受被拖放元素时触发。
- **drag<mark>end</mark>：**<font color=FF0000>事件主体是**被拖放元素**</font>，在整个拖放操作结束时触发。

摘自：[「2021」高频前端面试题汇总之HTML篇](https://juejin.cn/post/6905294475539513352)



#### CSS的解析方式

CSS 的解析方式是从右向左的，如：

```css
.foo .bar .baz {
  ...
}
```

这里浏览器对与CSS是先从 .baz 开始的，先找到 .baz，在查找上层是否有 .bar，一直向上。这样做是从性能方面去考虑的，只需要对CSS的一部分进行分析，如果存在，则继续向上；而不是直接对于整个CSS文档进行分析，这样很耗性能



#### 选择器的分类

- 元素选择器：a{}
- 伪元素选择器： ::before{}
- 类选择器：.link{}
- 属性选择器：[type=radioj{}
- 伪类选择器：:hover{}
- ID选择器：#id{}
- 组合选择器：[type=checkbox] + label{}
- 否定选择器： :not(link){}
- 通用选择器： *{}

补充：伪类代表一个状态，伪元素是一个真实存在的元素



#### **padding 和 margin 的区别**

- padding 是框线 和内容之间的距离，margin 是框线和其他元素之间的距离。

- padding 会被背景颜色覆盖，但margin 不会
- 如果元素是一个可以点击的元素，padding 会被纳入可点击的范围；而 margin 不会
- margin可能会出现 塌陷的情况，而 padding 不会
- margin 对于 行内元素，只对 左右( margin-left、margin-right )有效，上下无效；而padding 都可以，但是 由于行内元素没有高度，所以垂直样式上看不太出来（注：详见视频）

学习自：[[CSS] Box Model 盒子模型（Padding、Border、Margin）](https://www.bilibili.com/video/BV1WA411h7Y1)



#### 特指度 / 优先级 ( Specificity )

下面列表中，选择器类型的优先级是递增的：

1. **类型选择器：**（例如，h1）和 <font color=FF0000>伪元素</font>（例如，`::before`）

   通配选择符（universal selector）（即：`*`）、关系选择符（combinators）（ `+`, `>`, `~`, `' '`, `||`）和 否定伪类( negation pseudo-class )（ `:not()` ）对优先级没有影响。（但是，在 `:not()` 内部声明的选择器会影响优先级）。

2. **类选择器：** (例如，`.example`)，属性选择器（例如，`[type="radio"]`）和<font color=FF0000>伪类</font>（例如，`:hover`）

3. **ID 选择器：**（例如，`#example`）

4. 给元素添加的**内联样式** (例如，`style="font-weight:bold"`) 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。

5. 当在一个样式声明中使用一个 **`!important` **规则时，此声明将覆盖任何其他声明。

   虽然，从技术上讲，`!important` 与优先级无关，但它与最终的结果直接相关。

   使用 `!important` 是一个**坏习惯**，应该尽量避免，因为这破坏了样式表中的固有的级联规则 使得调试找bug变得更加困难了

而当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，<font color=FF0000>CSS 中最后的那个声明将会被应用到元素上</font>。

摘自：[MDN - 优先级](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity) 另外，在《CSS权威指南 第四版》第三章 “特指度和层叠”有更详细的阐述。



#### **定位**

position的默认值为 **static**，static 的元素对于 top bottom left right 均不会生效

**relative** 和 static 类似，都会跟随 html 的排版流程移动（注：这里是否可以说为受到文档流影响）；relative 元素 相对于自己（本来的、不设置定位的）位置进行移动。但 absolute 不会

**relative** 最重要的功能是，在它里面的的 absolute 元素会根据 relative 的位置去定位（即：子绝父相）；而如果将absolute元素用 static 元素包裹，则完全不会按照父元素的位置去定位。

补充：

> absolute 是根据上一个脱离了文档流的 position 来计算位置的，最外层的 absolute 的元素是根据窗口定位
>
> 摘自：[CSS 布局的本质是什么](https://zhuanlan.zhihu.com/p/395050907)

**fixed** 是根据窗口定位，另外，即使fixed的元素被 relative 的父元素所包裹，但依然会根据body去定位；但是有一个特殊的地方，<font color=FF0000>**如果top bottom left right<font size=4> 都</font> 没有设置，<font size=4>则fixed 的效果和 absolute 一样，相对位置是相较于relative 父元素</font>**</font>。

**sticky** （粘性布局）会像 relative 一样，默认位受到 html 排版的影响，但是一旦页面滚动，将会固定在设置的 top bottom left right 指定的位置。（注：根据阮一峰的[说法](https://www.ruanyifeng.com/blog/2019/11/css-position.html)：<font color=FF0000>sticky 在 **position:relative** 与 **position:fixed** 定位之间切换</font>。）

学习自：[[CSS] 认识 Position](https://www.bilibili.com/video/BV1iE411W7ug)



#### 伪类和伪元素的不同

伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的

伪元素不是 DOM 中的真实元素，但是存在于最终的渲染树中，可以为其添加样式

摘自：[CSS 重点知识汇总](https://www.nowcoder.com/discuss/642120)



#### flexbox

flex-item 中 的属性

- **order** 默认值为0，且order越大，item越靠右边；同理，order越小，item越靠左边

- **align-self** 是用来覆盖 flex-container 的 align-item 的设定的，所以可选值和 align-item 一样

- **flex-basis** 是设置 flex-item 的主轴方向（flex-container根据 flex-direction 来设置）的<font color=FF0000>基础大小</font>的。（即，<font color=FF0000 size=4>是**flex-item的基本宽度**</font>）

- **flex-grow** 是指 当 flex-container 的主轴方向有剩余空间时，flex-item 沿主轴方向扩大的设置。flex-item 会将 <font color=FF0000 size=4>**原本主轴剩余的空间 均分**</font>，并根据 flex-grow 的值分配，<font color=FF0000 size=4>**添加**</font>到原本的 flex-item的 主轴方向的宽度上。

  **举例：**假设 flex-container flex-direction为row，宽度为300px，其中包含 A、B、C三个flex-item；预设宽度为60px，这样就剩下了300px - 3 * 60px = 120px 的宽度。设置B flex-item的 flex-grow为3（flex-grow的值默认为1），则A、B、C的宽度分别为：60px + 120px / (1 + 3 + 1) = 84px，60px + 120px / (1 + 3 + 1) * 3 = 132px，60px + 120px / (1 + 3 + 1) = 84px

- **flex-shrink：**和 flex-grow 相反， 是指当flex-item 主轴方向的大小总和 超过 flex-container时，flex-item 沿着主轴方向如何缩小的设置。

  由于就是flex-grow的逆过程，所以不再举例；需要注意的是：在flex-grow中的剩余空间，在flex-shrink中就是超出的空间。如果flex-shrink = 0 则完全不收缩，如果flex-item的flex-shrink都为0，则会超出flex-container

- **flex：**是 flex-grow、flex-shrink、flex-basis 组合起来的缩写

  - **flex: 1 1 auto：**则同步的、平均的 放大或缩小；同时，完全撑满整个flex-container
  - **flex: 0 1 150px：**则不会放大，但是会缩小；同时，默认宽度（在这里（flex-grow: 0）也可以理解为最大宽度）为150px
  - **flex: 0 0 200px：**不会放大和缩小，固定的宽度为200px

学习自：[Flexbox 网页布局完全解构](https://www.bilibili.com/video/BV1qJ411N7TA)



#### BFC

**BFC的概念：**

Formatting context（格式化上下文）是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。

**那么 BFC 是什么呢？**BFC 即 Block Formatting Contexts 块级格式化上下文，它属于上 普通流 ( common flow )。
**<font color=FF0000>具有 BFC 特性的元素可以看作是 <font size=4>隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素</font></font>，并且 BFC 具有普通容器所没有的一些特性。**
通俗一点来讲，<mark>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部</mark>。

摘自：[10 分钟理解 BFC 原理](https://zhuanlan.zhihu.com/p/25321647)

**文档中有三种流：**

- **普通流：**标准文档流
- **定位流：**使用了position
- **浮动流：**使用了float

这三种流在使用（布局）时会出现一些问题（会相互影响），所以需要使用BFC ( Block Formatting Context ) 块级元素格式上下文 来解决。简单来说BFC就是：<font color=FF0000 size=4>**就是被隔离的区间，BFC的子元素不会对外界的元素产生影响**</font>。

**BFC包含：**

- body元素：天生是BFC
- float: left | right，没有none
- overflow: hidden | scroll | auto，没有visible
- display: inline-block | table-cell | table-caption | flex | grid，没有none、inline 和 block
- position: absolute | fixed，没有relative

**BFC解决的问题：**

- **margin重合：**比如上下兄弟元素，margin-bottom 和 margin-top 会重合

  解决方案：给兄弟元素外层分别套上一个容器（此时他们就不是兄弟了），使得两个容器变成BFC

- **margin塌陷：**比如父子元素，在子元素上加山 margin-top，父元素也会受到margin-top影响而塌陷

  解决方案：使父元素成为BFC

- **高度塌陷：**子元素有宽和高，父元素只有宽度、高度被子元素撑开（为了表现父元素的轮廓，给父元素添加border）；如果设置子元素样式有  `float: right`；则发现父元素消失，表现为：border只有宽度而没有高度了。

  解决方案：使父元素成为BFC。或者父元素使用伪元素，设置伪元素为 `clear: both`，这种方式被称为 clearfix

学习自：[深挖BFC（BFC是什么？怎么触发？解决的是什么问题？怎么解决的？该怎么用？）](https://www.bilibili.com/video/BV1eA411c7Mh)

**BFC解决的问题：**

- **清除浮动：**消除父元素中其他子元素受到浮动子元素的影响
- **包裹浮动：**父盒子的高度没有浮动的子元素高，  这时候子元素会超出父元素；这时可以给父元素创建BFC，以包裹子元素
- **避免边距塌陷：**父元素和子元素都有margin-bottom，两者重合。创建BFC以消除重合

**创建BFC的常见方法：**

- **设置overflow属性：**除了 visible和 clip 以外的值都可以，例如overflaw: hidden<font color=FF0000>（因为可能会影响滚动行为，所以没有display: flow-root 更推荐）</font>

  另外，MDN文档中 不推荐使用overflow，而更推荐 display: flow-root：

  > 使用 overflow 创建新的 BFC 的问题在于， overflow 属性用于告诉浏览器您希望如何处理溢出的内容。在某些情况下，当您纯粹使用此属性创建BFC时，您会发现不需要的滚动条或剪切阴影。另外，对于未来的开发人员来说，它可能不太可读，因为不能显式地表明为什么要使用溢出来实现这一目的。如果您使用了这个方法，最好对代码进行注释以便他人理解。
  >
  > 摘自：[MDN - Introduction to formatting contexts 格式化上下文简介](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts)

- <font color=FF0000 size=4>**设置 display: flow-root**（最推荐使用）</font>，但是还有一个问题是：disploy: flow-root 的兼容性不太好，比如不兼容 IE（学习自：[[CSS] Float](https://www.bilibili.com/video/BV1Gk4y1k7Q5)）

  > flow-root 关键字的意义是，创建的内容本质上类似于一个新的根元素（如 \<html>所做），并确定这个新的上下文如何创建及其流布局如何实现。
  >
  > 摘自：[MDN - Introduction to formatting contexts 格式化上下文简介](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts)

学习自：[什么是 CSS BFC？](https://www.bilibili.com/video/BV1Ug411K7Fz)

另外，这里创建BFC的条件没有介绍完整，详见：[MDN - 块格式化上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)



## JS

#### var let const 以及 函数提升

**变量提升**

var定义的变量会在执行前，提升到作用域顶部；同时，提升到最上方的定义，变量值为 `undefined`；而提升前真正的定义处，才是赋值的地方。

示例如下：

```js
var a = 1
f()
function f() {
  console.log(a)
  if (false) {
    var a = 2
  }
}
```

该代码会变成：

```js
var a // undefined
funtion f() {
  var a // undefined
  console.log(a)
  if (false) {
    a = 2
  }
}
a = 1
f()
```

参考自：[程序员的崩溃早已注定](https://www.bilibili.com/video/BV1rv411K7q8)

在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。（注：JS中一共有三种上下文。下面闭包中有说）

> var是没有块级作用域，但是有函数作用域。
>
> 学习自：[后盾人 - 第九章 这次把JS闭包给你讲得明明白白](https://www.bilibili.com/video/BV1YJ411R7ap)

<font color=FF0000 size=4>**如果变量未经声明就被初始化了， 那么它就会自动被添加到全局上下文**</font>。如下示例：

```js
function add(num1, num2) {   
  var sum = num1 + num2;
  return sum;
}
let result = add(10, 20); // 30 
console.log(sum);         // 报错：sum 在这里不是有效变量
```

这里，函数 add() 定义了一个局部变量 sum，保存加法操作的结果。这个值作为函数的值被返回， 但变量 sum 在函数外部是访问不到的。<mark>如果省略上面例子中的关键字 var，那么 sum 在 add()被调用 之后就变成可以访问的了</mark>，如下所示：

```js
function add(num1, num2) {   
  sum = num1 + num2; // 注意：这里没有var
  return sum; 
}
let result = add(10, 20); // 30 console.log(sum);         // 30
```

这一次，变量 sum 被用加法操作的结果初始化时并没有使用 var 声明。<font color=FF0000 size=4>在调用 add()之后，sum 被添加到了全局上下文，在函数退出之后依然存在，从而在后面可以访问到</font>。注：这是使用var定义，和不使用var直接定义的第二个区别；第一个是不使用var定义可以被delete掉，而使用var定义，无法被delete掉。

**注意：**<font color=FF0000>未经声明而初始化变量是 JavaScript 编程中一个非常常见的错误，会导致很多问题。 为此，读者在初始化变量之前一定要先声明变量</font>。<font color=FF0000 size=4>**在严格模式下，未经声明就初始化变量 会报错**</font>。

另外，如下代码相等：

```js
var name = 'Jake'
// 等价于

name = 'Jake'
var name
```

> **补充：**
>
> 如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：
>
> ```js
> var message = "hi",
>     found = false,
>     age = 29
> ```
>
> 这里定义并初始化了 3 个变量。因为 ECMAScript 是松散类型的，所以使用不同数据类型初始化的 变量可以用一条语句来声明。插入换行和空格缩进并不是必需的，但这样有利于阅读理解。
>
> 摘自：《红宝书 - 第四版 - 3.3 变量》P25

**关于let**

ES6 新增的 let 关键字跟 var 很相似，但<font color=FF0000>它的作用域是块级的，这也是 JavaScript 中的新概念</font>。<font color=FF0000 size=4>**块级作用域由最近的一对包含花括号{}界定。换句话说，if 块、while 块、function 块，甚至连单独的块也是 let 声明变量的作用域**</font>

let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重 复的 let 声明会抛出 SyntaxError

除了 let，ES6 同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。 一经声明，在其生命周期的任何时候都不能再重新赋予新值。`const a; // SyntaxError: 常量声明时没有初始化`

<font color=FF0000>const 声明只应用到顶级原语或者对象</font>。换句话说，赋值为对象的 const 变量不能再被重新赋值 为其他引用值，但对象的键则不受限制。

<font color=FF0000>如果想让整个对象都不能修改，可以使用 Object.freeze()</font>，这样再给属性赋值时虽然不会报错， 但会静默失败：

```js
const o3 = Object.freeze({});
o3.name = 'Jake';
console.log(o3.name); // undefined
```

**标识符查找（简单的说就是：变量查找）**

当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜 索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索 停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个 原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。 如果仍然没有找到标识符，则说明其未声明。

> 在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方式来引用未声明的变量。<font color=FF0000>在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone）</font>，<mark>在此阶段引用任何后面才声明的变量都会抛出 ReferenceError</mark>。
>
> **新的解释：**
>
> ```js
> for (var i = 0; i < 5; ++i) {
> 	setTimeout(() => console.log(i), 0)
> } // 会输出 5、5、5、5、5
> ```
>
> 之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时 逻辑时，所有的 i 都是同一个变量，因而输出的都是同一个最终值。
>
> 摘自：红宝书 - 第四版 - 3.3变量 P26

**以上摘自：**红宝书 - 第四版 - 4.2.2 变量声明 ( P90 ) 起

**以下内容（直到单行的“摘自”）摘自：**[我用了两个月的时间才理解 let](https://zhuanlan.zhihu.com/p/28140450)

```js
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i<liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
```

**代码中隐藏点如下：**作者在这里参考了 [ES文档 - 13.7.4.7 章节](https://link.zhihu.com/?target=http%3A//www.ecma-international.org/ecma-262/6.0/%23sec-for-statement-runtime-semantics-labelledevaluation)

1. **for( let i = 0; i< 5; i++) 这句话的圆括号之间，有一个隐藏的作用域**
2. **for( let i = 0; i< 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。**

**所以上面的代码可以近似理解为：**

```js
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i<liList.length; i++){
  let i = 隐藏作用域中的i // 看这里看这里看这里
  liList[i].onclick = function(){
    console.log(i)
  }
}
```

那样的话，5 次循环，就会有 5 个不同的 i，console.log 出来的 i 当然也是不同的值。再加上隐藏作用域里的 i，一共有 6 个 i。

总得来说就是：let/const 在与 for 一起用时，会有一个 per-iteration-bindings 的概念（一种语法糖）。

<font size=4>**let到底有没有类型提升？**</font>

首先明确一点：提升不是一个技术名词。

要搞清楚提升的本质，需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」。

有的地方把创建说成是声明（declare），为了将这个概念与变量声明区别开，我故意不使用声明这个字眼。

有的地方把初始化叫做绑定（binding），但我感觉这个词不如初始化形象。

- **我们来看看 var 声明的「创建、初始化和赋值」过程**。假设有如下代码：

  ```js
  function fn(){ var x = 1 var y = 2 }
  fn()
  ```

  **在执行 fn 时，会有以下过程（不完全）：**

  1. 进入 fn，为 fn 创建一个环境

  2. 找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）

  3. <font color=FF0000>将这些变量「初始化」为 undefined</font>（注：这里只是初始化，而不是赋值）

  4. 开始执行代码

  5. x = 1 将 x 变量「赋值」为 1

  6. y = 2 将 y 变量「赋值」为 2

  也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。

- **接下来来看 function 声明的「创建、初始化和赋值」过程**假设代码如下：

  ```js
  fn2()
  function fn2(){ console.log(2) }
  ```

  **JS 引擎会有以下过程：**

  1. <font color=FF0000 size=4>找到所有用 function 声明的变量，在环境中「创建」这些变量</font>

  2. <font color=FF0000 size=4>将这些变量「初始化」并「赋值」为 function(){ console.log(2) }</font>

  3. 开始执行代码 fn2()

  也就是说 function 声明会在代码执行之前就「创建、初始化并赋值」。

- **接下来看 let 声明的「创建、初始化和赋值」过程**。假设代码如下：

  ```js
  { let x = 1; x = 2 }
  ```

  **我们只看 {} 里面的过程：**

  1. <font color=FF0000 size=4>找到所有用 let 声明的变量，在环境中「创建」这些变量</font>

  2. 开始执行代码（注意现在还没有初始化）

  3. 执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）

  4. 执行 x = 2，对 x 进行「赋值」

  **这就解释了为什么在 let x 之前使用 x 会报错：**执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）

- **接下来讨论 var foo 和 function foo() 的优先级：**下面两种写法，结果都是 [Function: foo]

  ```js
  var foo
  function foo()
  console.log(foo) // [Function: foo]
  ```

  ```js
  function foo() {}
  var foo
  console.log(foo) // [Function: foo]
  ```

  由于<font color=FF0000>（注：在该环境（执行上下文中）的**变量创建阶段**）</font> <font color=FF0000 size=4>**function 比 var 多一个「赋值」过程**</font>，所以两个代码的输出都是函数。你也可以记住结论：function 比 var 牛逼。

- **最后看 const**，其实 const 和 let 只有一个区别，那就是 <font color=FF0000>const 只有「创建」和「初始化」</font>，<font color=FF0000 size=4>**没有「赋值」过程**</font>（因为初始化的值就是let赋值的值）。

<font color=FF0000 size=4>**这四种声明，用下图就可以快速理解：**</font>（注：这张图很精髓）

![img](https://pic1.zhimg.com/80/v2-9c8c4a0a3ce5402b1a74f488d79c74d0_720w.png)

所谓暂时死区，就是不能在初始化之前，使用变量。

故事依然没有结束，这周我在知乎上问了一个问题：[如何理解 let x = x 报错之后，再次 let x 依然会报错？](https://www.zhihu.com/question/62966713)（这个问题是饥人谷的学生问我的）

![img](https://s2.loli.net/2022/01/08/MziC7vRtZKrlNSp.png)

这个问题说明：<font color=FF0000>**如果 let x 的初始化过程失败了，那么：**</font>

<font color=FF0000 size=4>**x 变量就将永远处于 created 状态**</font>。<font color=FF0000 size=4>**无法再次对 x 进行初始化（初始化只有一次机会，而那次机会你失败了）**</font>。<font color=FF0000 size=4>**由于 x 无法被初始化，所以 x 永远处在暂时死区**（处于一种：「既被定义了，又没被定义」的中间状态）</font>（也就是盗梦空间里的 limbo）！

有人会觉得 JS 坑，怎么能出现这种情况；其实问题不大，因为此时代码已经报错了，后面的代码想执行也没机会。

摘自：[我用了两个月的时间才理解 let](https://zhuanlan.zhihu.com/p/28140450)

补充：在TDZ状态中，let 声明的变量 会被设置为 \<uninitialized> 标志位

学习自：[JS夯实之执行上下文与词法环境](https://juejin.cn/post/6844904145372053511) 另外，[现代js教程 - 变量作用域，闭包](https://zh.javascript.info/closure) 中也有提到

##### 变量和函数提升优先级的补充

经过实验发现：function关键字定义的函数 > var变量接收的一般变量/函数（可以认为是函数是第一公民）；且相同优先级下，后面的定义会覆盖前面的定义。**另外：**根据《现代JS教程》中的说法（如下），函数表达式没有函数提升：

> 这种行为（注：变量提升）仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 let say = function(name)...
>
> 摘自：[现代JS教程 - 变量作用域，闭包](https://zh.javascript.info/closure)

```js
console.log(foo)

var foo = 1;                                           // 1
var foo = function() { console.log('foo var fn') }     // 2
function foo() { console.log('foo fn') }               // 3
function foo() { console.log('foo fn 2') }             // 4
```

只有 1 和 3 的情况下（顺序不变），打印结果为 3 的定义；只有 3 和 4 的情况下，打印结果为 'foo fn 2'。只有 1 和 2 的情况下，打印结果为 undefined，因为“函数表达式”不能“函数提升”。其他结果，自己实验。

另外，值得说明的是：函数在后面被调用的时候，只会使用最后一个定义（且没有被提升）的（之前定义的被覆盖了）。如下：

```js
// 上面定义代码略
foo() // foo var fn，函数表达式没有提升，所以覆盖了其他已经提升的函数定义，最后运行。
```

这里可以参考[[JS面试题#变量 函数提升]]第2题



number 类型转换规则（注：即使用Number()函数 显式转换）

| 值            | 变成……                                                       |
| :------------ | :----------------------------------------------------------- |
| undefined     | NaN                                                          |
| null          | 0                                                            |
| true 和 false | 1 and 0                                                      |
| string        | 去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 0。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 NaN。 |

摘自：[现代JS教程 - 类型转换](https://zh.javascript.info/type-conversions)



#### 箭头函数 总结

- **没有 this**

  > **补充：**由于 箭头函数没有自己的this指针，<font color=FF0000 size=4>通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this ---译者注），他们的**第一个参数会被忽略**</font>。（这种现象对于 bind 方法同样成立 ---译者注）
  >
  > 摘自：[MDN - 箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

- **没有 arguments**

- **不能使用 new 进行调用**（**注：**即<font color=FF0000>不能作为构造函数</font>）。

  MDN 中没有说明原因，可以参考下：[99.9%的人都不知道的箭头函数不能当做构造函数的秘密](https://juejin.cn/post/7050492355056664612)

  > **一句话答案：**
  >
  > <font color=FF0000>因为箭头函数没有`[[Construct]]`这个内部槽</font>（注：即内部属性）。
  >
  > **进一步解释：**
  >
  > <font color=FF0000>**函数对象** 是一个支持 `[[Call]]`、`[[Construct]]` 内部方法的对象</font>。<font color=FF0000>每个支持 `[[Construct]]` 的对象必须支持 `[[Call]]`，也就是说，每个构造函数必须是一个函数对象</font>。因此，构造函数也可以被称为 “构造函数函数”或“构造函数对象”。 所以，<font color=FF0000><font size=4>**想要对某个对象使用 `new`，就得确保该对象具有 `[[Construct]]` 这个内部方法**</font>。而箭头函数没有 `[[Construct]]`</font>
  >
  > **为什么没有 `[[Construct]]`：**
  >
  > 因为<font color=FF0000>箭头函数设计之初，就是为了设计一种更简短的函数并且不绑定 `this`</font>；<font color=FF0000>所以 <font size=4>**箭头函数不为参数 `super`、`this` 或 `new.target` 定义本地绑定**</font></font>。<mark>箭头函数中的</mark> <font color=FF0000>**`this`、`super`、`arguments` 及 `new.target`**</font> <mark>这些值由外围最近一层非箭头函数决定</mark>。而这样的一个函数设计者认为没有必要委托给能够 `[[Construct]]` 的目标函数，所以箭头函数没有 `[[Construct]]`。<font color=FF0000>同时因为没有构造原型的需求，所以**箭头函数不存在 `prototype` 属性**</font>。
  >
  >
  > 摘自：[99.9%的人都不知道的箭头函数不能当做构造函数的秘密](https://juejin.cn/post/7050492355056664612)

- **它们也没有 super**

摘自：[现代JS教程 - 深入理解箭头函数](https://zh.javascript.info/arrow-functions)

##### 工作时发现的箭头函数遗漏的重点补充

<font color=FF0000 size=4>用 params => { object: literal } 这种简单的语法返回对象字面量是行不通的</font>

```js
var func = () => { foo: 1 }; // Calling func() returns undefined!
var func = () => { foo: function() {} }; // SyntaxError: function statement requires a name
```

这是因为 <font color=FF0000 size=4>**花括号( {} )里面的代码被解析为一系列语句**</font>（即 foo 被认为是一个标签，而非对象字面量的组成部分）。<mark>**注：**这里可以参考下[[#IIFE 相关]] 中使用`()` 消除function 作为一个函数定义标识的歧义</mark>。

所以，记得用圆括号把对象字面量包起来：

```js
var func = () => ( {foo: 1} );
```

##### 其他 MDN 中说明的

- <font color=FF0000>箭头函数在参数和箭头之间不能换行</font>

  ```js
  var func = ()
             => 1; // SyntaxError: expected expression, got '=>'
  ```

  但是，可以通过在 ‘=>’ 之后换行，或者用 ‘( )’、'{ }'来实现换行，如下：

  ```js
  var func = (a, b, c) =>
    1;
  
  var func = (a, b, c) => (
    1
  );
  
  var func = (a, b, c) => {
    return 1
  };
  
  var func = (
    a,
    b,
    c
  ) => 1;
  ```

- yield 关键字通过不能在 箭头函数 中使用。

摘自：[MDN - 箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)



#### 可迭代( iterable ) 和 类数组( array-like )

- **Iterable：**是实现了 `Symbol.iterator` 方法的对象。

  - obj\[Symbol.iterator]() 的结果被称为 **迭代器（iterator）**
  - 一个迭代器必须有 `next()` 方法，它返回一个 `{done: Boolean, value: any}` 对象，这里 `done:true` 表明迭代结束，否则 `value` 就是下一个值。
  - `Symbol.iterator` 方法会被 `for..of` 自动调用，但我们也可以直接调用它。
  - 内建的可迭代对象例如字符串和数组，都实现了 `Symbol.iterator`。
  - 字符串迭代器能够识别代理对（surrogate pair）。（译注：代理对也就是 UTF-16 扩展字符。）

- **Array-like：** 是有 索引 和 `length` 属性的对象，所以它们看起来很像数组。比如：

  ```js
  let arrayLike = {
    0: "Hello",
    1: "World",
    length: 2
  };
  ```

一个可迭代对象也许不是类数组对象。反之亦然，类数组对象可能不可迭代。

全局方法 Array.from 可以接受一个 <font color=FF0000 size=4>**可迭代 **</font> 或 类数组 的值，并从中获取一个“真正的”数组

摘自：[现代JS教程 - Iterable object（可迭代对象）](https://zh.javascript.info/iterable)



#### 迭代器 和 生成器

实现迭代器必须要： 实现 可迭代协议 和 迭代器协议

<font color=FF0000 size=4>**生成器 可以 生成迭代器**</font>，代码示例如下：

```js
function* genFn() {
  yield 1
  yield 2
  yield 3
  yield 4
}

const iterator = genFn()
for (const it of iterator) {
  console.log(it) // 1 2 3 4
}

const iterator2 = genFn()
console.log(iterator2.next()) // { value: 1, done: false }
console.log(iterator2.next()) // { value: 1, done: false }
console.log(iterator2.next()) // { value: 1, done: false }
console.log(iterator2.next()) // { value: 1, done: false }
console.log(iterator2.next()) // { value: undefined, done: true }
```

**生成器函数的返回值由 yield 决定，和return起到了类似的效果，但return只能return 一次，return多次不起效果；但yield 可以多次。**如下示例，另外：示例的生成器函数中也加上了打印，注意打印结果：

```js
function* genFn() {
	console.log('1')
  yield 2
  console.log('3')
  return 'ret'
}

const genRet = genFn()
console.log(genRet)
console.log(genRet.next())
console.log(genRet.next())
// Object [Generator] {} **打印结果不是return的 'ret'**
// 1
// { value: 2, done: false }
// 3
// { value: ret, done: true }
```

如果把 return 'ret' 放到上面，yield 会失效；return 会作为next()的结果：

```js
function* genFn() {
  return 'ret'
	console.log('1')
  yield 2
  console.log('3')
}

const genRet = genFn()
console.log(genRet)
console.log(genRet.next()) 
console.log(genRet.next())
// Object [Generator] {}
// { value: 'ret', done: true } 注：这时候，yield将不会执行
// { value: undefined, done: true }
```

调用生成器函数 next()，是可以在next() 种传递参数的，并且传入的参数，被上一个 yield 函数接收：

```js
function* genFn() {
  const arg = yield 1
  console.log(arg) // arg2
  yield 2
}

const iterator = genFn()
iterator.next('arg1')
iterator.next('arg2')
```

可以通过return 来类比解释，运行到 `yield 1` 时，代码暂停，前面的 `const arg` 也没有执行，等待下次调用 next()。下次调用 next() 时，yield 2 调用，此时 const arg 也执行了，并接收到 第二次 next() 传来的参数 arg2；所以打印结果为 arg2。

async-await 是通过 生成器函数 和 执行器函数 产生的，执行器函数由 TJ 的 [co](https://github.com/tj/co) 实现。执行器的实现就是不断的调用 next() 方法，拿到yield 语句 获得的值；使用获取的值，再调用next() 方法

**异步概念补充：**

- **异步：**因为js是单线程，同时为了提高执行效率，避免等待的解决方案：异步
- 异步的解决方案是：事件轮询
- 事件轮询 的 核心思想是：回调函数

**promise面试题**

第一题：

```js
Promise.resolve()
       .then(() => new Error('errr!!!') )
       .then(res => console.log('then', res))
       .catch(err => console.log('catch', err))
// then Error: errr!!! 
// 注意：这里是then，而不是catch；因为这里还是new了一个Error并返回，还是相当于Promise.resolve(new Error('errr!!!')) ；而不是抛出(throw)一个Error。如果是 throw new Error('errr!!!')，则打印catch
```

第二题：

```js
Promise.resolve()
       .then(() => {
         Promise.resolve().
                 then(() => {
                   console.log(1)
                 })
                 .then(() => {
                   console.log(2)
                 })
       })
       .then(() => {
         console.log(3)
       })
// 1 3 2，原因：这里 1和3 的 then是同一层的，所以先后进入微任务队列，3的promise最后进入微任务队列
```

想要上面的结果改为 1 2 3：

```js
Promise.resolve()
       .then(() => {
  			 // 在这里加上 return，形成依赖
         return Promise.resolve().
                 then(() => {
                   console.log(1)
                 })
                 .then(() => {
                   console.log(2)
                 })
       })
       .then(() => {
         console.log(3)
       })
```

第三题：

```js
async function async1() {
  await async2() // 这里可以看做：async2先执行，await后执行。然后，await返回的一定是一个promise，所以下面的会被放入微任务队列；所以下面的 console.log(10) 先执行。另外，根据 coderwhy 的结论：第一个 await 看作是 new promise(resolve, reject)的东西，后面的 await 都是 promise.then
  console.log('async1 end')
}

async function async2() {
  console.log('async2 end')
}

async1()
console.log(10)
// async2 end - 10 - async1 end
```

第三题变种：

```js
async function async1() {
  await async2()
  console.log('async1 end')
}

async function async2() {
  console.log('async2 end')
  return Promise.reject() // 比原题 这里多了 reject
}

async1()
console.log(10)
// async2 end - 10 - UnhandledPromiseRejection 报错
// 注：如果要让UnhandledPromiseRejection消失，可以给 await-async2() 包上 try-catch
```

**第四题：**据说这题是快手的面试题

```js
let a;
const b = new Promise((resolve, reject) => {
  console.log('promise1') // 1，new Promise()中 同步代码
  resolve();
}).then(() => {
  console.log('promise2 // 4
}).then(() => {
  console.log('promise3') // 5
}).then(() => {
  console.log('promise4') // 6
})

a = new Promise(async (resolve, reject) => { // promise内代码为同步代码
  console.log(a) // 2，结果为 undefined，由于这里没有a还没有完成赋值，所以a为undefined
  await b; // 打印完成a为undefined之后，会执行b，因为b是微任务，所以先放入微任务队列，所以下面的 end 先打印
  console.log(a) // 7 这时候，由于 await b返回的是一个promise，所以a已经完成赋值；但是，在a中没有 resolve 和 reject，所以结果为 Promise { <pending> }
  console.log('after1') // 8
  await a // 这里a是一个promise，但还是pending状态，所以后面的代码（包括resolve），都不会执行
  resolve(true)
  console.log('after2') // 不会执行
})

console.log('end') // 3
```

注：上面的 await a 下面的代码之所以不会执行，是因为：只有 await 返回结果为 fulfilled 时，后面的代码才会执行。如下示例：

```js
const promise = new Promise((resolve, reject) => {})

async function fn() {
  console.log(promise) // Promise { <pending> }
  await promise
  console.log('never run') // 没有打印
}

fn()
```

学习自：[【全网首发:更新完】promise的前世今生 + 应用 + 面试 + 源码 【合集】](https://www.bilibili.com/video/BV1tM4y1F7he)



**浏览器常驻的线程：**

1.	js 引擎线程（解释和执行js 代码,  JS内核-V8引擎 ，js引擎用来解释执行js代码 ）
2.	GUI 线程（绘制用户界面， 与js 主线程是互斥的）
3.	http 网络请求线程（处理用户的get， post 等请求等， 返回结果后讲回调函数推入到任务队列）
4.	定时器触发线程（setTimeout， setInterval 等待时间结束后把执行函数推入到任务队列中）
5.	浏览器事件处理线程（将 click， mouse 等交互事件发生后将这些事件放入到事件队列中）

摘自：[promise铺垫--前篇【 JS的执行机制 】](https://www.bilibili.com/video/BV18z4y1y7mf) 的评论区



#### 宏任务和微任务

- **宏任务队列** ( macrotask queue ) : 

  - \<script>标签中的运行代码（注：<font color=FF0000 size=4>**整个script标签是个宏任务**</font>）

  - 网络任务源：ajax、fetch

  - <font color=FF0000>事件触发的回调函数</font>：例如 DOM Events、I/O、requestAnimationFrame（注：关于 requestAnimationFrame 是否是“宏任务”，存在异议。在 [深入探究 eventloop 与浏览器渲染的时序问题](https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering) 中，作者发现 如下代码，运行 结果为 B C A）

  - setTimeout、setInterval的回调函数、setImmediate（非标准的函数）

  - UI Rendering

  - DOM 操作任务源：如元素以非阻塞方式插入文档

  - History API：原文是 

    > **The history traversal task source:** This task source is used to queue calls to history.back() and similar APIs. 
    >
    > 摘自：[whatwg - 8.1.6.4 Generic task sources](https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources)

  - IndexDB 数据库操作等 I/O

  **补充：**关于fetch是宏任务

  > fetch 不是一个单纯的promise。关键在于，fetch会发起一个网络请求，当请求被响应时，怎么通知主线程来处理回调? 在 XHR 中，是将回调放入对应于网络请求的任务队列中，fetch是否也是这样呢？
  >
  > 对于fetch，其实浏览器还是沿用一样的网络请求处理逻辑，只是在响应时，推入对应任务队列的任务，执行了将promise回调推入微任务的动作。
  >
  > 摘自：[fetch返回一个promise，所以它在收到响应时直接进入微任务队列么？](https://ginobilee.github.io/blog/2019/01/28/xhr%20vs%20fetch/)

- 微任务队列 ( microtask queue ) : 
  - **Promise的then回调：**（<font color=FF0000 size=4>**在promise.then回调 前面的代码 还算同步代码**</font>）
  - **async / await：**
    - <font color=FF0000>**把await关键字后面执行的代码，看作是包裹在 (resolve, reject) => { ... } 中的代码**</font>
    - <font color=FF0000>**await 的下一条语句，可以看做 .then( res => { ... } ) 中的代码 ）**</font>
  - Mutation Observer API
  - queueMicrotask等
  - Proccess.nextTick（Node）

上面，宏任务有哪些 的部分内容摘自：[深入探究 eventloop 与浏览器渲染的时序问题](https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering)。另外，其中有一些不常见的宏任务，是引用自：[whatwg - 8.1.6.4 Generic task sources](https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources)，所以还是非常靠谱的。下面的内容是他的具体内容，这里摘抄过来：

> **8.1.6.4 Generic task sources**
>
> The following task sources are used by a number of mostly unrelated features in this and other specifications.
>
> - **The DOM manipulation task source:** This task source is used for features that react to DOM manipulations, such as things that happen in a non-blocking fashion when an element is inserted into the document.
>
> - **The user interaction task source:** 
>
>   This task source is used for features that react to user interaction, for example keyboard or mouse input.
>
>   Events sent in response to user input (e.g. click events) must be fired using tasks queued with the user interaction task source. [UIEVENTS]
>
> - **The networking task source:** This task source is used for features that trigger in response to network activity.
>
> - **The history traversal task source:** This task source is used to queue calls to history.back() and similar APIs.

**事件循环**

<img src="https://s2.loli.net/2022/01/19/GhMOyJw1D9YjAlQ.png" alt="img" style="zoom: 43%;" />

上图是对的，微任务 先于 宏任务执行也是对的；因为 \<script> 标签就是一个宏任务。要先执行上下文，这就是所谓的第一个宏任务；宏任务就是浏览器事件的callback。

可以理解为：每一个宏任务都会有一个微任务跟着，所以在当前宏任务结束之前，要执行本次宏任务中的微任务；接着再去执行下一个宏任务。

**event loop 就是浏览器 + js引擎 + 渲染引擎  合作的一个循环机制**

以上内容，摘自 codingstartup 微信群，关于 微任务 和 宏任务的讨论

**其他补充：**

> 任务队列分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为 task 与 jobs。
>
> 摘自：[前端基础进阶（十四）：深入核心，详解事件循环机制]()

**以下内容摘自：**[MDN - 在 JavaScript 中通过 queueMicrotask() 使用微任务](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide)

一个 **任务** 就是由执行诸如从头执行一段程序、执行一个事件回调或一个 interval/timeout 被触发之类的标准机制而被调度的任意 JavaScript 代码。这些都在 **任务队列（task queue）**上被调度。

在以下时机，任务会被添加到任务队列：

- 一段新程序或子程序被直接执行时（比如从一个控制台，或在一个 \<script> 元素中运行代码）。
- 触发了一个事件，将其回调函数添加到任务队列时。
- 执行到一个由 setTimeout() 或 setInterval() 创建的 timeout 或 interval，以致相应的回调函数被添加到任务队列时。

以下内容，摘自：[浏览器和 Node.js 的 EventLoop 为什么这么设计？ - 神说要有光的文章 - 知乎](https://zhuanlan.zhihu.com/p/453370934)

**怎么理解宏微任务的划分呢？**

- 定时器、网络请求 这种都是在别的线程跑完之后通知主线程的普通异步逻辑，所以都是宏任务。

- 而高优任务的这三种（Promise.then、MutationObserver、Object.observe）也很好理解，MutationObserver 和 Object.observe 都是监听某个对象的变化的，变化是很瞬时的事情，肯定要马上响应，不然可能又变了，Promise 是组织异步流程的，异步结束调用 then 也是很高优的。

<font color=FF0000>**浏览器的 Event Loop 只分了两层优先级，一层是宏任务，一层是微任务**。但是宏任务之间没有再划分优先级，微任务之间也没有再划分优先级</font>。

而 Node.js 任务宏任务之间也是有优先级的，比如定时器 Timer 的逻辑就比 IO 的逻辑优先级高，因为涉及到时间，越早越准确；而 close 资源的处理逻辑优先级就很低，因为不 close 最多多占点内存等资源，影响不大。于是就把宏任务队列拆成了五个优先级：Timers、Pending、Poll、Check、Close。

![img](https://s2.loli.net/2022/01/24/cC4M7f9Xqm3L6gN.jpg)

- **Timers Callback**： 涉及到时间，肯定越早执行越准确，所以这个优先级最高很容易理解。

- **Pending Callback**：处理网络、IO 等异常时的回调，有的 *niux 系统会等待发生错误的上报，所以得处理下。

- **Poll Callback**：处理 IO 的 data，网络的 connection，服务器主要处理的就是这个。

- **Check Callback**：执行 setImmediate 的回调，特点是刚执行完 IO 之后就能回调这个。

- **Close Callback**：关闭资源的回调，晚点执行影响也不到，优先级最低。

(Node) 除了宏任务有优先级，微任务也划分了优先级，多了一个 process.nextTick 的高优先级微任务，在所有的普通微任务之前来跑。

**以下内容，摘自：**[深入探究 eventloop 与浏览器渲染的时序问题](https://www.404forest.com/2017/07/18/how-javascript-actually-works-eventloop-and-uirendering/#3-microtask-的执行时机)

<font size=4>**每轮eventloop 是如何执行的：**</font>

1. 从 task 队列（一个或多个）中选出最老的一个 task，执行它。<font color=FF0000>**注：<font size=4>这里的task队列是指 macrotask 队列</font>**，下面也会说到</font>
2. 执行 microtask 检查点。简单说，会执行 microtask 队列中的所有 microtask，直到队列为空。如果 microtask 中又添加了新的 microtask，直接放进本队列末尾。
3. **执行 UI render 操作：**
   1. <font color=FF0000>**判断 document 在此时间点渲染是否会「获益」**</font>。<mark>浏览器只需保证 60Hz 的刷新率即可</mark>（在机器负荷重时还会降低刷新率），<mark>若 eventloop 频率过高，即使渲染了浏览器也无法及时展示</mark>。所以 <font color=FF0000>**并不是每轮 eventloop 都会执行 UI Render**</font>。
   2. <font color=FF0000>**执行各种渲染所需工作**</font>，如 触发 resize、scroll 事件、建立媒体查询、运行 CSS 动画等等
   3. 执行 animation frame callbacks
   4. 执行 IntersectionObserver callback
   5. 渲染 UI

用一张图来概括整体流程：

![eventloop-1](https://s2.loli.net/2022/01/19/MVpmZcUk5ufnXsl.png)



#### 垃圾回收 与 weakMap weakSet

垃圾回收的主要概念：JavaScript 中主要的内存管理概念是 <font color=FF0000 size=4>**可达性**</font>

**weakMap 和 weakSet存在的意义，示例如下：**

- 单纯的对象赋值为null，可以回收内存

  ```js
  let john = { name: "John" };// 该对象能被访问，john 是它的引用
  john = null; // 覆盖引用
  console.log(john) // null，该对象将会被从内存中清除
  ```

- 对 对象或者数组中的 对象赋值为空，对象中的对象不会被内存回收

  ```js
  let john = { name: "John" };
  let obj = { john }
  
  john = null
  console.log(obj) // 前面由 john 所引用的那个对象被存储在了 obj 中，所以它不会被垃圾回收机制回收
  ```

- **使用 weakMap，内存会被回收**

  ```js
  let john = { name: "John" };
  
  let weakMap = new WeakMap();
  weakMap.set(john, "...");
  
  john = null; // 覆盖引用
  console.log(weakMap.get(john))  // john 被从内存中删除了！
  ```

WeakMap 是类似于 Map 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问它们，便会将它们与其关联值一同删除。

WeakSet 是类似于 Set 的集合，它仅存储对象，并且一旦通过其他方式无法访问它们，便会将其删除。

**WeakMap 只支持如下方法：**

- weakMap.get(key)
- weakMap.set(key, value)
- weakMap.delete(key)
- weakMap.has(key)

不支持迭代以及 keys()，values() 和 entries() 方法。这是由JS引擎的实现机制决定的。

**类似的：** weakMap 只支持 add、has、delete 方法，不支持 size 和 keys()

以上学习自：[现代JS教程 - WeakMap and WeakSet（弱映射和弱集合）](https://zh.javascript.info/weakmap-weakset)



#### new 操作符 的执行步骤

1. <font color=FF0000>创建一个空的</font>简单<font color=FF0000> JavaScript 对象</font>（即 {} ）；
2. <font color=FF0000>为</font> 步骤1 <font color=FF0000>新创建的对象添加属性 \__proto__</font>，<font color=FF0000 size=4>**将该属性链接至构造函数的原型对象 **</font>；
3. <font color=FF0000>将</font> 步骤1 <font color=FF0000>新创建的对象 <font size=4>**作为 this 的上下文**</font> </font>；
4. <font color=FF0000>如果该函数没有返回对象，则返回 this</font>。

**示例：**当代码 new Foo(...) 执行时，会发生以下事情：

1. 一个继承自 Foo.prototype 的新对象被创建  。
2. 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。
3. 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）

摘自：[MDN - new 运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new)



#### call，apply，bind

这三者都可以借用函数

- **call：**可以添加（多个，假设有n个）参数，第一个参数是借用函数的对象，后面的 n-1 个参数是被借用对象的函数的参数。立即执行
- **apply：**可以添加两个参数，第一个参数是借用方法的对象，第二个参数是一个数组。立即执行。
- **bind：**可以添加一个参数，是借用方法的对象；不是立即执行，而是返回一个函数，等待调用方法的对象手动调用该函数，才会执行

参见：[【JS】两分钟说完call, apply和bind](www.bilibili.com/video/BV1Ug411F7fZ)

**补充：**

bind 函数相当于：希望一个函数“永久的”、“显式的”绑定到一个对象上（注：经过实验后发现这种说法似乎并不很准确，因为bind只是返回一个函数，需要手动接住。而如何接住是调用者的事情了，可以用一个函数变量（`const fn = boundFn.bind(bindObj)`），但这样fn并没有绑定到bindObj下。需要手动绑定（ `bindObj.fn = boundFn.bind(bindObj)` ）才行）；而使用call 和 apply 不会将一个函数以属性的形式“永久的”绑定到对象中。

另外，可以使用 apply 或者 call 实现bind：

```js
function bind(func, obj) {
  return function() {
    return func.apply(obj, arguments);
  }
}
```

另外，如果call apply中第一个对象传入的是 null、undefined，那么，该显式绑定将会被忽略。示例如下：

```js
function bindFn() { console.log(this) }

bindFn.call(null) //打印结果：window对象
```

参考自：[前端面试之彻底搞懂this指向](https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA)

**call 和 apply的区别：**call的thisArg 是可选的，而apply的thisArg 是必填的。

参考自：[MDN - Function.prototype.call()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call) 和 [MDN - Function.prototype.apply()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)



#### this 在不同情况下的指向

<font color=FF0000>JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变</font>。

- 在**对象方法**中，this 表示**该方法所属的对象**。

- 如果**单独使用**，this 表示**全局对象**（在严格模式下也是这样）。

- 在**函数**中，（宽松模式下 浏览器中？）this 表示**全局对象**。在**严格模式**下，**this 是未定义的 **(undefined)。

- 在**类**中： 

  > <font color=FF0000><font size=4>**this 在 类 中的表现与在函数中类似**</font>，因为 <font size=4>**类本质上也是函数**</font></font>，但也有一些区别和注意事项。
  >
  > <font color=FF0000>在类的构造函数中，this 是一个常规对象</font>。类中所有非静态的方法都会被添加到 this 的原型中
  >
  > **派生类中的this：**不像基类的构造函数，派生类的构造函数没有初始的 this 绑定。在构造函数中调用 super() 会生成一个 this 绑定，并相当于执行如下代码，Base为基类：
  >
  > ```js
  > this = new Base();
  > ```
  >
  > **注意⚠️：**在调用 super() 之前引用 this 会抛出错误
  >
  > 摘自：[MDN - this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)

- 在**事件**中，this 表示**接收事件的元素**。

  > 即 this === event.currentTarget
  >
  > 摘自：[MDN - this](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this)

- 类似 call() 和 apply() 方法可以将 this 引用到任何对象。

注意⚠️：这里没有在“对象”中，只有在“对象方法”中；所以如下代码，this指向的是全局

```js
let obj = {
  arrowFn: () => { console.log(this) }
}
obj.arrowFn() // window
```

还有，在对象中的 this（我不知道属于上面的哪一种），是全局对象；实验如下：

```js
let obj = {
  thisVal: this,
  consoleThis() {
    console.log(this.thisVal)
  }
}
obj.consoleThis() // window
```

摘自：[runoob - JavaScript this 关键字](https://www.runoob.com/js/js-this.html)

#### this的绑定（学习自 coderwhy 的文章）

在常见的编程语言中，几乎都有this这个关键字（Objective-C（还有Python）中使用的是self ），但是JavaScript中的this和常见的面向对象语言中的this不太一样：

- <mark>常见面向对象的编程语言中</mark>，比如Java、C++、Swift、Dart等等一系列语言中，<mark>**this通常只会出现在 类的方法 中**</mark>。也就是你需要有一个类，<font color=FF0000>**类中的方法（特别是实例方法）中，this代表的是当前调用对象**</font>。
- 但是 <font color=FF0000>JavaScript 中的 this 更加灵活，无论是它出现的位置还是它代表的含义</font>。

**如果没有this，那么我们的代码会是下面的写法：**

在方法中，为了能够获取到name名称，必须通过obj的引用（变量名称）来获取。但是这样做有一个很大的弊端：如果我将obj的名称换成了info，那么所有的方法中的obj都需要换成info。

```js
var obj = {
  name: "why",
  running: function() { console.log(obj.name + " running") },
  eating: function() { console.log(obj.name + " eating") },
  studying: function() { console.log(obj.name + " studying") }
}
```

事实上，上面的代码，在实际开发中，我们都会使用this来进行优化：

当我们通过obj去调用running、eating、studying这些方法时，this就是指向的obj对象

```js
var obj = {
  name: "why",
  running: function() { console.log(this.name + " running") },
  eating: function() { console.log(this.name + " eating") },
  studying: function() { console.log(this.name + " studying") }
}
```

所以我们会发现，<font color=FF0000>在某些函数或者方法的编写中，this可以让我们更加便捷的方式来引用对象，在进行一些API设计时，**代码更加的简洁和易于复用**</font>。

**全局作用域下：**在浏览器中，this指向 window（Node中没有window，需要使用global；web worker需要使用self ）

但是，<mark>开发中很少直接在全局作用域下去使用this，通常都是在**函数中使用**</mark>。

<font color=FF0000>**所有的函数在被调用时，都会创建一个执行上下文（即：运行环境）**</font>：<font color=FF0000 size=4>**这个上下文中记录着函数的 调用栈、函数的调用方式、传入的参数信息等**</font>；<font color=FF0000>**this也是其中的一个属性**</font>。

**如下示例：**<font color=FF0000>定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果</font>

```js
// 定义一个函数
function foo() { console.log(this) }

// 调用方式一: 直接调用
foo(); // window

// 调用方式二: 将foo放到一个对象中,再调用
var obj = { name: "why", foo } // 注意：这里 obj.foo = foo()，es6 省略写法
obj.foo() // { name: 'why', foo: [Function: foo] }。即：obj对象

// 调用方式三: 通过call/apply调用
foo.call("abc"); // String {"abc"}对象
```

**上面的示例可以给我们的启示：**

- <font color=FF0000>函数在调用时，JavaScript 会默认给 this 绑定一个值</font>
- this的绑定和 <font color=FF0000>定义（编写代码）的位置</font> <font size=4>**没有关系**</font>
- this的绑定和 <font color=FF0000 size=4>调用方式以及调用的位置</font> <font size=4>**有关系**</font>
- <font color=FF0000 size=4>**this是在运行时被绑定的**</font>（注：即是 动态的）

<font size=4>**this的绑定规则**</font>

- **默认绑定：**在<font color=FF0000>**独立函数调用**</font>时，使用默认绑定。<font color=FF0000>**独立函数调用** 可以理解成 <font size=4>**函数没有被绑定到 某个对象 上进行调用**</font></font>。<font size=4>通常**默认绑定**时，<font color=FF0000>**函数中的this指向全局对象(window)**</font></font>

  **示例如下：**

  - **示例一：**普通函数调用

    ```js
    function foo() { console.log(this) }
    foo(); // window
    ```

  - **示例二：**函数调用链（一个函数又调用另外一个函数）

    ```js
    function test1() {
      console.log(this); // window
      test2();
    }
    function test2() {
      console.log(this); // window
      test3()
    }
    function test3() {
      console.log(this); // window
    }
    test1();
    ```

  - **示例三：**将函数作为参数，传入到另一个函数中

    ```js
    function foo(func) { func() }
    function bar() { console.log(this) }
    
    foo(bar); // window
    ```

  - **示例四：**对上面的案例三做一些修改

    ```js
    function foo(func) { func() }
    
    var obj = {
      name: "why",
      bar: function() { console.log(this) }
    }
    
    foo(obj.bar) // window
    ```

    这里结果依然是window。原因是：<font color=FF0000>在**真正函数调用的位置**，并没有进行任何的对象绑定，只是一个独立函数的调用</font>。另外，<font color=FF0000 size=4>**this指向只看调用位置**</font>；也可以这样说：<font color=FF0000 size=4>**谁调用，this 就指向谁**</font>**。**

    **同时：**<font color=FF0000>这里 foo 函数传过去的 obj.bar 只是一个值，没有调用</font>

- **隐式绑定：**另一种比较常见的调用方式是通过某个对象进行调用。即：它的调用位置中，是通过某个对象发起的函数调用

  **示例如下：**

  - **示例一：**foo 调用时 this 会 <font color=FF0000 size=4>**隐式的**</font> 被绑定到 obj 对象上

    ```js
    function foo() { console.log(this) }
    
    var obj = { name: "why", foo }
    obj.foo() // obj对象
    ```
    
  - **示例二：**通过 obj2 又引用了 obj1 对象，再通过 obj1 对象调用 foo 函数；<font color=FF0000>foo 调用的位置上其实还是 obj1 被绑定了 this</font>

    ```js
    function foo() { console.log(this) }
    
    var obj1 = { name: "obj1", foo }
    var obj2 = { name: "obj2", obj1 }
    
    obj2.obj1.foo() // { name: 'obj1', foo: [Function: foo] }
    ```

  - **示例三：**隐式丢失。最后结果为 window

    因为 foo 最终被调用的位置是 bar，而 <font color=FF0000>bar 在进行调用时没有绑定任何的对象，也就没有形成隐式绑定</font>；相当于是一种默认绑定
    
    ```js
    function foo() { console.log(this) }
    
    var obj1 = { name: "obj1", foo }
    
    // 讲obj1的foo赋值给bar
    var bar = obj1.foo;
    // 注：console.log(bar) // function foo() { console.log(this); }
    bar(); // window
    ```
    
    **注：**该示例和上面 “默认绑定” 的 “示例四” 原理 很类似。另外，如代码中的“注”，在调用 bar() 之前打印 bar，会发现bar 就是一个简单的、this 未绑定任何对象（默认绑定）的函数

- **显式绑定：**

  **<font color=FF0000 size=4>隐式绑定</font>（注：别看错） 有一个前提条件：**<font color=FF0000>必须在调用的对象内部有一个对函数的引用</font>（比如一个属性），<font color=FF0000>如果没有这样的引用，在进行调用时，会报找不到该函数的错误</font>；正是通过这个引用，间接的将 this 绑定到了这个对象上。

  如果我们不希望在 **对象内部** 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做？

  - <font color=FF0000>**JavaScript 所有的函数都可以使用 call 和 apply 方法**</font>（和 prototype 有关）

    **call 和 apply 的区别：**他们第一个参数是相同的，后面的参数：<font color=FF0000>apply 为数组，call 为参数列表</font>

  - <font color=FF0000>**这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是 <font size=4>给 this 准备的</font>**</font>。在调用这个函数时，会将 this 绑定到这个传入的对象上。

  **这就是显式绑定。** **注：**另外，还有 bind 方法，参考上面 apply、call、bind 的笔记。

  **除了 bind / apply 的其他显示绑定：JS 的 内置函数：**

  有时，我们会调用一些 JavaScript 内置函数，或者一些第三方库中的内置函数。<mark>这些内置函数会要求我们传入另外一个函数，自己并不会显示的调用这些函数，而是 JavaScript 内部或者第三方库内部会帮助我们执行</mark>。这些函数中的 this 又是如何绑定的？示例如下：

  - **示例一：**setTimeout。setTimeout中会传入一个函数，这个函数中的 this 通常是 window

    ```js
  setTimeout(function() {
      console.log(this) // window
    }, 1000)
    ```
  
    为什么这里 this 是 window？这和 setTimeout 源码的内部调用有关，setTimeout 内部是通过 apply 进行绑定的 this 对象，并且绑定的是全局对象。

  - **示例二：**数组的forEach。<font color=FF0000>在 forEach 中传入的函数打印的也是 Window 对象</font>；<mark>这是因为默认情况下传入的函数是自动调用函数（默认绑定）</mark>

    ```js
  var names = ["abc", "cba", "nba"];
    names.forEach(function(item) {
      console.log(this); // 三次window
    });
    ```
  
    如何改变该函数的this 指向？看下 Array.prototype.forEach() 函数的函数签名：

    ```js
  arr.forEach(callback(currentValue [, index [, array]])[, thisArg])
    ```
  
    最后的 **thisArg 参数** 就是：当执行回调函数 callback 时，用作 this 的值

    ```js
  var names = ["abc", "cba", "nba"]
    var obj = {name: "why"}
    names.forEach(function(item) {
      console.log(this) // 三次obj对象
    }, obj);
    ```
  
  - **示例三：**div的点击。

    ```html
    <div class="box"></div>
    <style>
      .box {
        width: 200px;
        height: 200px;
        background-color: red;
      }
    </style>
    <script>
      var box = document.querySelector(".box");
    	box.onclick = function() {
      	console.log(this); // <div class="box"></div> 即：box对象
    	}
    </script>
    ```
    
    这里 this 指向的是：box对象。这是因为在发生点击时，执行传入的回调函数被调用时，会将 box 对象绑定到该函数中。**注：** 这里可以参考下 [[#this 在不同情况下的指向]] 中 “在事件中，this 表示接收事件的元素” ，这种 this 的指向情况。
  
- **new 绑定**

  JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字。

  **使用new关键字来调用函数时，会执行如下的操作：**

  1. 创建一个全新的对象

  2. 这个新对象会被执行 prototype 连接（**注：**感觉上面两步可以通过 Object.create() 来实现）

  3. <font color=FF0000 size=4>**这个新对象会绑定到函数调用的 this 上**</font>（ this 的绑定在这个步骤完成）

  4. 如果函数没有返回其他对象，表达式会返回这个新对象

<font color=FF0000 size=4>**上面一共介绍了四种绑定方式**</font>，它们之间是有优先级的：

- **默认规则的优先级最低**

- <font color=FF0000>显式绑定 优先级高于 隐式绑定</font>

  ```js
  function foo() { console.log(this); }
  var obj1 = { name: "obj1", foo }
  var obj2 = { name: "obj2", foo }
  
  // 隐式绑定
  obj1.foo(); // obj1
  obj2.foo(); // obj2
  // 隐式绑定和显示绑定同时存在
  obj1.foo.call(obj2); // obj2, 说明显式绑定优先级更高
  ```

- new 绑定 优先级高于 隐式绑定

  ```js
  function foo() { console.log(this); }
  var obj = { name: "why", foo }
  
  new obj.foo(); // foo对象, 说明new绑定优先级更高
  ```

- new 绑定 优先级高于 bind

  ```js
  function foo() { console.log(this) }
  var obj = { name: "obj" }
  
  // var foo = new foo.call(obj); // 会报错，下面有解释
  var bar = foo.bind(obj)
  var foo = new bar() // 打印结果：`foo {}`, 说明使用的是 new绑定。注：如果没有 new 运算符，bar() 的打印结果为 obj 对象。
  ```
  

另外，<font color=FF0000 size=4>**new绑定 和 call、apply 是不允许同时使用的**，所以不存在谁的优先级更高</font>

**优先级总结：**<font color=FF0000 size=4>**new绑定 > 显示绑定（bind）> 隐式绑定 > 默认绑定**</font>

<font size=4>**上面四种绑定方式的其他情况：**</font>

- 如果在显示绑定中，我们传入一个 null 或者 undefined，那么这个显示绑定会被忽略，使用默认规则。**注：**这是在 浏览器的“宽松模式”下的设定。

- <font color=FF0000 size=4>**创建一个函数的 间接引用，这种情况使用默认绑定规则**</font>。示例如下：

  ```js
  function foo() { console.log(this) }
  var obj1 = { name: "obj1", foo }
  var obj2 = { name: "obj2" }
  
  obj1.foo(); // obj1对象
  (obj2.foo = obj1.foo)();  // window
  ```
  **注：**这里解释的不完整，详细的解释，可以参考 [[#this 取值过程具体分析]] 中的 (foo.bar = foo.bar)() 情况；另外，除了这种情况，它下面的  (false || foo.bar)() 和 (foo.bar, foo.bar)() 也可作为良好补充。
  
- <font color=FF0000 size=4>**箭头函数：**</font><font color=FF0000>**箭头函数不使用 this的四种标准规则（也就是不绑定this），而是根据外层作用域来决定this**</font>。注：需要补充的是，箭头函数中的 this 不会受 call() / apply() 而改变绑定；更多解释见：[[#箭头函数 总结]] 中的 “没有 this” 中的补充内容

  代码示例如下：

  - **未使用箭头函数的代码：**

    ```js
    var obj = {
      data: [],
      getData: function() {
        var _this = this;
        setTimeout(function() {
          var res = ["abc", "cba", "nba"]; // 模拟获取到的数据
          _this.data.push(...res);
        }, 1000);
      }
    }
    
    obj.getData();
    ```

    由于在 setTimeout 中的 this 是 window，所以需要通过  \_this 保存 当前的 this（obj对象）

  - **使用箭头函数的代码**

    ```js
    var obj = {
      data: [],
      getData: function() {
        setTimeout(() => {
          var res = ["abc", "cba", "nba"]; // 模拟获取到的数据
          this.data.push(...res);
        }, 1000);
      }
    }
    
    obj.getData();
    ```

    因为：箭头函数并不绑定 this 对象，那么 this 引用就会从上层作用域中找到对应的 this；而外层的 this 就是 obj 对象。

##### this 相关面试题

- **面试题一：**

  ```js
  var name = "window";
  var person = {
    name: "person",
    sayName: function () {
      console.log(this.name);
    }
  };
  function sayName() {
    var sss = person.sayName;
    sss();                  // window❌；错误原因和上面的一样：这里调用时是“独立函数调用”，没有和任何对象关联
    person.sayName();       // person☑️
    (person.sayName)();     // person☑️
    (b = person.sayName)(); // window❌ 这里错了是以为是window对象；没注意后面的this.name；所以是window
  }
  sayName();
  ```

  注：第二次做全对，但是 “第三个”不确定

- **面试题二：**

  ```js
  var name = 'window'
  var person1 = {
    name: 'person1',
    foo1: function () { console.log(this.name) },
    foo2: () => console.log(this.name),
    foo3: function () {
      return function () { console.log(this.name) }
    },
    foo4: function () {
      return () => { console.log(this.name) }
    }
  }
  
  var person2 = { name: 'person2' }
  
  person1.foo1();                // person1☑️ 隐式绑定
  person1.foo1.call(person2);    // person2☑️ 隐式绑定和显示绑定的结合，显示绑定生效
  
  person1.foo2();                // window☑️ foo2()是一个箭头函数，不适用所有的规则。注：这里可以参考下最后一题的解释：箭头函数会向上（应该是定义处的上方）寻找this，而对象中（不是函数中） this 为 全局对象，所以，结果为 window
  person1.foo2.call(person2);    // window☑️ foo2依然是箭头函数，不适用于显示绑定的规则。注：解释见上面一题
  
  person1.foo3()();              // window❌ 获取到foo3，但是调用位置是全局作用于下，所以是默认绑定window。理解，返回函数function() { console.log(this.name)}；这个时候条用返回函数，相当于IIFE，相当于还是在最外层调用this.name。另外，题目代码相当于 ( (person1.foo3()) )()  ⭐️⭐️⭐️很重要，易错！
  person1.foo3.call(person2)();  // window❌ 与上一个同理，还是相当于返回一个function() {console.log(this.name)}函数，然后再最外层调用函数
  person1.foo3().call(person2);  // person2☑️ 拿到foo3返回的函数，通过显示绑定到person2中，所以是person2
  
  person1.foo4()();              // person1☑️ foo4()的函数返回的是一个箭头函数，箭头函数的执行找上层作用域，是person1。注：自己的理解，这里的找上层作用域就是去调用处，即前面调用者person1的this。⭐️⭐️⭐️ 重要
  person1.foo4.call(person2)();  // person2❌ foo4()显示绑定到person2中，并且返回一个箭头函数。箭头函数找上层作用域，是person2
  person1.foo4().call(person2);  // person1❌ foo4返回的是箭头函数，箭头函数只看（**定义处的上方**）上层作用域；同时“**箭头函数使用 call 不会改变 this 的绑定**” ⭐️⭐️⭐️ 重要
  ```
  
  **注：**第二次做，最后三个都错了，倒数第四第五个不确定；错误答案如下：
  
  ```js
  person1.foo4()();             // window
  person1.foo4.call(person2)(); // window 
person1.foo4().call(person2); // person2
  ```

- **面试题三：**

  ```js
  var name = 'window'
  // 和上一题的区别在这里
  function Person (name) {
    this.name = name
    this.foo1 = function () { console.log(this.name) },
    this.foo2 = () => console.log(this.name),
    this.foo3 = function () {
      return function () { console.log(this.name) }
    },
    this.foo4 = function () {
      return () => { console.log(this.name) }
    }
  }
  var person1 = new Person('person1')
  var person2 = new Person('person2')
  
  person1.foo1()               // person1☑️ 隐式绑定
  person1.foo1.call(person2)   // person2☑️ 显式绑定优先级大于隐式绑定
  
  person1.foo2()               // person1❌ foo是一个箭头函数，会找上层作用域中的this，那么就是person1 ⭐️注：第二次做的解释：由于 new 会改变对象中 this 的指向；所以，这里对象中 的 this 的指向为 person1
  person1.foo2.call(person2)   // person1❌ **foo是一个箭头函数，使用 call 调用不会影响 this 的绑定**，和上面一样向上层查找⭐️⭐️⭐️
  
  person1.foo3()()             // window☑️ 调用位置是全局直接调用，所以依然是window（默认绑定）
  person1.foo3.call(person2)() // window☑️ 最终还是拿到了foo3返回的函数，在全局直接调用（默认绑定）
  person1.foo3().call(person2) // person2☑️ 拿到foo3返回的函数后，通过call绑定到person2中进行了调用
  
  person1.foo4()()             // person1☑️ foo4返回了箭头函数，和自身绑定没有关系，上层找到person1
  person1.foo4.call(person2)() // person2☑️ foo4调用时绑定了person2，返回的函数是箭头函数，调用时，找到了上层绑定的person2
  person1.foo4().call(person2) // person1☑️ foo4调用返回的箭头函数，和call调用没有关系，找到上层的person1
  ```
  
  **注：**第二次做，错的和上面的一样。
  
- **面试题四：**

  ```js
  var name = 'window'
  function Person (name) {
    this.name = name
    this.obj = {
      name: 'obj',
      foo1: function () {
        return function () { console.log(this.name) }
      },
      foo2: function () {
        return () => { console.log(this.name) }
      }
    }
  }
  var person1 = new Person('person1')
  var person2 = new Person('person2')
  
  person1.obj.foo1()()             // window☑️ obj.foo1()返回一个函数，这个函数在全局作用于下直接执行（默认绑定）
  person1.obj.foo1.call(person2)() // window☑️ 最终还是拿到一个返回的函数（虽然多了一步call的绑定），这个函数在全局作用于下直接执行（默认绑定）
  person1.obj.foo1().call(person2) // person2❌ 这里不应该错
  
  person1.obj.foo2()()             // obj❌ 这里不该错。拿到foo2()的返回值，是一个箭头函数；箭头函数在执行时找上层作用域下的this，就是obj
  person1.obj.foo2.call(person2)() // person2❌ foo2()的返回值，依然是箭头函数，但是在执行foo2时绑定了person2；箭头函数在执行时找上层作用域下的this，找到的是person2
  person1.obj.foo2().call(person2) // obj❌ foo2()的返回值，依然是箭头函数；**箭头函数通过call调用是不会绑定this**，所以找上层作用域下的this是obj ⭐️⭐️⭐️
  ```
  
  **注：**第二次做，第三条和第五条错了；但是是题目看错了，不该错
  
  ```js
  person1.obj.foo1().call(person2) // obj，没看到 foo1 后面的()
  
  person1.obj.foo2.call(person2)() // obj，同样不该错。
  ```
  

摘自：[前端面试之彻底搞懂this指向](https://mp.weixin.qq.com/s/hYm0JgBI25grNG_2sCRlTA)

#### 从 ECMAScript 规范理解 this （学习自“冴羽”的 GitHub 文章）

首先是第 8 章 Types：

> Types are further subclassified into ECMAScript language types and specification types.

> An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.

> A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record.

简单的翻译一下：

ECMAScript 的类型分为 **语言类型** 和 <font color=FF0000 size=4>**规范类型**</font>。

- ECMAScript <font color=FF0000>**语言类型**</font> 是开发者直接使用 ECMAScript 可以操作的。其实就是我们常说的 Undefined, Null, Boolean, String, Number 和 Object。**注：**就是 JS 的基本类型。另外，这里讲的是 ES5，ES6 中新增的基本类型 Symbol 没提及。

- <font color=FF0000 size=4>**规范类型**</font> <font color=FF0000>**相当于 meta-values**</font>，是<font color=FF0000>**用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的**</font>。规范类型 <font color=FF0000>**包括：<font color=fuchsia size=4>Reference</font>, List, Completion, Property Descriptor, Property Identifier, Lexical Environment 和 Environment Record**</font>。

简单来说： ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。其中 <font color=fuchsia size=4>**Reference 类型**</font> <font color=FF0000>**与 this 的指向有着密切的关联**</font>

##### Reference

**什么是 Reference ？**让我们看 8.7 章 The Reference Specification Type：

> The Reference type is used to <font color=FF0000>explain the behaviour of such **operators** as **delete**, **typeof**, and the **assignment operators**</font>.

所以 <font color=FF0000>**Reference 类型就是用来解释诸如 delete、typeof 以及 赋值 等操作行为的**</font>。抄袭尤雨溪大大的话，就是：

> 这里的 Reference 是一个 Specification Type，也就是 “只存在于规范里的抽象类型”。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。

**再看接下来的这段具体介绍 Reference 的内容：**

> A Reference is a resolved name binding. 注：翻译为“引用 是 已解析的名称绑定”

> A Reference <font color=FF0000>consists of three components</font>, the <font color=FF0000>base value</font>, the <font color=FF0000>referenced name</font> and the <font color=FF0000>Boolean valued strict reference flag</font>.

> The <font color=FF0000>**base value**</font> is <mark><font size=4>**either**</font> undefined, an Object, a Boolean, a String, a Number</mark>, <mark style="background: aqua"><font size=4>**or**</font> an environment record</mark> (10.2.1). **注：**base value 要么是 基本类型（的包装类对象？这里存疑），要么是 environment record

> A base value of `undefined` indicates that the reference could not be resolved to a binding. The referenced name is a String.

这段讲述了 Reference 的构成，由三个组成部分，分别是：

- base value

- referenced name

- strict reference

**可是这些到底是什么呢？我们简单的理解的话：**

- base value 就是 <font color=FF0000 size=5>**属性所在的对象**</font> 或者 就是 EnvironmentRecord（注：即，它没有所属对象；亦即，它在全局作用域下），它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。

- referenced name 就是属性的名称。

如下示例：

```js
var foo = 1;

// 对应的Reference是：
var fooReference = {
    base: EnvironmentRecord, // base，即 base value；该属性所属的对象。
    name: 'foo', // name 即：referenced name
    strict: false // strict 即：strict reference
};
```

```js
var foo = {
    bar: function () { return this; }
};
foo.bar(); // foo

// bar对应的Reference是：
var BarReference = {
    base: foo,
    propertyName: 'bar',
    strict: false
};
```

而且规范中还提供了获取 Reference 组成部分的方法，比如 GetBase 和 IsPropertyReference。这两个方法很简单，简单看一看：

- **GetBase**

  > GetBase(V). <font color=FF0000>Returns the base value component of the reference V</font>.

​		返回 reference（**注：**在这里是 V）的 <font color=FF0000>base value</font>。**注：**即，该属性所属的对象 或者（在全局作用域上，没有所属对象）就是 Environment Record（这里重复是为了再次强调）

- **IsPropertyReference**

  > IsPropertyReference(V). <font color=FF0000>Returns true if **either** the base value is an object **or** HasPrimitiveBase(V) is true</font>; otherwise returns false.

  简单的理解：<font color=FF0000>如果 base value 是一个对象，就返回 true</font>。

**注：**注意⚠️，上面两个函数下面会用到。

**GetValue**

除此之外，紧接着在 8.7.1 章规范中就讲了一个<font color=FF0000>用于从 Reference 类型 **获取对应值** 的方法： GetValue</font>。简单模拟 GetValue 的使用：

```js
var foo = 1;

var fooReference = {
    base: EnvironmentRecord,
    name: 'foo',
    strict: false
};
GetValue(fooReference) // 1;
```

GetValue 返回对象属性真正的值，但是 <font color=FF0000>**要注意**</font>⚠️：<font color=FF0000 size=4>**调用 GetValue，返回的将是具体的值，而不再是一个 Reference **</font>。**注：**下面的 “ (foo.bar = foo.bar)() ”以及下面的例子 会用到；重要！⭐️⭐️⭐️

##### 如何确定this的值

关于 Reference 讲了那么多，为什么要讲 Reference 呢？到底 Reference 跟本文的主题 this 有哪些关联呢？如果你能耐心看完之前的内容，以下开始进入高能阶段：

看规范 11.2.3 Function Calls：<font color=FF0000>**这里讲了当函数调用的时候，如何确定 this 的取值**</font>

**只看第一步、第六步、第七步：**

> 1. <font color=FF0000>Let *ref* be the <font size=4>result of **evaluating MemberExpression**</font></font>.

> 6. If Type(*ref*) is Reference, then        <mark>**注： **</mark>如果 ref 是 Reference 规范类型。如何判断是 Reference 下面有讲，见下面的 “this 取值的具体分析” 的第二部分
>
> ​       a. If IsPropertyReference(ref) is true, then  <mark>**注：**</mark> 即，如果 ref 是一个对象（通过 IsPropertyReference 判断）
>
> ​              i. Let thisValue be GetBase(ref).  <mark>**注：**</mark>，则<font color=FF0000 size=4>通过 GetValue(ref) **获取它的值为 this**</font>
>
> ​       b. Else, the base of ref is an Environment Record  <mark>**注：**</mark> 如果 ref 不是对象，则它是一个 Environment Record
>
> ​             i. Let thisValue be the result of calling the ImplicitThisValue concrete method of GetBase(ref). 
>
> ​		    <mark>**注：**</mark>调用 GetBase(ref) 的 ImplicitThisValue 具体方法的结果，设置为 this 的值

> 7. Else, Type(*ref*) is not Reference. <mark>**注：**</mark>ref 的 规范类型 不是 Reference
>
> ​       a. Let thisValue be undefined. <mark>**注：**</mark> 则，this 的值为 undefined（在 浏览器“宽松模式”下 undefined 会变成 window）

**让我们描述一下：**

1. <font color=FF0000>**计算 MemberExpression 的结果赋值给 ref**</font>

2. 判断 ref 是不是一个 Reference 类型
   1. 如果 <font color=fuchsia>**ref 是 Reference**</font>，并且 IsPropertyReference(ref) 是 true（**注：**即 ref 是一个对象）， 那么 this 的值为 GetBase(ref)
   2. 如果 <font color=fuchsia>**ref 是 Reference**</font>，并且 base value 值是 Environment Record（**注：**IsPropertyReference(ref) 是 false，即 ref 不是一个对象）， 那么 this 的值为 ImplicitThisValue(ref) **注：**根据最后 “最最后，忘记了一个最最普通的情况：” 的说明，ImplicitThisValue(ref) 始终返回 undefined，所以在非严格模式下，this 为 window
   3. 如果 <font color=aqua>**ref 不是 Reference**</font>，那么 this 的值为 undefined

##### this 取值过程具体分析

让我们一步一步看：

1. **计算 MemberExpression 的结果赋值给 ref：**

   什么是 MemberExpression？看规范 11.2 Left-Hand-Side Expressions  ：

   > **MemberExpression :**
   >
   > - PrimaryExpression // 原始表达式 可以参见《JavaScript权威指南第四章》
   > - FunctionExpression // 函数定义表达式
   > - MemberExpression [ Expression ] // 属性访问表达式。**注：**通过 `[]` 成员访问器 获取成员
   > - MemberExpression . IdentifierName // 属性访问表达式。 **注：**通过 `.` 成员访问器 获取成员
   > - new MemberExpression Arguments // 对象创建表达式。**注：**即 new 运算符

   举例：

   ```js
   function foo() {
     console.log(this)
   }
   foo(); // MemberExpression 是 foo
   
   function foo() {
     return function() {
       console.log(this)
     }
   }
   foo()(); // MemberExpression 是 foo()
   
   var foo = {
     bar: function () {
       return this;
     }
   }
   foo.bar(); // MemberExpression 是 foo.bar
   ```

   所以简单理解 MemberExpression 其实就是 `()` 左边的部分

2. **判断 ref 是不是一个 Reference 类型。**

   关键就在于：<font color=FF0000>**看规范** 是如何处理各种 MemberExpression</font>，返回的结果是不是一个 Reference 类型。举最后一个例子：

   ```js
   var value = 1;
   
   var foo = {
     value: 2,
     bar: function () {
       return this.value;
     }
   }
   
   //示例1
   console.log(foo.bar());
   //示例2
   console.log((foo.bar)());
   //示例3
   console.log((foo.bar = foo.bar)());
   //示例4
   console.log((false || foo.bar)());
   //示例5
   console.log((foo.bar, foo.bar)());
   ```

   - **foo.bar()**

     在示例1 中，MemberExpression 计算的结果是 foo.bar，那么 foo.bar 是不是一个 Reference 呢？

     查看规范 11.2.1 Property Accessors（**注：**译为 “属性访问器”，即：其他语言中的“成员运算符”（ js 中好像没有“成员运算符” 的说法，至少没怎么搜到）），这里展示了一个计算的过程，什么都不管了，就看最后一步：

     > Return a value of type Reference whose base value is baseValue and whose referenced name is propertyNameString, and whose strict mode flag is strict.
     >
     > **译为：**<font color=FF0000>**返回一个规范类型为 Reference 的值**</font>，其“基值“( base value ) 为 baseValue，其引用名称为 properNameString，其严格模式标志是严格的。

     我们得知该表达式返回了一个 Reference 类型！根据之前的内容，我们知道该值为：

     ```js
     var Reference = {
       base: foo,
       name: 'bar',
       strict: false
     };
     ```

     接下来按照 2.1 的判断流程走：

     > 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true , 那么 this 的值为 GetBase(ref)

     该值是 Reference 类型，那么 IsPropertyReference(ref) 的结果是多少呢？

     前面我们已经铺垫了 IsPropertyReference 方法，如果 base value 是一个对象，结果返回 true。

     base value 为 foo，是一个对象，所以 IsPropertyReference(ref) 结果为 true。这个时候我们就可以确定 this 的值了：

     ```js
     this = GetBase(ref)，
     ```

     GetBase 也已经铺垫了，获得 base value 值，这个例子中就是 foo，所以 this 的值就是 foo ，示例1的结果就是 2！

   - **(foo.bar)()**

     看示例2：

     ```
     console.log((foo.bar)());
     ```

     foo.bar 被 () （**注：**圆括号操作符）包住，查看规范 11.1.6 The Grouping Operator；直接看结果部分：

     > Return the result of evaluating Expression. This may be of type Reference.

     > NOTE This algorithm does not apply GetValue to the result of evaluating Expression.

     实际上 () 并没有对 MemberExpression 进行计算，所以其实跟示例 1 的结果是一样的。

   - **(foo.bar = foo.bar)()**

     看示例3，有赋值操作符，查看规范 11.13.1 Simple Assignment ( = )。计算的第三步：

     > 3. Let rval be GetValue(rref).

     <font color=FF0000>**因为使用了 GetValue，所以返回的值不是 Reference 类型**</font>；按照之前讲的判断逻辑：

     > 2.3 <font color=FF0000>如果 ref 不是 Reference，那么 this 的值为 undefined</font>

     <font color=FF0000>this 为 undefined</font>，<mark>非严格模式下，this 的值为 undefined 的时候，其值会被隐式转换为全局对象</mark>。

   - **(false || foo.bar)()**

     看示例4，逻辑与算法，查看规范 11.11 Binary Logical Operators。计算第二步：

     > 2.Let lval be GetValue(lref).

     <font color=FF0000>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</font>

   - **(foo.bar, foo.bar)()**

     看示例5，逗号操作符，查看规范11.14 Comma Operator ( , )。计算第二步：

     > 2.Call GetValue(lref).

     <font color=FF0000>因为使用了 GetValue，所以返回的不是 Reference 类型，this 为 undefined</font>

   所以结果为：

   ```js
   var value = 1;
   
   var foo = {
     value: 2,
     bar: function () {
       return this.value;
     }
   }
   
   console.log(foo.bar()); // 2
   console.log((foo.bar)()); // 2
   console.log((foo.bar = foo.bar)()); // 1
   console.log((false || foo.bar)()); // 1
   console.log((foo.bar, foo.bar)()); // 1
   ```

最后，最最普通的情况：

```js
function foo() { console.log(this)}
foo(); 
```

MemberExpression 是 foo，解析标识符，查看规范 10.3.1 Identifier Resolution，会返回一个 Reference 类型的值：

```js
var fooReference = {
    base: EnvironmentRecord,
    name: 'foo',
    strict: false
};
```

接下来进行判断：

> 2.1 如果 ref 是 Reference，并且 IsPropertyReference(ref) 是 true, 那么 this 的值为 GetBase(ref)

因为 base value 是 EnvironmentRecord，并不是一个 Object 类型，还记得前面讲过的 base value 的取值可能吗？ 只可能是 undefined, an Object, a Boolean, a String, a Number 和 an environment record 中的一种。

IsPropertyReference(ref) 的结果为 false，进入下个判断：

> 2.2 如果 ref 是 Reference，并且 base value 值是 Environment Record, 那么 this 的值为 ImplicitThisValue(ref)

base value 正是 Environment Record，所以会调用 ImplicitThisValue(ref)

查看规范 10.2.1.1.6，<font color=FF0000>ImplicitThisValue 方法的介绍：<font size=4>**该函数始终返回 undefined**</font></font>。所以最后 this 的值就是 undefined。

##### 多说一句

尽管我们可以简单的理解 this 为调用函数的对象，如果是这样的话，如何解释下面这个例子呢？

```js
var value = 1;

var foo = {
  value: 2,
  bar: function () {
    return this.value;
  }
}
console.log((false || foo.bar)()); // 1
```

此外，又如何确定调用函数的对象是谁呢？在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。而你也就能明白，尽管 foo() 和 (foo.bar = foo.bar)() 最后结果都指向了 undefined，但是两者从规范的角度上却有着本质的区别。

##### 关于文章 this 死记硬背的总结：

对于：赋值运算、二元逻辑运算、逗号操作符 this 都指向 window

摘自：[JavaScript深入之从ECMAScript规范解读this](https://github.com/mqyqingfeng/Blog/issues/7)


#### 《现代 JS 教程 - Reference Type》中 this 与 Reference Type 关系的补充
<font color=FF0000 size=4>**一个动态执行的方法调用可能会丢失 `this` **</font>。例如：

```js
let user = {
  name: "John",
  hi() { alert(this.name); },
  bye() { alert("Bye"); }
};

user.hi(); // 正常运行

// 现在让我们基于 name 来选择调用 user.hi 或 user.bye
(user.name == "John" ? user.hi : user.bye)(); // Error!
```

在最后一行有个在 `user.hi` 和 `user.bye` 中做选择的条件（三元）运算符。当前情形下的结果是 `user.hi`。

接着该方法被通过 `()` 立刻调用。但是并不能正常工作！

如你所见，此处调用导致了一个错误，<font color=FF0000 size=4>**因为在该调用中 `"this"` 的值变成了 `undefined` **</font>。

**这样是能工作的（ 对象.方法 ）：**

```js
user.hi();
```

**这就无法工作了（被评估的方法）：**

```js
(user.name == "John" ? user.hi : user.bye)(); // Error!
```

为什么呢？欲知缘何，且让我们深入 `obj.method()` 调用运行的本质。

##### Reference type 解读

仔细看的话，我们可能注意到 `obj.method()` 语句中的两个操作：

1. 首先，点 `'.'` 取了属性 `obj.method` 的值。
2. 接着 `()` 执行了它。

那么，<font color=FF0000>**`this` 的信息是怎么从第一部分传递到第二部分的呢？<font size=4>如果我们将这些操作放在不同的行，`this` 必定是会丢失的</font>**</font>：

```js
let user = {
  name: "John",
  hi() { alert(this.name); }
}

// 把获取方法和调用方法拆成两行
let hi = user.hi;
hi(); // 报错了，因为 this 的值是 undefined
```

这里 `hi = user.hi` 把函数赋值给了一个变量，<font color=FF0000>**接下来在最后一行它是完全独立的，所以这里没有 `this`**</font>。

**为确保 `user.hi()` 调用正常运行，JavaScript 玩了个小把戏：<font color=FF0000>点 `'.'` 返回的不是一个函数，而是一个特殊的</font> [Reference Type](https://tc39.github.io/ecma262/#sec-reference-specification-type) <font color=FF0000>的值</font>。**

<font color=FF0000>**Reference Type 是 ECMA 中的一个“规范类型”**。我们不能直接使用它，但它被用在 JavaScript 语言内部</font>。

<font color=FF0000 size=4>**Reference Type 的值是一个三个值的组合 `(base, name, strict)` **</font>，其中：

- `base` 是对象。
- `name` 是属性名。
- <font color=FF0000>**`strict` 在 `use strict` 模式下为 true**</font>

<font color=FF0000 size=4>**对属性 `user.hi` 访问的结果不是一个函数，而是一个 Reference Type 的值**</font>。对于 `user.hi`，在严格模式下是：

```javascript
// Reference Type 的值
(user, "hi", true)
```

当 `()` 被在 Reference Type 上调用时，它们会接收到关于对象和对象的方法的完整信息，然后可以设置正确的 `this`（在此处 `=user` ）

<font color=FF0000 size=4>**Reference Type 是一个特殊的“中间人”内部类型，目的是从 `.` 传递信息给 `()` 调用**</font>。

<font color=FF0000>**<font size=4>任何例如赋值 `hi = user.hi` 等其他的操作，都会将 Reference Type 作为一个整体丢弃掉</font>，而会取 `user.hi`（一个函数）的值并继续传递**</font>。所以任何后续操作都 “丢失” 了 `this` 。

因此，`this` 的值仅在函数直接被通过点符号 `obj.method()` 或方括号 `obj['method']()` 语法（此处它们作用相同）调用时才被正确传递。

摘自：[现代 JS 教程 - Reference Type](https://zh.javascript.info/reference-type)



#### typeof 和 instanceof 的实现原理
typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断number, string, object, boolean, function, undefined, symbol 这七种类型。很遗憾的一点是，typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object。（类似的，可以参见：[[JS及其基本库备忘录#关于 typeof 判断类型的不足 解决方法的补充]]）。要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断

##### typeof 的实现原理：
可以先想一个很有意思的问题，<font color=FF0000>js 在底层是怎么存储数据的类型信息呢</font>？或者说，<font color=FF0000>一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢</font>？其实，<font color=FF0000 size=4>js 在底层存储变量的时候，会在变量的机器码的 **低位1-3位**⚠️ 存储其类型信息</font>

-   **000：**<font color=FF0000 size=4>**对象**</font>
-   **010：**浮点数
-   **100：**字符串
-   **110：**布尔
-   **1：**整数

但是，对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的：<font color=FF0000 size=4>null：**所有机器码均为0**；undefined：**用 −2^30 整数来表示**。</font>所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。
然而用 instanceof 来判断的话：

```js
null instanceof null // TypeError: Right-hand side of 'instanceof' is not an object
```

null 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考 [typeof](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Ftypeof "https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof")。

另外，还可以使用 Object.prototype.toString.call() ，详见：[[JS及其基本库备忘录#关于 typeof 判断类型的不足 解决方法的补充]]

##### instanceof 操作符的实现原理

根据 ECMAScript 语言规范，梳理了一下大概的思路，然后整理了一段代码如下：

```js
function new_instance_of(leftVaule, rightVaule) {
  // 注：注意⚠️，这里 rightValue 是一个 **构造函数**，所以才有 prototype 属性。
  let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
  leftVaule = leftVaule.__proto__ ; // 取左表达式的__proto__值。注：是一个对象
  while (true) {
  	if (leftVaule === null) { return false; } // Object.__prototype__ 为 null了，找到最上面了；则可以确认找不到了
    if (leftVaule === rightProto) { return true; }
    leftVaule = leftVaule.__proto__ // 继续往上级找，依次类推；直到找到，或为null
  }
}
```

关于原型继承，可以用一张图来表示：

<img src="https://s2.loli.net/2022/03/24/IxBmUVDvrX3el1c.png" alt="https://cdn.jsdelivr.net/gh/nekolr/image-hosting@202004191648/2020/04/19/Yly.png" style="zoom:50%;" />

**另外，有几个 instanceof 比较重要 / 典型 的例子：**

```js
function Foo() {}

Object instanceof Object // true
Function instanceof Function // true     
Function instanceof Object // true
Object instanceof Function // true。这个学习自：如何理解在 JavaScript 中 "函数是第一等公民" 这句话? - justjavac的回答 - 知乎 https://www.zhihu.com/question/67652709/answer/255460149

Foo instanceof Foo // false
Foo instanceof Object // true
Foo instanceof Function // true
```

- **Object instanceof Object === true：**由图可知，Object 的 prototype 属性是 Object.prototype，而由于 Object 本身是一个函数（**注：**构造函数），由 Function 所创建，所以 Object.\__proto__ 的值是 Function.prototype；而 Function.prototype 的 \_\_proto__ 属性是 Object.prototype。所以我们可以判断出，Object instanceof Object 的结果是 true 

  ```js
  leftValue = Object.__proto__ = Function.prototype;
  rightValue = Object.prototype;
  
  leftValue != rightValue // 第一次判断
  leftValue = Function.prototype.__proto__ = Object.prototype
  
  leftValue === rightValue // /第二次判断，返回 true
  ```

  **注：**上面的说法也解释了 Object instanceof Function === true。因为 Object.\__proto__ === Function.prototype

- **Foo instanceof Foo === false：**Foo 函数的 prototype 属性是 Foo.prototype ，而 Foo 的 \__proto__ 属性是 Function.prototype，由图可知，Foo 的原型链上并没有 Foo.prototype ，因此 Foo instanceof Foo 也就返回 false

  ```js
  leftValue = Foo.__proto === Function.prototype
  rightValue = Foo.prototype
  
  leftValue != rightValue // 第一次判断
  leftValue = Function.prototype.__proto__ = Object.prototype
  
  leftValue != rightValue // 第二次判断
  leftValue = Object.prototype = null
  
  leftValue === null // 第三次判断。返回 false
  ```

- **Foo instanceof Object === true**

  ```js
  leftValue = Foo.__proto__ === Function.prototype
  rightValue = Object.prototype
  
  leftValue != rightValue // 第一次判断
  leftValue = Function.prototype.__proto__ = Object.prototype
  
  leftValue === rightValue // 第二次判断。返回 true
  ```

- **Foo instanceof Function === true**

  ```js
  leftValue = Foo.__proto__ === Function.prototype
  rightValue = Function.prototype
  
  leftValue === rightValue // 第一次判断。返回 true
  ```


摘自：[typeof 和 instanceof 的实现原理](https://juejin.cn/post/6844903613584654344)


#### 原型链

<font color=FF0000>每个函数都有一个 prototype 属性</font>，就是我们经常在各种例子中看到的那个 prototype。另外，<font color=FF0000 size=4>prototype **是函数才会有的属性**</font>（**注：**这一点，之前从没听过... 🥬）。如下示例：

```js
function Person() {}
Person.prototype.name = 'Kevin';
// 注：这里 Person.prototype.name 的意思是，给 Person 的 prototype 加上 name 这个 property。
// 类似的，Person.prototype.age = 11，都是可以的。
// 打印 Person.prototype 可见到赋值的 property 组成的对象。比如：{ name: 'Kevin', age: 11 }

var person1 = new Person();
var person2 = new Person();
console.log(person1.name) // Kevin
console.log(person2.name) // Kevin
```

<font color=FF0000 size=4>函数的 prototype 属性指向了一个对象，**这个对象正是调用该构造函数而创建的实例的原型**</font>（**注：**这句话，非常重要！！！⭐️⭐️⭐️。<mark>打印下 Object.getPrototypeOf(person1)，会发现，结果为：{ name: 'Kevin' }</mark> ），<font color=FF0000>也就是这个例子中的 person1 和 person2 的原型</font>。

那什么是原型呢？你可以这样理解：<font color=FF0000>每一个JavaScript对象 ( null 除外) 在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性</font>。

<font size=4>**\__protot__**</font>

每一个 JavaScript 对象（除了 null ）都具有的一个属性，叫 \_\_proto\_\_，这个属性会指向该对象的原型。

```js
function Person() {}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true
```

所以，实例对象和构造函数都可以指向原型（注：分别通过 \__protot__ 和 prototype ）。

\_\_proto\_\_ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说<font color=FF0000>是一个 getter / setter</font>，当使用 obj.\__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。

原型也有属性指向构造函数，即 constrcutor。

<font size=4>**constructor**</font>

每个原型都有一个 constructor 属性指向关联的构造函数

```js
function Person() {}
console.log(Person === Person.prototype.constructor); // true
```

<font size=4>**Object.prototype**</font>

Object.prototype 的原形是什么？是 null，即：( Object.prototype.\__proto__ \=== null ) === true。而 null 表示：“没有对象”，即该处不应该有值。

所以 Object.prototype.\_\_proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。所以查找属性的时候查到 Object.prototype 就可以停止查找了。

所以，原型链的关系图为：

<img src="https://s2.loli.net/2022/02/18/D9ZKsagu72bA6XP.jpg" alt="68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67" style="zoom: 85%;" />

<font size=4>**js 的继承思想**</font>

js 的继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话：

> 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。

摘自：[JavaScript深入之从原型到原型链](https://github.com/mqyqingfeng/Blog/issues/2)

#### JS 的继承的多种方式和优缺点

- <font size=4>**原型链继承**</font>

  ```js
  function Parent () { this.names = ['kevin', 'daisy']; }
  Parent.prototype.foo = function() { console.log('foo') }
  
  function Child () {}
  Child.prototype = new Parent();
  
  var child1 = new Child();
  child1.names.push('yayu');
  console.log(child1.names); // ["kevin", "daisy", "yayu"]
  
  var child2 = new Child();
  console.log(child2.names); // ["kevin", "daisy", "yayu"]
  ```

  **特性：**

  - <font color=FF0000 size=4>**引用类型的属性** 被所有实例共享</font>（**注：**如上）。**注：**这里是 引用属性被共享，而 js 的基础类型不会

    另外，父类的方法同样被继承。

  - 在创建 Child 的实例时，不能向 Parent 传参。

- <font size=4>**借用构造函数（经典继承）**</font>

  ```js
  function Parent () { this.names = ['kevin', 'daisy']; }
  function Child () { Parent.call(this); }
  
  var child1 = new Child();
  child1.names.push('yayu');
  console.log(child1.names); // ["kevin", "daisy", "yayu"]
  
  var child2 = new Child();
  console.log(child2.names); // ["kevin", "daisy"]
  ```

  **优点：**

  - <font color=FF0000>避免了 <font size=4>**引用类型**</font> 的属性被所有实例共享</font>（注：如上面）

  - 可以在 Child 中向 Parent 传参（注：示例如下）

    ```js
    function Parent (name) { this.name = name; }
    function Child (name) { Parent.call(this, name); }
    var child1 = new Child('kevin');
    ```

  > **缺点**
  >
  > 如果仅仅借用构造函数，那么将无法避免构造函数模式存在的问题：方法都在构造函数中定义（**注：**这里应该是在说，如果不报错的话；毕竟如下说的：借用构造函数无法使用父类的函数），因此函数复用也就不可用了。而且超类型（如Father）中定义的方法，对子类型而言也是不可见的。
  >
  > 摘自：[JS原型链与继承别再被问倒了](https://juejin.cn/post/6844903475021627400)
  >
  > **借用构造函数无法使用父类的函数，示例如下：**
  >
  > ```js
  > function Parent () { this.names = ['kevin', 'daisy']; }
  > Parent.prototype.foo = function() { console.log('foo') }
  > 
  > function Child () { Parent.call(this); }
  > var child1 = new Child();
  > child1.foo() // 报错 TypeError: child1.foo is not a function
  > ```

- <font size=4>**组合继承**</font>（原型链继承和经典继承双剑合璧）

  > 基本思路：使用 <font color=FF0000>原型链 实现对**原型属性和方法** 的继承</font>，通过<font color=FF0000>借用构造函数来实现对 **实例属性**（写在父类构造函数内的）的继承</font>
  >
  > 摘自：[JS原型链与继承别再被问倒了](https://juejin.cn/post/6844903475021627400)

  ```js
  function Parent (name) {
      this.name = name;
      this.colors = ['red', 'blue', 'green'];
  }
  Parent.prototype.getName = function () { console.log(this.name) }
  function Child (name, age) {
      Parent.call(this, name);
      this.age = age;
  }
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;
  
  var child1 = new Child('kevin', '18'); // 下面代码略，请参见原链接
  ```

  优点：融合原型链继承和构造函数的优点，<font color=FF0000>是 JavaScript 中最常用的继承模式</font>
  
  缺点：组合继承最大的缺点是会调用两次父构造函数。
  
  - 一次是设置子类型实例的原型的时候：
  
    ```js
    Child.prototype = new Parent();
    ```
  
  - 一次在创建子类型实例的时候：
  
    ```js
    var child1 = new Child('kevin', '18');
    ```

- <font size=4>**原型式继承**</font>

  ```js
  function createObj(o) {
      function F(){}
      F.prototype = o;
      return new F();
  }
  ```

  就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。

  **缺点：**<font color=FF0000>包含引用类型的属性值始终都会共享相应的值</font>，这点跟原型链继承一样。

  **注，**发现：这种继承和下面的 寄生式好像没区别啊？不过，不确定...

- <font size=4>**寄生式继承**</font>

  创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。

  ```js
  function createObj (o) {
      var clone = Object.create(o);
      clone.sayName = function () { console.log('hi'); }
      return clone;
  }
  ```

  **缺点：**跟借用构造函数模式一样，每次创建对象都会创建一遍方法。

- <font size=4>**寄生组合式继承**</font>

  组合继承最大的缺点是会调用两次父构造函数，这一点上面有提及。

  > **寄生组合式继承就是为了降低调用父类构造函数的开销而出现的**
  >
  > > 其背后的基本思路是: 不必为了指定子类型的原型而调用超类型的构造函数
  >
  > 

  // TODO，这里需要重新看一遍

摘自：[JavaScript深入之继承的多种方式和优缺点](https://github.com/mqyqingfeng/Blog/issues/16)

补充阅读：[JS原型链与继承别再被问倒了](https://juejin.cn/post/6844903475021627400)



### 闭包

下面的摘抄是 2022/3/1 写的，再下面的摘抄要早于 2022/3/1；但是，因为直到这篇才完全搞懂闭包的原理，而且感觉写得非常好，所以放在最前面（虽然，无法否认的是：没有前面（早于 2022/3/1）的阅读，这篇文章不可能看懂）

MDN 对闭包的定义为（**注：**目前 (2022/3/1) 这句话在 MDN 上找不到了...）：

> <font color=FF0000 size=4>闭包是指**那些能够访问自由变量的函数**</font>。

那什么是自由变量呢？

> <font color=FF0000>**自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量**</font>。

由此，我们可以看出闭包共有两部分组成：

> 闭包 = 函数 + 函数能够访问的自由变量

在《JavaScript权威指南》中就讲到：<font color=FF0000>从技术的角度讲，所有的 JavaScript <font size=4>**函数**</font>都是闭包</font>。

这怎么跟我们平时看到的讲到的闭包不一样呢！？别着急，这是理论上的闭包，其实还有一个实践角度上的闭包，让我们看看汤姆大叔翻译的关于闭包的文章中的定义：

**ECMAScript中，闭包指的是：**

- **从理论角度：**所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。

  注：

- **从实践角度：**以下函数才算是闭包：

  - <font color=FF0000 size=4>**即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）**</font>。**注：**这个更重要，也是下面重点讲的
  - 在代码中引用了自由变量

接下来就来讲讲实践上的闭包。

<font size=4>**分析**</font>

让我们先写个例子，例子依然是来自《JavaScript权威指南》，稍微做点改动：

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){ return scope; }
    return f;
}

var foo = checkscope();
foo();
```

首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。

另一个与这段代码相似的例子，在[《JavaScript深入之执行上下文》](https://github.com/mqyqingfeng/Blog/issues/8)中有着非常详细的分析。如果看不懂以下的执行过程，建议先阅读这篇文章。

**这里直接给出简要的执行过程：**

1. 进入全局代码，<font color=FF0000>**创建全局执行上下文，（将）全局执行上下文 压入 执行上下文栈**</font>
2. 全局执行上下文初始化
3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
4. checkscope 执行上下文初始化，创建变量对象、作用域链、this等
5. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
7. f 执行上下文初始化，创建变量对象、作用域链、this等
8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

**注：个人总结**

> 这里无论是 checkscope 函数，还是 f 函数，上面的执行过程都是非常类似的：
>
> 1. 开始执行函数
> 2. 创建“函数执行上下文”
> 3. 将“函数执行上下文”压入“执行上下文栈”
> 4. 执行上下文初始化：创建  VO、作用域链、this 这三样
> 5. 函数执行完毕
> 6. “函数执行上下文”从“执行上下文栈”中弹出
>
> 另外，前3步“全局代码”也有。到这里，“注” 结束

了解到这个过程，我们应该思考一个问题，那就是：<mark>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊（即从执行上下文栈中被弹出），怎么还会读取到 checkscope 作用域下的 scope 值呢？</mark>

当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：

```js
fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}
```

对的，<font color=FF0000>就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值</font>，说明 <font color=FF0000 size=4>**当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它**</font>（**注：**这就是闭包的原理），正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。

<font size=4>**经典闭包题**</font>

```js
var data = [];
for (var i = 0; i < 3; i++) {
  data[i] = function () { console.log(i); };
}

data[0](); // 3
data[1](); // 3
data[2](); // 3
```

**分析一下原因：**当执行到 data[0] 函数之前，此时全局上下文的 VO 为：

```js
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```

当执行 data[0] 函数的时候，data[0] 函数的作用域链为：

```js
data[0]Context = {
    Scope: [AO, globalContext.VO]
}
```

data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。

data[1] 和 data[2] 是一样的道理。

<font color=FF0000>**使用闭包的写法**</font>

```js
var data = [];
for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
        return function(){ console.log(i); }
  })(i);
}

data[0](); // 0
data[1](); // 1
data[2](); // 2
```

当执行到 data[0] 函数之前，此时全局上下文的 VO 为：

```js
globalContext = {
    VO: {
        data: [...],
        i: 3
    }
}
```

跟没改之前一模一样。

当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：

```js
data[0]Context = {
    Scope: [AO, 匿名函数Context.AO globalContext.VO]
}
```

匿名函数执行上下文的AO为：

```js
匿名函数Context = {
    AO: {
        arguments: {
            0: 0,
            length: 1
        },
        i: 0
    }
}
```

<font color=FF0000>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，**这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了**，即使 globalContext.VO 也有 i 的（值为3）</font>，所以打印的结果就是0。data[1] 和 data[2] 是一样的道理

摘自：[JavaScript深入之闭包](https://github.com/mqyqingfeng/Blog/issues/9)

<font color=FF0000>一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）</font>。也就是说，<font color=FF0000 size=4>闭包让你可以**在一个内层函数中 **访问到 **其外层函数的作用域**</font>。在 JavaScript 中，<font color=FF0000><font size=4>**每当创建一个函数**</font>，闭包就会在函数创建的同时被创建出来</font>。

词法（lexical）一词指的是，词法作用域根据源代码中声明变量的位置来确定该变量在何处可用

闭包很有用，因为<font color=FF0000>它允许将函数与其所操作的某些数据（环境）关联起来</font>。这<font color=FF0000>显然类似于面向对象编程</font>。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。（注：这里和OOP类似的说法，下面的后盾人的讲解中会有示例）

因此，<font color=FF0000 size=4>通常你使用只有一个方法的对象的地方，都可以使用闭包</font>。

**注：**在  [MDN - 闭包 - 在循环中创建闭包：一个常见错误](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#creating_closures_in_loops_a_common_mistake) 部分，对于文中的示例，我还是错了；总结如下：闭包产生的必要条件之一是：在函数中 定义 函数。

**性能考量**

<font color=FF0000>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的</font>，因为<font color=FF0000>闭包 **在处理速度和内存消耗方面对脚本性能具有负面影响**</font>。

摘自：[MDN - 闭包](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)

**现代js教程中的 定义：**

闭包 是指： <font color=FF0000 size=4>内部函数总是可以访问**其所在的外部函数中声明的 变量 和 参数**，即使在其外部函数被返回（寿命终结）了之后</font>。在某些编程语言中，这是不可能的，或者应该以特殊的方式编写函数来实现。但是。<font color=FF0000 size=4>在 JavaScript 中，所有函数都是天生闭包的；只有一个例外，即： "new Function" </font>（详见：[现代js教程 - 变量作用域，闭包](https://zh.javascript.info/closure)）。

也就是说：JavaScript 中的函数会自动通过隐藏的 [[Environment]] 属性记住创建它们的位置，所以它们都可以访问外部变量。

在面试时，前端开发者通常会被问到“什么是闭包？”，正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 [[Environment]] 属性和词法环境原理的技术细节。

> 闭包是指 <font color=FF0000>使用一个特殊的属性 [[Environment]] 来记录函数自身的创建时的环境的函数</font>。它<font color=FF0000>具体指向了函数创建时的词法环境</font>。
>
> 摘自：[现代js教程 - "new Function" 语法 - 闭包](https://zh.javascript.info/new-function#bi-bao)

#### 现代js教程中的闭包原理

**一：变量**

在 JavaScript 中，<font color=FF0000> <font size=4>**每个**</font> 运行的函数，代码块 `{...}` 以及整个脚本，都有一个被称为 **词法环境（Lexical Environment）** 的内部（隐藏）的关联对象</font>。

<font size=4>**<font color=FF0000>词法环境对象</font> 由两部分组成：**</font>

1. **环境记录（Environment Record）：** 一个<font color=FF0000>存储所有局部变量作为其属性（包括一些其他信息，例如 <font size=4>**this 的值**</font>）的对象</font>。
2. <font color=FF0000>对 **外部词法环境** 的引用</font>，与外部代码相关联。**注：**由下面可知，这就是通过 \[\[environment]] 内部属性 保存了“对创建该函数的词法环境的引用”

**注：**下面的 [[#LexicalEnvironment 由三个部分构成]] 中也说明了 “词法环境” 的组成部分，与这里不同的是：把 “this的绑定” 单独列出来了；可以作为参考。

一个“变量”只是 **环境记录** 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。

举个例子，这段没有函数的简单的代码中只有一个词法环境：

<img src="https://s2.loli.net/2022/01/06/vRABXebdq614YVO.png" alt="image-20220106195326326" style="zoom: 27%;" />

这就是所谓的与整个脚本相关联的 **全局** 词法环境。

在上面的图片中，<font color=FF0000>矩形表示环境记录（变量存储），箭头表示外部引用</font>。<mark>全局词法环境没有外部引用，所以箭头指向了 null</mark>。

随着代码开始并继续运行，词法环境发生了变化。

这是更长的代码：

<img src="https://s2.loli.net/2022/01/06/qMJlBoSnIdHUFQu.png" alt="image-20220106200157833" style="zoom:30%;" />

**右侧的矩形演示了执行过程中全局词法环境的变化：**

1. <font color=FF0000 size=4>**当脚本开始运行，词法环境预先填充了所有声明的变量**</font>

   <font color=FF0000>最初，它们处于“未初始化 (Uninitialized) ”状态（注：即，处于临时死区） 。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 let 声明前，不能引用它。几乎就像变量不存在一样</font>。

2. 然后 let phrase 定义出现了。它尚未被赋值，因此它的值为 undefined。从这一刻起，我们就可以使用变量了。

3. phrase 被赋予了一个值。

4. phrase 的值被修改。

现在看起来都挺简单的，是吧？

- 变量是特殊内部对象的属性，与当前正在执行的（代码）块 / 函数 / 脚本有关
- 操作变量实际上是操作该对象的属性

> **词法环境是一个规范对象**
>
> “词法环境”是一个规范对象（specification object）：它仅仅是存在于 编程语言规范 中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。**注：**上面提及的 规范对象
>
> 但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。

**二：函数声明**

一个函数其实也是一个值，就像变量一样。**不同之处在于<font color=FF0000>函数声明的初始化会被立即完成</font>。**（**注：**即立即做“函数提升”）

<font color=FF0000>当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数</font>（不像 let 那样直到声明处才可用）。<font color=FF0000>这就是为什么我们可以在（函数声明）的定义之前调用函数声明</font>（注：可以理解为 函数提升）。

例如，这是添加一个函数时全局词法环境的初始状态：

<img src="https://s2.loli.net/2022/01/06/XtcY5kd71KIUbS8.png" alt="image-20220106222306087" style="zoom:40%;" />

<font color=FF0000>**正常来说，这种行为仅适用于函数声明**</font>，而不适用于我们将函数分配给变量的函数表达式，例如 `let say = function(name)...`。

**三：内部和外部的词法环境**

<font color=FF0000>在 **一个函数运行时**，在调用刚开始时，**会自动创建一个新的词法环境以存储这个调用的局部变量和参数**</font>。

例如，对于 `say("John")`，它看起来像这样（当前执行位置在箭头标记的那一行上）：

<img src="https://s2.loli.net/2022/01/06/2LMWR8x3pDsOlGk.png" alt="image-20220106222541757" style="zoom:40%;" />

<font color=FF0000>在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）</font>：

- 内部词法环境与 `say` 的当前执行相对应。它具有一个单独的属性：`name`，函数的参数。我们调用的是 `say("John")`，所以 `name` 的值为 `"John"`。
- 外部词法环境是全局词法环境。它具有 `phrase` 变量和函数本身。

内部词法环境引用了 `outer`。

<font color=FF0000>**当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。**</font>

<mark>如果在任何地方都找不到这个变量，那么在严格模式下就会报错</mark>（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。

在这个示例中，搜索过程如下：

- 对于 `name` 变量，当 `say` 中的 `alert` 试图访问 `name` 时，会立即在内部词法环境中找到它。
- 当它试图访问 `phrase` 时，然而内部没有 `phrase`，所以它顺着对外部词法环境的引用找到了它。

<img src="https://s2.loli.net/2022/01/06/ZJNsdKoGuQF8nIO.png" alt="image-20220106223026406" style="zoom:40%;" />

**四：返回函数**

让我们回到 `makeCounter` 这个例子。

```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
```

在 <font color=FF0000><font size=4>**每次**</font> `makeCounter()` 调用的开始，<font size=4>**都会** 创建一个新的词法环境对象</font>，以存储该 `makeCounter` 运行时的变量</font>。

因此，我们有两层嵌套的词法环境，就像上面的示例一样：

<img src="https://s2.loli.net/2022/04/01/asCwBgzep2YqArT.png" alt="image-20220106223713061" style="zoom:40%;" />

不同的是，在执行 `makeCounter()` 的过程中创建了一个仅占一行的嵌套函数：`return count++`。我们尚未运行它，仅创建了它。

<font color=FF0000 size=4>**所有的函数在“诞生”时都会记住创建它们的词法环境**</font>。从技术上讲，这里没有什么魔法：<font color=FF0000><font size=4>**所有函数都有名为 `[[Environment]]` 的隐藏属性**</font>（**注：**一般翻译为“内部属性”），<font size=4>**该属性保存了「对“创建该函数”的词法环境的 引用」**</font></font>（**注：**即上面说的“词法环境对象 组成的另一部分”）。

<img src="https://s2.loli.net/2022/01/06/mLkqjsYg4iDWoAF.png" alt="image-20220106223906345" style="zoom:40%;" />

<mark>因此，`counter.[[Environment]]` 有对 `{count: 0}` 词法环境的引用</mark>。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。<font color=FF0000 size=4>**`[[Environment]]` 引用在函数创建时被设置并永久保存**</font>。

稍后，当调用 `counter()` 时，会为该调用创建一个新的词法环境，并且其外部词法环境引用获取于 `counter.[[Environment]]`：

<img src="https://s2.loli.net/2022/01/06/uc9Ih7Et4ZlHSRp.png" alt="image-20220106230050113" style="zoom:30%;" />

现在，当 `counter()` 中的代码查找 `count` 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 `makeCounter()` 的词法环境，并且在哪里找到就在哪里修改。**在变量所在的词法环境中更新变量。**

这是执行后的状态：

<img src="https://s2.loli.net/2022/01/06/PS9nAjt3XQHscTq.png" alt="image-20220106230246012" style="zoom:33%;" />

如果我们调用 `counter()` 多次，`count` 变量将在同一位置增加到 `2`，`3` 等。

##### js 的 垃圾收集

**注：**上面已经讲完了 词法环境的生成 和 运行时的状态

<font color=FF0000 size=4>**通常，函数调用完成后，会将词法环境和其中的所有变量从内存中删除**</font>。<font color=FF0000>因为现在没有任何对它们的引用了</font>。与 JavaScript 中的任何其他对象一样，<font color=FF0000 size=4>词法环境仅在可达时才会被保留在内存中</font>（**注：**可达性是JS主要的内存管理的概念。详见：[现代JS教程 - 垃圾回收](https://zh.javascript.info/garbage-collection)）。

但是，<font color=FF0000>**如果有一个嵌套的函数在函数结束后仍可达，则它将具有引用词法环境的 `[[Environment]]` 属性**</font>。<mark>注：即，如果函数还有可能被使用，则不会被回收销毁；则它以及它可达的这条链上的 词法环境 将不会被销毁</mark>。

在下面这个例子中，即使在函数执行完成后，词法环境仍然可达（**注：**这里形成了闭包，在全局环境中被 全局变量引用）。因此，此嵌套函数仍然有效。

```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]] 存储了对相应 f() 调用的词法环境的引用
```

请注意，如果多次调用 `f()`，并且返回的函数被保存，那么所有相应的词法环境对象也会保留在内存中。下面代码中有三个这样的函数：

```js
function f() {
  let value = Math.random();

  return function() { alert(value); };
}

// 数组中的 3 个函数，每个都与来自对应的 f() 的词法环境相关联
let arr = [f(), f(), f()];
```

当词法环境对象变得不可达时，它就会死去（就像其他任何对象一样）。换句话说，它仅在至少有一个嵌套函数引用它时才存在。

在下面的代码中，嵌套函数被删除后，其封闭的词法环境（以及其中的 `value`）也会被从内存中删除：

```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // 当 g 函数存在时，该值会被保留在内存中

g = null; // ……现在内存被清理了
```

摘自：[现代js教程 - 变量作用域，闭包](https://zh.javascript.info/closure)

##### 《现代js教程 - 变量作用域，闭包》的总结思维导图：

![yuque_diagram](https://s2.loli.net/2022/01/07/6Hyzl97phPbcS2Y.png)

摘自：[语雀 - 默言 - 前端学习](https://www.yuque.com/moyanfs/js/xg6x6a)

#### 方应杭的闭包说明

**闭包的定义：**「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。

**闭包的作用：**

闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。

假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。如果不用闭包，你可以直接用一个全局变量：

```js
window.lives = 30 // 还有三十条命
```

这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？<font color=FF0000>用局部变量</font>。

但是用局部变量别人又访问不到，怎么办呢？<font color=FF0000>暴露一个访问器（函数），让别人可以「间接访问」</font>。代码示例如下：

```js
!function(){
  var lives = 50
  window.addOneLife = function(){
    lives += 1
  }
  window.minusOneLife = function(){
    lives -= 1
  }
}()
```

闭包是 JS 函数作用域的副产品。换句话说，正是由于 JS 的函数内部可以使用函数外部的变量，所以这段代码正好符合了闭包的定义。而不是 JS 故意要使用闭包。只要你懂了 JS 的作用域，你自然而然就懂了闭包，即使你不知道那就是闭包！

##### 关于闭包的谣言

闭包会造成内存泄露？错。

说这话的人根本不知道什么是内存泄露。<font color=FF0000>内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来</font>。

闭包里面的变量明明就是我们需要的变量（lives），凭什么说是内存泄露？

这个谣言是如何来的？因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。参见司徒正美的[这篇文章](https://link.zhihu.com/?target=http%3A//www.cnblogs.com/rubylouvre/p/3345294.html)。

摘自：[「每日一题」JS 中的闭包是什么？ - 方应杭的文章 - 知乎](https://zhuanlan.zhihu.com/p/22486908)

**补充：**在 [一道js面试题引发的思考](https://github.com/kuitos/kuitos.github.io/issues/18) 中有同样的看法

> 最后，关于闭包引起的内存泄露那都是因为浏览器的 gc 问题（IE8以下为首）导致的，跟 js 本身没有关系，所以，请不要再问 js 闭包会不会引发内存泄露了，谢谢合作！
>
> 摘自：[一道js面试题引发的思考](https://github.com/kuitos/kuitos.github.io/issues/18)

#### 阮一峰 文章中的“闭包使用注意点”

1. <font color=FF0000>由于 **闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包**，否则会造成网页的性能问题</font>，在 IE 中可能导致内存泄露（**注：**上面方应杭的文章说不会导致内存泄漏，而只是 IE 的问题；详见上面）。<font color=FF0000>解决方法是，在退出函数之前，将不使用的局部变量全部删除</font>（**注：**比如设置为 null）。
2. <font color=FF0000>闭包会在父函数外部，改变父函数内部变量的值</font>。所以，如果你把父函数当作对象 ( object )使用，把闭包当作它的公用方法( Public Method )，把内部变量当作它的私有属性( private value )，这时一定要小心，不要随便改变父函数内部变量的值。

摘自：[阮一峰 - 学习Javascript闭包（Closure）](https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)

#### 后盾人视频的“闭包”讲解

默认情况下，函数执行完毕就会被销毁掉（包含词法环境）；但是，存在执行完毕后不会被销毁掉的。之所以为什么不被销毁掉，是因为使用全局环境下的变量引用，仍有可能被使用，所以不会被销毁。

<font color=FF0000 size=4>**一个函数被调用多次，就会生成多个独立的（互不影响的）词法环境，生成多个内存空间**</font>。

```js
function foo() {
  let n = 1
  function sum() { console.log(++n) }
  sum()
}
foo() // 2
foo() // 2
```

如上面所说，上面的代码，结果是打印 两个 `2` 。如果想要打印 `2` 和 `3`，需要 将 sum函数 return 出来，由一个全局环境的变量接受，这样就不会被销毁，也能让一块内容空间（词法环境）一直被使用

```js
function foo() {
  let n = 1
  return function sum() { console.log(++n) }
}
let bar = foo()
bar() // 2
bar() // 3
```

**构造函数与闭包**

```js
// 构造函数Foo
function Foo() {
  let n = 1
  this.sum = function() {
    console.log(++n)
  }
}
let foo = new Foo()
foo.sum() // 2
foo.sum() // 3

let bar = new Foo()
bar.sum() // 2
bar.sum() // 3
```

<font color=FF0000 size=4>**上面的构造函数就类似于：**</font>

```js
function Foo() {
  let n = 1
  this.sum = function() {
    console.log(++n)
  }
  return sum
}
```

**注：**上面说的 构造函数 类似于 return，感觉很有道理。

**var是没有块级作用域，但是有函数作用域。**

```js
for(var i = 0; i <= 3; i++) {
  setTimeout(function() {
    console.log(i)
  }, 1000)
} // 3 3 3
```

用函数将var包裹：

```js
for(var i = 0; i <= 3; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i)
    }, 1000)
  })(i)
} // 1 2 3
```

**闭包的应用**

通过返回函数，让代码更有复用性

```js
let arr = [1, 2, 3, 4, 5]
function between(a, b) {
  return function(v) {
    return v >= a && v <= b
  }
}
console.log(arr.filter(between(2, 4)))
```

学习自：[后盾人 - 第九章 这次把JS闭包给你讲得明明白白](https://www.bilibili.com/video/BV1YJ411R7ap)

#### 技术蛋老师 的视频讲解

**JS的执行上下文分为 三种：**

- **全局环境**
- **函数环境**
- **Eval环境**（慎用）

**注：**这里在《红宝书 第四版》中的 4.2.1 作用域链增强 ( P89 ) 中也有提到。另外，下面 [[#词法环境 LexicalEnvironment 的类型]] 中也说到了 词法环境分为：全局环境、模块环境、函数环境；词法环境不是属于执行上下文么？这里有点不清楚... TODO

因为JS是单线程的（一次做一件事），js处理多个执行上下文的方式是通过“栈”的形式。

**创建执行上下文是分为两个步骤的：**

1. **创建阶段：** 会创建：
   - 作用域链：相当于一个集合，包含：当前变量对象 + <font color=FF0000><font size=4>**所有父级** </font>变量对象</font>
   - 变量对象：包含：参数、变量、函数声明
   - 决定 this 的值
   
   **注：**根据 [JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8) 的说法：<font color=FF0000 size=4>**每个执行上下文，都有三个重要属性：1) 变量对象 ( Variable object，VO )、2) 作用域链(Scope chain)、3) this**</font>；所以，这里创建的三个东西就是执行上下文中的内容。
   
2. **执行阶段：**执行函数中每一行代码，会进行：<font color=FF0000>变量赋值，函数引用等动作</font>

**执行上下文 示例如下：**

- **代码**

  ```js
  function books() {
    var book = '书包里的书'
    return function() { cnosole.log(book) }
  }
  var bag = books()
  bag()
  ```

- **栈（由上到下）和执行上下文 结构：**

  - **匿名函数执行上下文：**{ 作用域链：{ 匿名函数变量对象 + books变量对象 + 全局变量对象 }, { 变量对象: 无} }
  - **books执行上下文：**{ 作用域链: { books变量对象 + 全局变量对象 }, { 变量对象: book } }
  - **全局执行上下文：**{ 作用域链: { 全局变量对象 }, { 变量对象: books, bag } }

**闭包代码题目：**

```js
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i++)
  }, 4000)
}
console.log(i)
```

结果为 5 5 6 7 8 9。另外，setTimeout输出的 5 6 7 8 9 是在4秒后**一起**输出的，而不是 分别间隔4秒输出。

**解释：**这里的setTimeout中的匿名函数被放到了任务队列中，并且由于没有实际执行，所以这里没有计算结果（也就是：依然以 i++ 的形式存在）。

新的问题：修改代码，使得上面的代码，输出 5 0 1 2 3 4：

```js
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i++)
    }, 4000)
  })(i)
}
console.log(i)
```

这里的原理是：把每一轮循环的i值保存起来，用 IIFE 实现（这里创建了 IIFE 的执行上下文，变量对象中的不再是i+1，而是值；这些值被放入队列）；等到出任务队列时，再使用即可。

学习自：[JavaScript闭包 - Web前端工程师面试题讲解](https://www.bilibili.com/video/BV1iE411q7Qd) 参考视频：[快速掌握 JS 面试题之『作用域和闭包』](bilibili.com/video/BV1Kv411778c)

#### 词法环境 和 执行上下文的区别

在上面讲解闭包的过程中，由于《现代JS教程》通过词法环境进行解释，而蛋老师的 [JavaScript闭包 - Web前端工程师面试题讲解](https://www.bilibili.com/video/BV1iE411q7Qd) 则是通过执行上下文进行解释；让我产生了好奇，这两者的区别。以下内容摘自：[JS夯实之执行上下文与词法环境](https://juejin.cn/post/6844904145372053511)

<font size=4>**先说结论：**</font><font color=FF0000>**执行上下文 包含 词法环境**</font>

<font size=4>**执行上下文(Execution Context)**</font>

<font color=FF0000>执行上下文是用来 跟踪记录代码运行时环境的 抽象概念</font>。每一次代码运行都至少会生成一个执行上下文。代码都是在执行上下文中运行的。

在执行上下文中记录了代码执行过程中的状态信息，<mark>根据不同运行场景，执行上下文会细分为：全局执行上下文、函数执行上下文、eval执行上下文</mark>（ [[#技术蛋老师 的视频讲解]] 中有详细讲解，这里略）

<font size=4>**执行栈**</font>（**注：**也被称为 “调用栈”，这种说法来自 [百度百科 - 执行栈](https://baike.baidu.com/item/执行栈/22105693)，另外，下面第二行也有说）

**有了执行上下文，就要有<font color=FF0000>合理管理它的工具</font>**。而 <font color=FF0000>**执行上下文栈 ( Execution Context Stack ) 是用来 <font size=4>管理执行期间创建的所有执行上下文的数据结构</font>**</font>，它是一个 LIFO（后进先出）的栈，<font color=FF0000>它也是我们熟知的 <font size=4>**JS 程序运行过程中的 调用栈**</font></font>。 <font color=FF0000>**程序开始运行时，会先创建一个全局执行上下文并压入到执行栈中，之后每当有函数被调用，都会创建一个新的函数执行上下文并压入栈内**</font>。

**了解执行栈工作过程示例：**

```js
console.log('script')
function foo(){
  function bar(){ console.log('bar', isNaN(undefined)) }
  bar()
  console.log('foo')
}
foo()
```

当这段JS程序<font color=FF0000>开始运行时</font>，它<font color=FF0000>**会创建一个全局执行上下文 GlobalContext**</font>，其中 <font color=FF0000><font size=4>会初始化一些全局对象或全局函数</font>，如代码中的 console、undefined、isNaN</font>。<font color=FF0000>将全局执行上下文压入执行栈</font>（**注：**关于有哪些全局属性 / 函数，可以参考 [w3school - JavaScript 全局参考手册](https://www.w3school.com.cn/jsref/jsref_obj_global.asp)。另外，MDN 中也有讲述全局对象，不过不怎么详细，仅供参考：[MDN - 全局对象](https://developer.mozilla.org/zh-CN/docs/Glossary/Global_object)），<font color=FF0000 size=4>**通常 JS引擎都有一个指针 `running` 指向栈顶元素**</font>：

<img src="https://s2.loli.net/2022/01/08/RU4Il9GvyB81Frt.png" alt="img" style="zoom:55%;" />

<font color=FF0000>JS引擎 会将全局范围内声明的函数 ( `foo` ) 初始化在全局上下文中</font>（<mark>当然，当调用 “log函数” 时，也是要新建函数上下文并压栈到调用栈中的。为了简单流程，忽略了 “log函数” 上下文的创建过程</mark>），之后开始一行行的执行代码，运行到 `console` 就在 `running` 指向的上下文中的词法环境中找到 “全局对象 `console`” 并调用 `log` 函数。

运行到 `foo()` 时，识别为函数调用，此时<font color=FF0000>创建一个新的执行上下文 `FooContext` 并入栈</font>，<font color=FF0000>将 `FooContext` 内词法环境的 outer 引用指向全局执行上下文的词法环境，**移动 `running` 指针指向这个新的上下文**</font>：

<img src="https://s2.loli.net/2022/01/08/Vk8eWBlfR9tdNiO.png" alt="img" style="zoom:55%;" />

在完成 `FooContext` 创建后，进入到 `FooContext` 中继续执行代码，运行到  `bar()`  时，同理仍需要新建一个执行上下文 `BarContext`，<mark>此时 `BarContext` 内词法环境的 outer 引用会指向 FooContext 的词法环境</mark>：

<img src="https://s2.loli.net/2022/01/08/fk3TzOhSZgKFp8d.png" alt="img" style="zoom:55%;" />

继续运行 `bar` 函数，<font color=FF0000 size=4>由于函数上下文内有 `outer` 引用实现层层递进引用，因此**在 `bar` 函数内仍可以获取到 `console` 对象并调用 `log`**</font>（**注：**为防止忘记，提醒下（上面也有说到）创建全局执行上下文时，会初始化一些全局对象或全局函数，包含 console）

<font color=FF0000>之后，完成 `bar` 和 `foo` 函数调用，会依次将上下文出栈，直至全局上下文出栈，程序结束运行</font>。

![img](https://s2.loli.net/2022/01/08/EwZ6ohLCX7TFVdR.png)

<font size=4>**执行上下文的创建**</font>

**执行上下文创建会做两件事情：**

1. <font color=FF0000>**创建 词法环境**</font> ( Lexical Environment )：<font color=FF0000>词法环境是 **let const** </font>
2. <font color=FF0000>**创建 变量环境**</font> ( Variable Environment )：<font color=FF0000>变量环境是为适配 **var** 专门存在的</font>

因此一个执行上下文在概念上应该是这样子的：

```js
ExecutionContext = {
  LexicalEnvironment = <ref. to LexicalEnvironment in memory>,
  VariableEnvironment = <ref. to VariableEnvironment in  memory>,
}
```

在全局执行上下文中，this指向全局对象，window in browser / global in nodejs。

<font size=4>**词法环境 ( LexicalEnvironment )**</font>

<font color=FF0000>词法环境是 ECMA 中的一个规范类型：基于代码词法嵌套结构用来 **记录标识符和具体变量或函数的关联**</font>。 简单来说，<font color=FF0000>**词法环境就是建立了<font size=4> 标识符——变量 </font>的映射表**</font>。这里的 <font color=FF0000><font size=4>**标识符**</font> 指的是 <font size=4>**变量名称或函数名**</font></font>，而<font color=FF0000><font size=4>**变量**</font> 则是实际变量原始值或者对象/函数的 <font size=4>**引用地址**</font></font>。

##### LexicalEnvironment 由三个部分构成

- **环境记录 EnvironmentRecord：**<font color=FF0000>**存放变量和函数声明的地方**</font>。 **注：**这里提及的 “环境记录” 在下面有说明 [[#环境记录 ER]]
- **外层引用 outer：**<font color=FF0000>提供了访问父词法环境的引用</font>，可能为null
- **this 绑定 ThisBinding：**<font color=FF0000>确定当前环境中this的指向</font>



##### 词法环境 LexicalEnvironment 的类型

- **全局环境 ( GlobalEnvironment )：**<font color=FF0000>在 JavaScript 代码运行伊始，宿主（浏览器、NodeJs 等）会事先初始化全局环境，在全局环境的 EnvironmentRecord 中会绑定内置的全局对象（`Infinity`等）或 全局函数（ `eval`、`parseInt`等），其他声明的全局变量或函数也会存储在全局词法环境中</font>。<mark>全局环境的 outer 引用为 null</mark>。

  > 这里提及的全局对象就有我们熟悉的所有内置对象，如 Math、Object、Array 等构造函数，以及 Infinity 等全局变量。全局函数则包含了 eval、parseInt等函数。

- **<font color=FF0000>模块环境 ( ModuleEnvironment )</font>：**你若写过 NodeJs 程序就会很熟悉这个环境，<font color=FF0000 size=4>**在模块环境中你可以读取到 `export`、`module` 等变量，这些变量都是记录在模块环境的ER中**</font>。<font color=FF0000>模块环境的 outer 引用指向全局环境</font>。
- **函数环境 ( FunctionEnvironment )：**<font color=FF0000><font size=4>**每一次**</font>调用函数时都会产生函数环境，在函数环境中会涉及 `this` 的绑定或 `super` 的调用</font>。<mark>在 **环境记录 ( ER )** 中也会记录该函数的 length 和 arguments 属性</mark>。函数环境的 outer 引用指向调起该函数的父环境。<font color=FF0000>在函数体内声明的变量或函数则记录在函数环境中</font>。

##### 环境记录 ER

<font color=FF0000>**代码中声明的 变量 和 函数 都会存放在 EnvironmentRecord 中等待执行时访问**</font>。 <mark>环境记录 **EnvironmentRecord 也有两个不同类型**，分别为 **declarative ER** 和 **object ER**</mark>

- <font color=FF0000>**declarative ER 是较为常见的类型，通常函数声明、变量声明都会生成这种类型的 ER**</font>
- <mark>**object ER** 可以由 with 语句触发的</mark>，而 with 使用场景很少，一般开发者很少用到

如果你在函数体中遇到诸如 var、const、let、class、module、import 函数声明，那么环境记录就是 declarative类型的。

值得一提的是<font color=FF0000 size=4>**全局上下文的ER** 有一点特殊，因为 **它是 object ER 与 declarative ER 的混合体**</font>。

- **object ER** 中存放的是<font color=FF0000>全局对象函数、function函数声明、async、generator、var 关键词变量</font>
- **declarative ER** 则<font color=FF0000>存放其他方式声明的变量，如 let、const、class等</font>

<font color=FF0000>**由于标准中将 object ER 视作 基准ER，因此这里我们仍将 全局ER 的类型视作 object**</font>

```js
GlobalExecutionContext = {
    LexicalEnvironment: {
        EnvironmentRecord: {
            type: 'object',  // 混合 object + declarative
            NaN,
            parseInt,
            Object,
            myFunc,
            a,
            b,
            ...
        },
        outer: null,
        this: <globalObject>
    }
}
```

LexicalEnvironment 只存储函数声明和 let / const 声明的变量，与下文的 VariableEnvironment 有所区别。

**示例如下：**

```js
let a = 10;
function foo(){
    let b = 20
    console.log(a, b)
}
foo()
```

**词法环境伪码**

```js
GlobalEnvironment: {
    EnvironmentRecord: {
        type: 'object',
        a: <uninitialized>,
        foo: <func>
    },
    outer: <null>,
    this: <globalObject>
}

FunctionEnvironment: {
    EnvironmentRecord: {
        type: 'declarative',
        arguments: {length: 0},
        b: <uninitialized>,
    },
    outer: <GlobalEnvironment>,
    this: <globalObject>  // 严格模式下为 undefined
}
```

**函数环境记录**

由于函数环境是日常开发过程最常见的词法环境，因此需要更加深入的研究一下函数环境的运行机制，帮助我们更好理解一些语言特性。

当调用一个函数时，会生成 “函数执行上下文”，函数执行上下文 的词法环境的环境记录就是函数类型的，有点拗口，用树形图代表一下：

```js
FunctionContext
    |LexicalEnvironment
        |EnvironmentRecord  //--> 函数类型
```

<font color=FF0000>**为什么要强调这个类型呢？因为ECMA针对函数式环境记录会额外增加一些内部属性：**</font>

| 内部属性              | Value                                       | 说明                                                         | 补充                                                         |
| --------------------- | ------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [[ThisValue]]         | Any                                         | 函数内调用this时引用的地址，我们常说的函数this绑定就是给这个内部属性赋值 |                                                              |
| [[ThisBindingStatus]] | "lexical" / "initialized" / "uninitialized" | 若等于lexical，则为箭头函数，意味着this是空的；              | 强行new箭头函数会报错TypeError错误                           |
| FunctionObject        | Object                                      | 在这个对象中有两个属性[[Call]]和[[Construct]]，它们都是函数，如何赋值取决于如何调用函数 | 正常的函数调用赋值[[Call]]，而通过new或super调用函数则赋值[[Construct]] |
| [[HomeObject]]        | Object / undefined                          | 如果该函数(非箭头函数)有super属性(子类)，则[[HomeObject]]指向父类构造函数 | 若你写过extends就知道我在说什么                              |
| [[NewTarget]]         | Object / undefined                          | 如果是通过[[Construct]]方式调用的函数，那么[[NewTarget]]非空 | 在函数中可以通过new.target读取到这个内部属性。以此来判断函数是否通过new来调用的 |

此外，函数环境记录中还存有一个arguments对象，记录了函数的入参信息。

<font size=4>**小结**</font>

概念类型太多，有一些凌乱了。简单速记一下：

- 词法环境分类：全局 / 函数 / 模块
- 词法环境：ER ( env record ) + outer + this
  - ER分类：declarative ( DER ) + object ( OER )
  - 全局ER：DER + OER


<font size=4>**VariableEnvironment 变量环境**</font>

在 ES6 前，声明变量都是通过 var 关键词声明的，在 ES6 中则提倡使用 let 和 const 来声明变量，为了兼容 var 的写法，于是使用变量环境来存储 var 声明的变量

> var 关键词有个特性，会让变量提升，而通过 let / const 声明的变量则不会提升。为了区分这两种情况，就用不同的词法环境去区分。

<font color=FF0000>变量环境 本质上仍是 词法环境，但它只存储 var 声明的变量</font>，这样在初始化变量时可以赋值为 undefined。

有了这些概念，一个完整的执行上下文应该是什么样子的呢？来点例子🌰：

```js
let a = 10;
const b = 20;
var sum;

function add(e, f){
    var d = 40;
    return d + e + f 
}

let utils = { add }

sum = utils.add(a, b)
```

完整的执行上下文如下所示：

```js
GlobalExecutionContext = {
    LexicalEnvironment: {
        EnvironmentRecord: {
            type: 'object',
            add: <function>,
            a: <uninitialized>,
            b: <uninitialized>,
            utils: <uninitialized>,
        },
        outer: null,
        this: <globalObject>
    },
    VariableEnvironment: {
        EnvironmentRecord: {
            type: 'object',
            sum: undefined
        },
        outer: null,
        this: <globalObject>
    },
}

// 当运行到函数add时才会创建函数执行上下文
FunctionExecutionContext = {
    LexicalEnvironment: {
        EnvironmentRecord: {
            type: 'declarative',
            arguments: {0: 10, 1: 20, length: 2},
            [[ThisValue]]: <utils>,
            [[NewTarget]]: undefined,
            ...
        },
        outer: <GlobalLexicalEnvironment>,
        this: <utils>
    },
    VariableEnvironment: {
        EnvironmentRecord: {
            type: 'declarative',
            d: undefined
        },
        outer: <GlobalLexicalEnvironment>,
        this: <utils>
    },
}
```

执行上下文创建后，进入到执行环节，变量在执行过程中赋值、读取、再赋值等。直至程序运行结束。 我们注意到，在执行上下文创建时，变量 a b 都是 \<uninitialized> 的，而 sum 则被初始化为 undefined。这就是为什么你可以在声明之前访问 var 定义的变量(变量提升)，而访问 let / const 定义的变量就会报引用错误的原因。

摘自：[JS夯实之执行上下文与词法环境](https://juejin.cn/post/6844904145372053511)



#### IIFE 相关

定义一个函数，像这样 function foo(){} 或者 var foo = function(){}，调用时，你都需要在后面加上一对圆括号，像这样 foo()。

因为foo相对于函数表达式 `function(){/* code */}` 只是一个引用变量。那这可以说明函数表达式可以通过在其后加上一对括号自己调用自己吗？

```js
function foo(){ /* code */ }(); // SyntaxError: Unexpected token ')'
// 注：这样的报错，和原文中的不一样，因为无法复现原文中的报错。另外，这里的写法等价于如下代码：
function foo() { /* code */ } // 这里可以换行
(); // 这里报错是因为：括号中没有值，无法求值。这里括号的作用参见下面的补充：括号的作用。如果在括号中加上内容，是不会报错的

function foo() { /* code */ }(1) // 但是，没有输出，因为没有调用 foo 函数
```

正如你所看到的，这里捕获了一个错误。<font color=FF0000>**这是因为：**</font>当圆括号为了调用函数出现在函数后面时，<font color=FF0000 size=4>**无论在 全局环境 或者 局部环境 里遇到了 function 关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式**</font>。如果你不明确的告诉圆括号它（它是指 `function() {}` ）是一个表达式，<font color=FF0000>它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字</font>。

那么就可以 先给 函数加上名字再调用，这样是可以的：

```js
var foo = function() { console.log('foo') }()
```

使用 IIFE，最流行也最被接受的方法是 <font color=FF0000>将函数声明包裹在圆括号里 来告诉语法分析器去表达一个函数表达式</font>（**注：**即 `( () => {} )()` ），因为<font color=FF0000 size=4>**在JS里，圆括号不能包含声明**</font>（**注：**感觉用“不会”更好些？即：js引擎认为 括号中“不会”包含声明）。<font color=FF0000>因为这点，当圆括号为了包裹函数碰上了 function 关键词，它便知道将它作为一个函数表达式去解析而不是函数声明</font>。

##### 生成 IIFE 的方式如下

- 如下两种模式，都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量

  ```js
  (function(){/* code */}()); // Crockford recommends this one，括号内的表达式代表函数立即调用表达式
  (function(){/* code */})(); // But this one works just as well，括号内的表达式代表函数表达式
  ```

- 可以使用括号 或者 强制运算符( coercing operator )，消除 （function 语句）是“函数表达式”还是“函数声明”的歧义

  ```js
  var i = function(){ return 10 }();
  true && function(){ /*code*/ }();
  0, function(){}();
  ```

- 如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节

  ```js
  !function(){ /* code */ }();
  ~function(){ /* code */ }();
  -function(){ /* code */ }();
  +function(){ /* code */ }();
  ```

- 如下也是一种方法：

  ```js
  new function(){ /* code */ }() // Only need parens if passing arguments
  ```

##### 关于括号生成 IIFE 方法

额外的带着歧义的括号围绕在函数表达式周围是没有必要的(因为这时候的括号已经将其作为一个表达式去表达)，但当括号用于调用函数表达式时，这仍然是一个好主意

这样的括号指明函数表达式将会被立即调用，并且变量将会储存函数的结果，而不是函数本身。当这是一个非常长的函数表达式时，这可以节约比人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。

##### 看视频 “IIFE 立即执行函数 中的坑 && （） 括号的用法” 的补充

括号的作用：1. 求值（返回一个值。同时，括号中不能写一个表达式，会报错。另外，其中是可以写一个函数的，因为：函数是一个值。）

为了让function 的语句 被认为是“表达式”，可以让其“求值”，从而得到表达式。比如通过：赋值、括号求值、以及运算（算术运算、逻辑运算、位运算）

学习自：[IIFE 立即执行函数 中的坑 && （） 括号的用法【前端必会核心】](https://www.bilibili.com/video/BV1ob4y1k7Qw)



#### 事件循环 event loop

<font size=4>**为什么 JavaScript 是单线程？**</font>

<font color=FF0000>JavaScript语言的一大特点就是单线程</font>，也就是说，<font color=FF0000>同一个时间只能做一件事</font>。

<mark>JavaScript的单线程，与它的用途有关</mark>。<font color=FF0000>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题</font>。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

<font color=FF0000>为了利用多核CPU的计算能力，HTML5提出**Web Worker标准**，**允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM**</font>。所以，这个新标准并没有改变JavaScript单线程的本质。

<font size=4>**任务队列**</font>

<mark>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务</mark>。<mark>如果前一个任务耗时很长，后一个任务就不得不一直等着</mark>。<mark style=background-color:aqua>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行</mark>。

JavaScript语言的设计者意识到：<font color=FF0000>这时主线程完全可以不管IO设备，**挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去**</font>。

于是，<font color=FF0000 size=4>**所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）**</font>

- **同步任务 **指的是：<font color=FF0000>在主线程上排队执行的任务</font>，<mark>只有前一个任务执行完毕，才能执行后一个任务</mark>。<font color=FF0000 size=4>**同步任务运行在执行栈中**</font>
- **异步任务** 指的是：<font color=FF0000 size=4>不进入主线程、而进入"任务队列"（task queue）的任务，**只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行**</font>

**具体来说，异步执行的运行机制如下**。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）

1. 所有同步任务都在主线程上执行，形成一个 <font color=FF0000 size=4>**执行栈**</font>（execution context stack）。

2. 主线程之外，还存在一个"任务队列"（task queue）。<font color=FF0000 size=4>只要异步任务有了运行结果，就在"任务队列"之中放置一个事件</font>
3. <font color=FF0000>一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件</font>。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4. <font color=FF0000>主线程不断重复上面的第三步</font>。

下图就是主线程和任务队列的示意图：只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

<img src="https://s2.loli.net/2022/01/09/WP3Lnsimz4KCqlB.jpg" alt="任务队列" style="zoom:90%;" />

<font size=4>**事件和回调函数**</font>

“任务队列” 是一个事件的队列（也可以理解成消息的队列），<font color=FF0000 size=4>**IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了**</font>（注：这里之前我的理解有问题）。主线程读取"任务队列"，就是读取里面有哪些事件。

<font color=FF0000>"任务队列"中的事件，除了IO设备的事件以外，**还包括一些用户产生的事件**（比如鼠标点击、页面滚动等等）</font>。<mark>只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取</mark>。

所谓 “回调函数”（callback），就是那些会被主线程挂起来的代码。<font color=FF0000 size=4>异步任务必须指定回调函数</font>，当主线程开始执行异步任务，就是执行对应的回调函数。

<mark>”任务队列“ 是一个先进先出的数据结构，排在前面的事件，优先被主线程读取</mark>。主线程的读取过程基本上是自动的，<font color=FF0000>只要执行栈一清空，"任务队列"上 第一位的事件就自动进入主线程</font>。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。

<font size=4>**Event Loop**</font>

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。

为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲[《Help, I'm stuck in an event-loop》](https://vimeo.com/96425312)）。

<img src="https://s2.loli.net/2022/01/10/PVGgz9QR2thAaXc.png" alt="Event Loop" style="zoom:80%;" />

上图中，<font color=FF0000 size=4>主线程运行的时候，产生堆（heap）和栈（stack），**栈中的代码调用各种外部API，它们在"任务队列"中加入各种事件**（click，load，done）</font>。<mark>只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数</mark>。

执行栈中的代码（同步任务），总是在读取"任务队列"（异步任务）

<font size=4>**定时器**</font>

除了放置异步任务的事件，"任务队列"还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做"定时器"（timer）功能，也就是定时执行的代码。

定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。

setTimeout() 接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。

**setTimeout(fn,0)** 的含义是，<font color=FF0000>指定某个任务在主线程最早可得的空闲时间执行</font>，也就是说，尽可能早得执行。<font color=FF0000 size=4>**它在"任务队列"的尾部添加一个事件**</font>，因此 <font color=FF0000 size=4>**要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行**</font>。

<font color=FF0000 size=4>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），**不得低于4毫秒**</font>，如果低于这个值，就会自动增加（注：[为什么 setTimeout 有最小时延 4ms ? - BY1024的文章 - 知乎](
https://zhuanlan.zhihu.com/p/155752686) 这篇文章很好的讲述了 原因。）。在此之前，老版本的浏览器都将最短间隔设为10毫秒。<font color=FF0000>另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次</font>。这时使用 requestAnimationFrame() 的效果要好于 setTimeout()。

需要注意的是，setTimeout() 只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在 setTimeout() 指定的时间执行。

<font size=4>**Node.js的Event Loop**</font>

<mark>Node.js 也是单线程的 Event Loop，但是它的运行机制不同于浏览器环境</mark>。请看下面的示意图（作者[@BusyRich](https://twitter.com/BusyRich/status/494959181871316992)）。

![Node.js](https://s2.loli.net/2022/01/10/STUOzgrlV2LNPDC.png)

**根据上图，Node.js的运行机制如下：**

1. V8引擎解析JavaScript脚本
2. 解析后的代码，调用Node API
3. libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎
4. V8引擎再将结果返回给用户

除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与"任务队列"有关的方法：[process.nextTick](https://nodejs.org/docs/latest/api/process.html#process_process_nexttick_callback)和[setImmediate](https://nodejs.org/docs/latest/api/timers.html#timers_setimmediate_callback_arg)。它们可以帮助我们加深对"任务队列"的理解。

- <font color=FF0000>**process.nextTick**方法可以在当前"执行栈"的尾部，<font size=4>**下一次Event Loop（主线程读取"任务队列"）之前 触发回调函数**</font></font>。也就是说，<font color=FF0000 size=4>它指定的任务总是发生在所有异步任务之前</font>。
- <font color=FF0000>**setImmediate**方法则是在当前"任务队列"的尾部添加事件</font>，也就是说，<font color=FF0000>它指定的任务总是在下一次Event Loop时执行</font>，这与setTimeout(fn, 0)很像。

**process.nextTick 和 setImmediate的一个重要区别：**多个process.nextTick语句总是在当前"执行栈"一次执行完，多个setImmediate可能则需要多次loop才能执行完。事实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取"事件队列"！

```js
process.nextTick(function foo() {
  process.nextTick(foo);
});
```

事实上，现在要是你写出递归的process.nextTick，Node.js会抛出一个警告，要求你改成setImmediate。

摘自：[阮一峰 - JavaScript 运行机制详解：再谈Event Loop](https://www.ruanyifeng.com/blog/2014/10/event-loop.html)

异步函数（比如setTimeout）执行之后，浏览器会把异步函数（比如是：setTimeout(fn, 5000) ）的回调函数 放到 <font color=FF0000 size=4>Event Table</font>中。<font color=FF0000 size=4>**Event Table 就是个注册站：调用栈让Event Table注册一个函数**，该函数会在5秒之后被调用</font>。<font color=FF0000 size=4>当指定的事情发生时，Event Table会将这个函数移到Event Queue</font>。<font color=FF0000 size=4>**Event Queue其实就是个缓冲区域**，这里的函数等着被调用并移到调用栈</font>

问题来了，什么时候函数会从Event Queue移到调用栈？<font color=FF0000>JavaScript引擎依据一条规则：有一个monitoring process（不知翻译成啥好）会持续不断地检查调用栈是否为空，一旦为空，它会检查Event Queue里边是否有等待被调用的函数</font>。如果存在，它就会调用这个Queue中第一个函数并将其移到调用栈中。如果Event Queue为空，那么这个monitoring process会继续不定期的检查。这一整个过程就是**Event Loop**。

摘自：[JavaScript 事件循环（译文JavaScript Event Loop）](https://segmentfault.com/a/1190000006811224) 另外，其中有 代码流程示例，推荐阅读。

**补充示图：**

<img src="https://s2.loli.net/2022/01/10/SBkJ2ogzhAfQIbi.png" alt="截屏2022-01-10 下午5.37.23" style="zoom: 22%;" />

摘自：[再学JavaScript ES(6-11)全版本语法大全 - 4 - 1](https://coding.imooc.com/class/chapter/444.html)

**补充 名词解释：**

- **Event Table：**可以理解成一张 “事件 --> 回调函数” 的对应表，用来存储 JavaScript 中的异步事件 (request, setTimeout, IO等) 及其对应的回调函数的列表
- **Event Queue：**简单理解就是 回调函数 队列，所以它也叫 Callback Queue。<font color=FF0000>**当 Event Table 中的事件被触发，事件对应的 回调函数 就会被 push 进这个 Event Queue**</font>，然后等待被执行

摘自：[浅析 JS 中的 EventLoop 事件循环（新手向）](https://mp.weixin.qq.com/s/_izT6XaJNrQBOu-GIHa6PA)

另外，在“神说要有光”的文章[Event Loop 和 JS 引擎、渲染引擎的关系](https://mp.weixin.qq.com/s/1PCQMgrXt4bPYtW-uVZgHQ)中，对 event loop做了论述；当然文章的侧重点不完全在 event loop；此文已阅读，在 [[js及其基本库备忘录#Event Loop 和 JS 引擎、渲染引擎的关系]] 部分 做了摘抄、笔记和备注。



## Vue

#### Vue的特点：

- **渐进式：**就是<font color=FF0000>一开始不需要你完全掌握它的全部功能特性，可以后续逐步增加功能</font>



#### Vue2 \$on \$off

this.$on 可以定义多个事件，绑定同一个处理函数；也可以为同一个事件绑定多个处理函数

- 定义多个事件，并绑定同一个处理函数

  ```js
  this.$on(['my_event', 'my_event2'], this.handleEvents)
  ```

- 同一个事件定义多个处理函数：

  ```js
  this.$on('my_event', this.handleEvents)
  this.$on('my_event', this.handleEvents2)
  ```

  处理函数会按照定义的（注册？）顺序，依次执行

**相关的hook**

开发过程中我们有时候要创建一个定时器，在组件被销毁之前，这个定时器也要销毁。代码如下：

```js
mounted() {
  // 创建一个定时器
  this.timer = setInterval(() => {
      // ...
    }, 500)
  },
  // 销毁这个定时器。
  beforeDestroy() {
    if (this.timer) {
      clearInterval(this.timer)
      this.timer = null
    }
  }
}
```

这种写法有个很明显的弊端：定时器 timer 的创建和清理并不是在一个地方，这样很容易导致忘记去清理！

我们可以借助 hook 对代码整合，这样代码也更容易维护了：

```js
mounted() {
    let timer = setInterval(() => {
      // ......
    }, 500);
    this.$once("hook:beforeDestroy", function() {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
    });
  }
```

在 Vue 组件中，可以用过 \$on、\$once 去监听所有的生命周期钩子函数，如监听组件的 updated 钩子函数可以写成 this.\$on('hook:updated', () => {})。

> **补充：**这样的话，我们就<font color=FF0000>可以在一个生命周期方法里监听其余生命周期的发生</font>。
>
> 摘自：[Vue@hook那些事](https://zhuanlan.zhihu.com/p/142395540)

hook 还可以 <font color=FF0000>**外部监听组件的生命周期函数**</font>。在某些情况下，我们需要在父组件中了解一个子组件何时被创建、挂载或更新。

比如，如果你要在第三方组件 CustomSelect 渲染时监听其 updated 钩子，可以通过 @hook:updated 来实现：

```vue
<template>
  <!-- 通过@hook:updated监听组件的updated生命钩子函数 -->
  <!-- 组件的所有生命周期钩子都可以通过@hook:钩子函数名 来监听触发 -->
  <custom-select @hook:updated="doSomething" />
</template>
<script>
import CustomSelect from "../components/custom-select";
export default {
  components: { CustomSelect },
  methods: {
    doSomething() { console.log("custom-select组件的updated钩子函数被触发") }
  }
};
</script>
```

摘自：[令人眼前一亮的 Vue 实战技巧](https://segmentfault.com/a/1190000040180294)

也可以参考：[Vue2文档 - 深入了解组件 - 处理边界情况 - 程序化的事件侦听器](https://cn.vuejs.org/v2/guide/components-edge-cases.html#:~:text=%E6%B3%A8%E5%85%A5%E7%9A%84%E7%9F%A5%E8%AF%86%E3%80%82-,%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8,-%E7%8E%B0%E5%9C%A8%EF%BC%8C%E4%BD%A0%E5%B7%B2%E7%BB%8F)



#### Vue2：事件修饰符native

native是原生事件。native 一定是用于自定义组件（用在原生组件上会报错）

**代码示例如下：**

```html
<body>
    <div id="app">
        <div class="box" >
            <Son @click='handler1'></Son>
            <Son @click.native='handler1'></Son>
        </div>
    </div>
</body>
<script>
    const Son = Vue.component('Son', {
        template: '<button @mouseover=handler2 class="box1">son</button>',
        methods: { 
          handler2 (e) {} 
        }
    })
    new Vue({
        el: "#app",
        components: { Son },
        data() {
          return { a: 123 }
        },
        methods: {
            handler1 (e) { console.log('父级') }
        }
    })
</script>
```

**注意：**

1. 当 \<Son <font color=FF0000 size=4>**@click**</font>='handler1'>\</Son>，子组件中的this.$listeners返回的是{click: ƒ}，box1的dom上没有绑定click事件（可以打开F12查看），所以这个事件不是原生的click

2. 当 \<Son <font color=FF0000 size=4>**@click.native**</font>='handler1'>\</Son>，子组件中的this.$listeners返回的是{}，box1的dom上绑定了click事件（可以打开F12查看），所以这个事件是原生的click

**为什么有时候组件点击事件不会生效**，猜测如下：

1. <font color=FF0000>子组件html 标签没有定义click原生事件</font>
2. 子组件没有执行this.$emit('click')

摘自：[Vue事件修饰符native和self](https://juejin.cn/post/6844903885916618759)

**补充：在Vue3中 .native 修饰符 已被移除**

**在Vue2中：**<font color=FF0000>默认情况下，传递给带有 v-on 的组件的事件监听器只能通过 this.$emit 触发</font>。要将原生 DOM 监听器添加到子组件的根元素中，可以使用 .native 修饰符：

```html
<my-component
  v-on:close="handleComponentEvent"
  v-on:click.native="handleNativeClickEvent"
/>
```

**在3.x中：**v-on 的 .native 修饰符已被移除。同时，<font color=FF0000>新增的 <font size=4>**emits 选项**</font> 允许子组件定义真正会被触发的事件</font>。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。

```vue
<my-component
  v-on:close="handleComponentEvent"
  v-on:click="handleNativeClickEvent"
/>

<script>
  export default {
    emits: ['close']
  }
</script>
```

摘自：[Vue3 官方文档 - 从Vue2迁移 - 移除v-on.native修饰符](https://v3.cn.vuejs.org/guide/migration/v-on-native-modifier-removed.html#移除-v-on-native-修饰符)

<font size=4>**注意：<font color=FF0000>Vue2的组件中没有 emits options</font>**</font>



#### Vue2：sync修饰符

document 是一个组件，接受一个prop title用于展示；现在要在父组件上修改title：document子组件使用和以往一样，单向数据流，emit触发update:title 事件（ ` this.$emit( 'update:title', 'newVal' ) ` ）。

而在父组件中：

```vue
<!-- 不使用.sync的方法 -->
<document
   :title="title"
   @update:title="title = $event"
/>

<!-- 使用.sync的方法 -->
<document :title.sync="title" />
```

使用了 .sync 相当于将 title 变成了一个双向绑定的 数据，无需父组件通过事件（即上面第一种的写法）来修改。

另外，.sync 修饰符还可以 用于 v-bind.sync，示例：`v-bind.sync="propObj"`

摘自：[使用.sync修饰符【Vue小技巧】](https://www.bilibili.com/video/BV1iL411J76u)



#### Vue2 Vue.extend()

Vue.extend 可以用于创建一个 基于 Vue 构造函数的“子类”，其参数应为一个包含组件选项的对象。示例如下：

```js
// Profile是一个构造器（构造函数）
const Profile = Vue.extend( myComponent )
// 调用Profile构造器，并挂载
new Profile().$mount('#mount-point')
```

在 Vue 3.x 中，已经没有组件构造器的概念了。应该始终使用 createApp 这个全局 API 来挂载组件

```js
const Profile = myComponent
Vue.createApp(Profile).mount('#mount-point')
```

摘自：[Vue3文档 - 用于迁移的构建版本 - Vue extend 移除](https://v3.cn.vuejs.org/guide/migration/global-api.html#vue-extend-移除)

补充内容：[Vue2文档 - API - Vue.extend(options)](https://cn.vuejs.org/v2/api/#Vue-extend-options)、[如何使用Vue.extend来动态创建组件？【Vue】](https://www.bilibili.com/video/BV1D54y1C7ST)

补充：Vue.extend() 是Vue 组件实例化中一个非常重要的方法，就是用于生成组件的构造函数。



#### Vue2 filter

Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。

过滤器可以用在两个地方：**双花括号插值和 `v-bind` 表达式**（后者从 2.1.0+ 开始支持）。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：

```vue
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

**可以<font color=FF0000>在一个组件的选项中定义本地的过滤器</font>：**

```js
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
```

**或者在创建 Vue 实例之前<font color=FF0000>全局定义过滤器</font>：**

```js
Vue.filter('capitalize', function (value) {
  if (!value) return ''
  value = value.toString()
  return value.charAt(0).toUpperCase() + value.slice(1)
})

new Vue({ // ... })
```

当全局过滤器和局部过滤器重名时，会采用局部过滤器。

<font color=FF0000>过滤器函数总接收表达式的值（之前的操作链的结果）作为第一个参数</font>。在上述例子中，`capitalize` 过滤器函数将会收到 `message` 的值作为第一个参数。

**过滤器可以串联：**

```js
{{ message | filterA | filterB }}
```

`filterA` 被定义为接收单个参数的过滤器函数，表达式 `message` 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 `filterB`，将 `filterA`的结果传递到 `filterB` 中。

<font color=FF0000>**过滤器是 JavaScript 函数，因此可以接收参数：**</font>

```js
{{ message | filterA('arg1', arg2) }}
```

这里，<font color=FF0000>`filterA` 被定义为接收三个参数的过滤器函数</font>。<font color=FF0000>其中 `message` 的值作为第一个参数，普通字符串 `'arg1'` 作为第二个参数，表达式 `arg2` 的值作为第三个参数</font>。

摘自：[Vue2文档 - 过滤器](https://cn.vuejs.org/v2/guide/filters.html)

从 Vue 3.0 开始，过滤器已移除，且不再支持。虽然过滤器看起来很方便，但它需要一个自定义语法，打破了大括号内的表达式“只是 JavaScript”的假设，这不仅有学习成本，而且有实现成本。建议用方法调用或计算属性来替换它们

摘自：[Vue3 - 迁移 - 过滤器](https://v3.cn.vuejs.org/guide/migration/filters.html#过滤器)





#### Vue2 Observable





#### Vue2 响应式实现

Vue2 实现响应式的核心API 是` Object.definePropery( obj, prop, descriptor ) `，其中descriptor中除了包含 configurable、enumerable、writable 和 value 之外，还可以使用get 和 set 对 读取和写入操作 进行拦截。

但是 <font color=FF0000>Object.defineProperty 有一个问题：**无法对对象的 属性添加 和 属性删除 作出响应**</font>；这是Vue2 响应式的一大痛点。因此，Vue添加了 Vue.delete() 和 Vue.set() 这两个 API，以对 属性删除 和 属性添加 这两个 操作 进行监听（依赖收集？）

这里学习自：[（完整版）快速掌握Vue2响应式原理【Vue】](https://www.bilibili.com/video/BV1VA411x76D) 具体是在第三集

**关于响应式的补充：**

> 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。<font color=FF0000 size=4>**Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因**</font>。
>
> 有时你可能需要为已有对象赋值多个新 property，比如使用 Object.assign() 或 \_.extend()。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。（即：类似于重新给data option中的数据 赋值（覆盖掉））
>
> ```js
> // 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`
> this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
> ```
>
> **Vue 不能检测以下数组的变动：**
>
> 1. 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue
> 2. 当你修改数组的长度时，例如：vm.items.length = newLength
>
> 举个例子：
>
> ```js
> var vm = new Vue({
>   data: {
>     items: ['a', 'b', 'c']
>   }
> })
> vm.items[1] = 'x' // 不是响应性的
> vm.items.length = 2 // 不是响应性的
> ```
>
> 为了解决第一类问题，以下两种方式都可以实现和 **vm.items[indexOfItem] = newValue** 相同的效果，同时也将在响应式系统内触发状态更新：
>
> ```js
> // Vue.set
> Vue.set(vm.items, indexOfItem, newValue)
> // Array.prototype.splice
> vm.items.splice(indexOfItem, 1, newValue)
> ```
>
> 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：
>
> ```js
> vm.$set(vm.items, indexOfItem, newValue)
> ```
>
> 为了解决第二类问题，你可以使用 splice：
>
> ```js
> vm.items.splice(newLength)
> ```
>
> 摘自：[Vue2 文档 -  深入响应式原理](https://cn.vuejs.org/v2/guide/reactivity.html#如何追踪变化)



#### nextTick的原理

> 本轮事件结束后 vue开始处理收集到的watcher逻辑 这就是一个tick 然后执行你传入的回调。
>
> 摘自：codingstatup微信群 群友



#### 异步更新队列

> <font color=FF0000>Vue 在更新 DOM 时是异步执行的</font>。<font color=FF0000>只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更</font>。<font color=FF0000>如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的</font>。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替
>
> 摘自：[Vue2 文档 -  深入响应式原理 - 异步更新队列](https://cn.vuejs.org/v2/guide/reactivity.html#异步更新队列)



#### key 的 作用

key的作用主要是为了高效的更新虚拟DOM 。<font color=FF0000>另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果</font>

摘自：[vue中使用v-for时为什么不能用index作为key？](https://segmentfault.com/a/1190000019961419)

<font size=4>**还可以用key的改变，作为强制更新**</font>

我们在项目开发时，可能会遇到这样问题：当页面切换到同一个路由但不同参数地址时，比如/detail/1，跳转到/detail/2，页面跳转后数据竟然没更新？路由配置如下：

```js
{ path: "/detail/:id", name:"detail", component: Detail }
```

这是因为 <font color=FF0000>vue-router 会识别出两个路由使用的是同一个组件从而进行复用，并不会重新创建组件，而且组件的生命周期钩子自然也不会被触发，导致跳转后数据没有更新</font>。那我们如何解决这个问题呢？
我们可以为 router-view 组件添加属性 key，例子如下：

```vue
<router-view :key="$route.fullpath"></router-view>
```

<font color=FF0000>这种办法主要是利用虚拟 DOM 在渲染时候通过 key 来对比两个节点是否相同，如果 key 不相同，就会判定 router-view 组件是一个新节点，从而先销毁组件，然后再重新创建新组件，这样组件内的生命周期会重新触发。</font>

摘自：[令人眼前一亮的 Vue 实战技巧](https://segmentfault.com/a/1190000040180294)

类似的，也有 el-cascader 懒加载数据回显的问题（一般是编辑），通过 手动修改 key绑定的值来进行让数据重新展示（应该是销毁了数据？）。参考了：[vue框架下 element 动态加载级联选择器主动清空内容_aj951225的博客-程序员ITS301](https://www.its301.com/article/aj951225/106857977)



#### Diff算法

**diff算法原理：**

**patch函数：比较 老的虚拟DOM 和 新的虚拟DOM**

- <font color=FF0000 size=4>**只比较同一层级，不进行跨级比较**</font>
- 比较 标签名 tagName，标签名不同，直接删除整个子树；不继续深度比较
- 标签名相同，则再比较key
- 如果key相同，则认为是相同的节点，不继续深度比较

**patchVnode 分为如下情况：**

- 老的Vnode 有 children，新的Vnode也有 children
  - 这也就是updateChidren 方法
- 老的Vnode 有text，新的Vnode有 children
- 老的Vnode 有 children，新的Vnode 有 text
- 老的Vnode 有 text，新的Vnode也有 text

**updateChidren方法 用四个指针进行比较，判断是否为同一个节点；这分为四种情况**

- 老的Vnode的开始指针 和 新的Vnode的开始指针 进行比较
- 老的Vnode的结束指针 和 新的Vnode的结束指针 进行比较
- 老的Vnode的开始指针 和 新的Vnode的结束指针 进行比较
- 老的Vnode的结束指针 和 新的Vnode的开始指针 进行比较

学习自：[（完整版）快速掌握虚拟DOM和diff算法【Vue】](https://www.bilibili.com/video/BV1dV411a7mT)

**补充：其他的讲解**

<font color=FF0000>响应式数据更新</font>后，<font color=FF0000>触发了 渲染 Watcher 的回调函数 vm.\_update( vm.\_render() ) 去驱动视图更新</font>，<font color=FF0000>vm.\_render() 其实生成的就是 vnode</font>，而 vm.\_update 就会带着新的 vnode 去走触发 \__patch__ 过程。

**patch 函数**

对比新旧节点是否是相同类型的节点

1. **不是相同节点（TagName 或 key 不相同）：**

   isSameNode为false的话，<font color=FF0000>直接销毁旧的 vnode</font>，渲染新的 vnode。这也解释了为什么 diff 是同层对比。

2. **是相同节点，要尽可能的做节点的复用：**<font color=FF0000>调用 src/core/vdom/patch.js 下的 patchVNode 方法</font>

   - **如果新 vnode 是文字 vnode：**直接调用浏览器的 dom api 把节点的直接替换掉文字内容就好。

   - **如果新 vnode 不是文字 vnode：**开始对子节点 children 进行对比了。

   - **如果有新 children 而没有旧 children：**说明是新增 children，直接 **`addVnodes`** 添加新子节点。

   - **如果有旧 children 而没有新 children：**说明是删除 children，直接 **`removeVnodes`** 删除旧子节点

   - **如果新旧 children 都存在：**则开始 <font color=FF0000>新旧节点的 diff 过程</font>，通过<font color=FF0000 size=4> **`updateChildren`** 函数</font> 实现（源码在下面）

     创建 新老Vnode 的首尾指针 oldStartIdx、newStartIdx、oldEndIdx、newEndIdx。

     根据这些指针，在一个 <font color=FF0000>while 循环中不停的对新旧节点的两端的进行对比</font>（通过sameVnode函数进行对比），然后<font color=FF0000>把两端的指针向不断内部收缩，直到没有节点可以对比</font>。

     ```js
     // sameVnode 实现，其中key的比较是最先的，有最高优先级
     function sameVnode (a, b) {
       return (
         a.key === b.key && (
           (
             a.tag === b.tag &&
             a.isComment === b.isComment &&
             isDef(a.data) === isDef(b.data) &&
             sameInputType(a, b)
           )
         )
       )
     }
     ```

     然后接着进入 `diff` 过程，每一轮都是同样的对比，其中某一项命中了（比如 旧首节点和新首节点 `sameNode`为true，则立即 对于当前节点 进行 `patchVNode` 函数操作，因为 `updateChildren` 本身就在 `patchVNode` 中运行，所以这里就是递归 ），就递归的进入 `patchVnode` 针对单个 `vnode` 进行的过程（如果这个 `vnode` 又有 `children`，那么还会来到这个 `diff children` 的过程 ）：

     1. 旧首节点和新首节点用 `sameNode` 对比。
     2. 旧尾节点和新尾节点用 `sameNode` 对比
     3. 旧首节点和新尾节点用 `sameNode` 对比
     4. 旧尾节点和新首节点用 `sameNode` 对比
     5. <font color=FF0000>如果以上逻辑都匹配不到，再把所有旧子节点的 `key` 做一个映射到旧节点下标的 `key -> index` 表</font>，然后用新 `vnode` 的 `key` 去找出在旧节点中可以复用的位置。

     <font color=FF0000>**然后不停的把匹配到的指针向内部收缩，直到新旧节点有一端的指针相遇**</font>（<font color=FF0000>说明这个端的节点都被patch过了</font>）。

     **在指针相遇以后，还有两种比较特殊的情况：**

     1. **有新节点需要加入：** <font color=FF0000>如果更新完以后，`oldStartIdx > oldEndIdx` ，说明 <font size=4>**旧节点**</font>都被 `patch` 完了，但是有可能还有新的节点没有被处理到</font>。接着会去 <font color=FF0000>判断是否要 <font size=4>**新增子节点**</font></font>。
     2. **有旧节点需要删除：** <font color=FF0000>如果新节点先patch完了，那么此时会走 `newStartIdx > newEndIdx` 的逻辑，那么就会去 <font size=4>**删除多余的旧子节点**</font></font>。

     所以：退出循环的条件为 **老Vnode首指针和尾指针相遇** <font color=FF0000 size=4>**且**</font> **新Vnode首指针和尾指针相遇**

```js
/* 源码地址：https://github.com/vuejs/vue/blob/bd6cea0973247e2a8e1d4a2250614c0bf44f0b26/src/core/vdom/patch.js#L404-L474 */
function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
  let oldStartIdx = 0 // 老Vnode 首指针索引
  let newStartIdx = 0 // 新Vnode 首指针索引
  let oldEndIdx = oldCh.length - 1 // 老Vnode 尾指针索引
  let oldStartVnode = oldCh[0]
  let oldEndVnode = oldCh[oldEndIdx]
  let newEndIdx = newCh.length - 1 // 新Vnode 尾指针索引
  let newStartVnode = newCh[0]
  let newEndVnode = newCh[newEndIdx]
  let oldKeyToIdx, idxInOld, vnodeToMove, refElm

  // removeOnly is a special flag used only by <transition-group>
  // to ensure removed elements stay in correct relative positions
  // during leaving transitions
  const canMove = !removeOnly

  if (process.env.NODE_ENV !== 'production') {
    checkDuplicateKeys(newCh)
  }

  // 循环执行 sameVnode函数 进行比较。退出条件为 老Vnode首指针和尾指针相遇 **且** 新Vnode首指针和尾指针相遇
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (isUndef(oldStartVnode)) {
      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
    } else if (isUndef(oldEndVnode)) {
      oldEndVnode = oldCh[--oldEndIdx]
    } 
    // 老Vnode 和 新Vnode 首指针对比，命中则调用patchVNode，这里相当于递归。
    // 退出子VNode的patchVNode之后，老Vnode 和 新Vnode 开始指针分别++
    else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
    } 
    // 老Vnode 和 新Vnode 尾指针对比。命中后的操作类似
    else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
    } 
    // 老Vnode首指针 和 新Vnode 尾指针对比。命中后的操作类似
    else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
    }
    // 老Vnode尾指针 和 新Vnode 首指针对比。命中后的操作类似
    else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    }
    // 都无法匹配
    else {
      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
      idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]
        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
      if (isUndef(idxInOld)) { // New element
        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
      } else {
        vnodeToMove = oldCh[idxInOld]
        if (sameVnode(vnodeToMove, newStartVnode)) {
          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
          oldCh[idxInOld] = undefined
          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
        } else {
          // same key but different element. treat as new element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        }
      }
      newStartVnode = newCh[++newStartIdx]
    }
  }
  if (oldStartIdx > oldEndIdx) {
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx)
  }
}
```

不建议使用 <font color=FF0000>index</font>（不仅仅是性能损耗，严重的 甚至会造成bug；即使是静态的列表，也要考虑到团队代码规范等等，所以也不建议使用index） 或者 <font color=FF0000>随机数</font>（导致key不幂等，key完全失效；导致组件销毁和重建） 作为key的原因，以及分别会造成什么问题；这篇文章中也有提到。

摘自：[为什么 Vue 中不要用 index 作为 key？（diff 算法详解）](https://juejin.cn/post/6844904113587634184)

补充：由看[vue中key的作用和工作原理](https://juejin.cn/post/6907456768222330893) 所引发的思考

```
oldVnode: W L O M
newVnode: W L C O M

// 首次循环patch A，进行oldVnode和newVnode首指针比较，命中
W L O M
W L C O M

//第2次循环patch B，进行oldVnode和newVnode首指针比较，命中
L O M
L C O M

//第3次循环patch M，进行oldVnode和newVnode首指针比较，未命中；，进行oldVnode和newVnode尾指针比较，命中
O M
C O M

//第4次循环patch O，进行oldVnode和newVnode首指针比较，未命中；，进行oldVnode和newVnode尾指针比较，命中
O 
C O 

//oldCh全部处理结束，newCh中剩下的C，创建C并插入到O前面
// 共进行了4次的patch，和一次的追加新dom的操作
```



#### Vue中 响应式实现 Object.defineProperty 和 Proxy的区别

- **Object.defineProperty <font color=FF0000 size=4>只能劫持对象的属性</font>，而 Proxy 是 <font color=FF0000 size=4>直接代理对象</font>**

  由于 <font color=FF0000>Object.defineProperty 只能对属性进行劫持，<font size=4>**需要遍历对象的每个属性**</font>，**如果属性值也是对象，则 <font size=4>需要深度遍历</font>**</font>。而 <font color=FF0000>Proxy 直接代理对象，不需要遍历操作</font>

- **Object.defineProperty 对新增属性需要手动进行 Observe**

  <font color=FF0000>由于 Object.defineProperty 劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用 Object.defineProperty 进行劫持</font>。也正是因为这个原因，使用 Vue 给 data 中的数组或对象新增属性时，需要使用 vm.$set 才能保证新增的属性也是响应式的。

  如果<font color=FF0000>采用 proxy 实现，Proxy 通过 **set(target, propKey, value, receiver)** 拦截对象属性的设置，是可以拦截到对象的新增属性的</font>

- **Proxy支持 13 种拦截操作，这是 defineProperty 所不具有的。**

  这里拦截操作列表 略

- **新标准性能红利：**Proxy 作为新标准，从长远来看，JS 引擎会继续优化 Proxy，但 getter 和 setter 基本不会再有针对性优化

- **Proxy 兼容性差：**并且目前并没有一个完整支持 Proxy 所有拦截方法的 Polyfill 方案

摘自：[Vue Object.defindPropety 和Proxy区别](https://juejin.cn/post/6844904009812148237)



#### camel修饰符

将 kebab-case attribute 名转换为 camelCase

```vue
<!-- 不加camel viewBox会被识别成viewbox -->
<svg :viewBox="viewBox"></svg>

<!-- 加了canmel viewBox才会被识别成viewBox -->
<svg :viewBox.camel="viewBox"></svg>
```

摘自：[「百毒不侵」面试官最喜欢问的13种Vue修饰符](https://juejin.cn/post/6981628129089421326)



#### 计算属性和函数的区别

> 我们可以将同一函数定义为一个方法而不是一个计算属性。<mark>（计算属性和函数）两种方式的最终结果确实是完全相同的</mark>。然而，<font color=FF0000> 不同的是计算属性是基于它们的 <font size=5>**响应依赖关系 缓存 **</font>的</font>。<font color=FF0000> 计算属性只在相关响应式依赖发生改变时它们才会重新求值</font>。<font color=FF0000> 这就意味着只要 author.books 还没有发生改变</font>，多次访问 publishedBookMessage 计算属性会立即返回之前的计算结果，<font color=FF0000> 而不必再次执行函数</font>。
>
> <font color=FF0000> 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数</font>
>
> <mark>我们为什么需要缓存？</mark>假设我们有一个性能开销比较大的计算属性 list，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 list。<mark>如果没有缓存，我们将不可避免的多次执行 list 的 getter！</mark>如果你不希望有缓存，请用 method 来替代

摘自：[Vue3官方文档 - 计算属性和侦听器 - 计算属性缓存 vs 方法](https://v3.cn.vuejs.org/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95)

#### 计算属性和监听器的区别

> 当需要在<font color=FF0000> 数据变化时<font size=4>**执行异步或开销较大的操作**</font>时</font>，（监听器）这个方式是最有用的。
>
> 使用 <font color=FF0000> watch 选项允许我们执行<font size=4>**异步操作**</font> (访问一个 API)，限制我们执行该操作的频率</font>，<font color=FF0000> 并在我们得到最终结果前，设置中间状态</font>。这些都是计算属性无法做到的
>
> Vue 提供了一种更通用的方式来观察和响应当前活动的实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch；然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调

摘自：[Vue3官方文档 - 计算属性和侦听器 - 计算属性 vs 侦听器](https://v3.cn.vuejs.org/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-vs-%E4%BE%A6%E5%90%AC%E5%99%A8)



#### v-if和v-show的区别

> v-if 支持 \<template>，而 v-show 不支持
>
> <font color=FF0000> v-if 是“真正”的条件渲染</font>，因为它会确保<font color=FF0000> 在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建</font>。
>
> <font color=FF0000> v-if 也是**惰性**的</font>：<mark>如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块</mark>。
>
> 相比之下，v-show 就简单得多——<font color=FF0000> 不管初始条件是什么，元素总是会被渲染（**非惰性？**）</font>，<font color=FF0000> 并且只是简单地基于 CSS 进行切换</font>。
>
> 一般来说，<font color=FF0000 size=4> v-if 有更高的**切换开销**，而 v-show 有更高的**初始渲染开销**</font>。因此，如果需要非常频繁地切换，则使用 v-show 较好；<font color=FF0000> **如果在运行时条件很少改变，则使用 v-if 较好**</font>

摘自：[Vue3官方文档 -  条件渲染 - v-if vs v-show](https://v3.cn.vuejs.org/guide/conditional.html#v-if-vs-v-show)



#### 为什么不推荐同时使用 v-if 和 v-for

> 当它们处于同一节点，v-if 的优先级比 v-for 更高，这<font color=FF0000>意味着 v-if 将没有权限访问 v-for 里的变量</font>

摘自：[Vue3官方文档 -  列表渲染 - v-for 与 v-if 一同使用](https://v3.cn.vuejs.org/guide/list.html#v-for-%E4%B8%8E-v-if-%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8)

对于后面一句，可以参考：[Vue3 风格指南 - 避免 v-if 和 v-for 一起使用](https://v3.cn.vuejs.org/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%BF%85%E8%A6%81)中的解释和示例

另外，根据[Vue3文档 - 迁移 - 模版指令](https://v3.cn.vuejs.org/guide/migration/introduction.html#模板指令) 可知：在同一元素上使用的 v-if 和 v-for 优先级已更改，Vue2是v-for 更高，Vue3是v-if 更高



#### 事件修饰符的作用

- **.stop：**和Event.stopPropagation() 作用一样，阻止单击事件继续传播
- **.prevent：**和Event.preventDefault() 作用一样，提交事件不再重载页面。比如submit事件触发后默认重载页面，而加上后则不会再重载
- **.capture：**<font color=FF0000> 添加事件监听器时使用事件捕获模式</font>，即内部元素触发的事件先在此处理，然后才交由内部元素进行处理
- **.self：**<font color=FF0000> 只当在 event.target 是当前元素自身时触发处理函数</font>
- **.once：**事件只会触发一次
- **.passive：**Vue为 [EventTarget.addEventListener](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener)中的passive选项添加了passive修饰符。<font color=FF0000> 事件的默认行为将会<font size=4>**立即触发**</font>，而不会等待绑定的事件完成</font>。
  - 不要把 .passive 和 .prevent 一起使用，因为<font color=FF0000> **.prevent 将会被忽略** </font>，同时浏览器可能会向你展示一个警告。（即：.prevent的优先级没有.passive高）

<font size=4>**补充：**</font>修饰符可以串联。但是：<font color=FF0000> 使用顺序很重要</font>；相应的代码会以同样的顺序产生

摘自：[Vue3官方文档 -  事件处理 - 事件修饰符](https://v3.cn.vuejs.org/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6)

**补充：**

| 修饰符                              | 处理函数中的等价操作                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| .stop                               | event.stopPropagation()                                      |
| .prevent                            | event.preventDefault()                                       |
| .self                               | if (event.target !== event.currentTarget) return             |
| 按键： .enter, .13                  | if (event.keyCode !== 13) return (对于别的按键修饰符来说，可将 13 改为另一个按键码 |
| 修饰键： .ctrl, .alt, .shift, .meta | if (!event.ctrlKey) return (将 ctrlKey 分别修改为 altKey, shiftKey, 或 metaKey) |

摘自：[Vue3官方文档 - 渲染函数 - 事件修饰符](https://v3.cn.vuejs.org/guide/render-function.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6)

补充：

![截屏2021-07-11 下午9.56.53.png](https://i.loli.net/2021/11/30/hvXU7f1CHqPNy3t.png)



#### v-model语法糖

```html
<input v-model="searchText" />
```

等价于：

```html
<input :value="searchText" @input="searchText = $event.target.value" />
```

当用在组件上时，v-model 则会这样：

```html
<custom-input
  :model-value="searchText"
  @update:model-value="searchText = $event"
></custom-input>
```

写成代码之后是这样的：

```js
app.component('custom-input', {
  props: ['modelValue'],
  emits: ['update:modelValue'],
  template: `
    <input
      :value="modelValue"
      @input="$emit('update:modelValue', $event.target.value)"
    >
  `
})
```

现在 v-model 就可以在这个组件上完美地工作起来了：

```html
<custom-input v-model="searchText"></custom-input>
```

摘自：[Vue3官方文档 - 组件基础](https://v3.cn.vuejs.org/guide/component-basics.html#在组件上使用-v-model)



#### prop 类型检查的原理

props 下的 prop中的 type 对应的 是 类型的构造函数，所以首字母大写。另外，在自定义对象（自定义构造函数）会通过 instanceof 来检查确认。或许原生类型可以通过js自带的方法进行检测，但是原理上也是可以通过instanceof 来进行检测。



#### v-slot 的使用

一般状况下，v-slot 只能被用在 \<template> 上。当然也有特殊情况：<font color=FF0000>当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用</font>；即：独占插槽。



#### provide / inject 使用注意点

如果需要在provide 组件实例中的property，或者property相关的内容（比如 有property是数组，需要provde该数组的长度），需要使用return一个对象（类似于data函数，也需要返回一个对象），防止改数据被多子组件实例篡改，造成数据混乱。



#### \<transition>

- **CSS过渡**：**在进入/离开的过渡中，会有 6 个 class 切换。**

1. **v-enter-from：**定义<mark>**进入( enter ) **</mark>过渡的 <mark>**开始( from )**</mark> 状态。在<font color=FF0000>元素被插入之前生效，在元素被插入之后的下一帧移除</font>。

1. **v-enter-active：**定义 <mark>**进入( center )**</mark>  过渡 <mark>**生效( active )**</mark>  时的状态。<font color=FF0000>在整个进入过渡的阶段中应用，**在元素被插入之前生效，在过渡/动画完成之后移除**</font>。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。
2. **v-enter-to：**定义 <mark>**进入( center )**</mark> 过渡的 <mark>**结束 ( to ) 状态**</mark>。<font color=FF0000>在元素被插入之后下一帧生效 (与此同时 v-enter-from被移除)，在过渡/动画完成之后移除</font>。
3. **v-leave-from：**定义 <mark>**离开( leave )**</mark> 过渡的 <mark>**开始( from )**</mark> 状态。<font color=FF0000>在离开过渡被触发时立刻生效，下一帧被移除</font>。
4. **v-leave-active：**定义 <mark>**离开( leave )**</mark> 过渡 <mark>**生效( active )**</mark> 时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。
5. **v-leave-to：**<mark>**离开( leave )**</mark> 过渡的 <mark>**结束( to )**</mark> 状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from被移除)，在过渡/动画完成之后移除。

<font color=FF0000 size=4>**辅助记忆：** </font>**enter -> leave** ；**from -> active -> to**；另外，注意下图中active的范围。

![](https://v3.cn.vuejs.org/images/transitions.svg)



#### watch和watchEffect的区别

- **watch**
  - 具备一定的惰性 lazy（数据不改变则不会执行）
    - 如果想要让watch变成immediate，只需要在watch函数之后加上配置：`{ immediate: true }`
  - 参数可以拿到原始和当前值
  - 可以侦听多个数据的变化，用一个侦听器承载
- **watchEffect**
  - 立即执行，没有惰性 immediate
  - <font color=FF0000> 不需要传递你要侦听的内容，**自动会感知代码依赖**</font>，不需要传递很多参数，只要传递一个回掉函数
  - 不能获取之前数据的值

摘自：[ imooc - Vue3 系统入门与项目实战 - 6-9 / 6-10](https://coding.imooc.com/class/chapter/472.html)



#### setup

- **props**

  setup函数中的 props参数 是响应式的，也因此不能使用ES6的解构，这样会使得prop的响应式；如果需要使用解构，可以使用 toRefs()  将props 解构为 响应式的 prop

- **context**

  setup函数中的context参数包含：attrs、slots、emits、expose。同时，context不是响应式的，所以可以放心的使用ES6解构。

  另外：attrs 和 slots 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 attrs.x 或 slots.x 的方式引用 property。但是：与 props 不同，attrs 和 slots 的 property 是非响应式的。如果打算根据 attrs 或 slots 的更改应用副作用，那么应该在 onBeforeUpdate 生命周期钩子中执行此操

- **为什么在setup不使用this**

  > 在 setup() 内部，this 不是该活跃实例的引用，因为 <font color=FF0000>setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同</font>。<mark>这使得 setup() 在和其它选项式 API 一起使用时可能会导致混淆</mark>。



#### reactive

reactive 相当于 Vue 2.x 中的 Vue.observable() API，为避免与 RxJS 中的 observables 混淆因此对其重命名。该 API 返回一个响应式的对象状态。<font color=FF0000>该响应式转换是“深度转换”——它会影响传递对象的所有嵌套 property</font>。



#### computed 函数

computed 函数，它如果只给它设置了一个getter，它将<font color=FF0000>接受 getter 函数并为 getter 返回的值 <font size=4> **返回一个不可变的响应式 ref 对象** </font></font>。如果也设置了setter，则返回一个可变的ref 对象。



#### Mixin

mixin引入的 数据 ( data ) 和当前组件的数据 出现冲突时，调用的规则是“就近原则”，即：

> 在数据的 property 发生冲突时，会以组件自身的数据为优先

另外

> 同名钩子函数将合并为一个数组，因此都将被调用。另外，<font color=FF0000>mixin 对象的钩子将在组件自身钩子之前调用</font>。

同时：

> 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。



#### 函数式组件

> 函数式组件是自身没有任何状态的组件的另一种形式。它们<font color=FF0000>在渲染过程中不会创建组件实例，并跳过常规的组件生命周期</font>。
>
> 我们<font color=FF0000>使用的是一个简单函数，而不是一个选项对象，来创建函数式组件</font>。该函数实际上就是该组件的 render 函数。而因为函数式组件里没有 this 引用，Vue 会把 props 当作第一个参数传入：
>
> ```js
> const FunctionalComponent = (props, context) => {
>   // ...
> }
> ```
>
> 第二个参数 context 包含三个 property：attrs、emit 和 slots。它们分别相当于实例的 \$attrs、\$emit 和 \$slots 这几个 property。
>
> 大多数常规组件的配置选项在函数式组件中都不可用。然而我们还是可以把 props 和 emits 作为 property 加入，以达到定义它们的目的：
>
> ```js
> FunctionalComponent.props = ['value']
> FunctionalComponent.emits = ['click']
> ```



#### 为什么需要虚拟DOM

我们用 JavaScript 生成名为 Virtual Dom 的 DOM 副本，这样做的原因是用 JavaScript 直接操作 DOM 的计算成本很高。虽然用 JavaScript 执行更新很快，但是<font color=FF0000> 找到所需的 DOM 节点并用 JavaScript 更新它们的成本却很高</font>。<font color=FF0000> 所以我们批量处理调用，并一次性更改 DOM</font>。

<font color=FF0000> 如果需要更新列表项，我们可以借助前面提到的响应性在 JavaScript 中进行。我们将更改应用至 JavaScript 副本、虚拟 DOM 中，然后在它们和实际 DOM 之间执行 diff</font>。只有这样，我们才能对已更改的内容进行更新。虚拟 DOM 允许我们对 UI 进行高效的更新！

**虚拟DOM的介绍：**

虚拟 DOM 是轻量级的 JavaScript 对象，<font color=FF0000> 由渲染函数创建</font>。<font color=FF0000 size=4> 它**包含三个参数：元素，具有数据、prop、attr 等的对象，以及一个数组**</font>。<font color=FF0000> 数组是我们传递子级的地方，子级也具有所有这些参数</font>，然后它们也可以具有子级，依此类推，直到我们构建完整的元素树为止。

摘自：[Vue3官方文档 -  渲染机制和优化 - 虚拟DOM](https://v3.cn.vuejs.org/guide/optimizations.html#%E8%99%9A%E6%8B%9F-dom)

Vue 在更新 DOM 时是异步执行的。<font color=FF0000>只要侦听到数据变化，<font size=4>**Vue 将开启一个队列**</font>，并缓冲在同一事件循环中发生的所有数据变更</font>。<font color=FF0000>如果同一个侦听器被多次触发，它<font size=4>**只会被推入到队列中一次**</font></font>。



#### render函数

> render 函数中的 h函数返回一个虚拟节点( VNode )
>
> 摘自：https://v3.cn.vuejs.org/api/global-api.html#h

> render 函数的优先级高于根据 template 选项或挂载元素的 DOM 内 HTML 模板编译的渲染函数。
>
> 摘自：https://v3.cn.vuejs.org/api/options-dom.html#render



#### $nextTick

$nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2017 async/await 语法完成相同的事情：

```js
  methods: {
    updateMessage: async function () {
      this.message = 'updated'
      console.log(this.$el.textContent) // => 'not updated'
      await this.$nextTick()
      console.log(this.$el.textContent) // => 'updated'
    }
  }
```

摘自：[Vue3文档 -  Vue 2 中更改检测的注意事项 - 异步更新队列](https://v3.cn.vuejs.org/guide/change-detection.html#异步更新队列)



#### Vue SFC

Vue SFC 是框架指定的文件格式，必须由 [@vue/compiler-sfc](https://github.com/vuejs/vue-next/tree/master/packages/compiler-sfc) 预编译为标准的 JavaScript 与 CSS。编译后的 SFC 是一个标准的 JavaScript（ES）模块



#### 各生命周期的作用

![](https://v3.cn.vuejs.org/images/lifecycle.svg)

**必经的生命周期**

- **beforeCreate：**<font color=FF0000 size=4> **在实例初始化之后** </font>、<font color=FF0000>**进行 数据侦听和事件 / 侦听器的配置之前  同步调用** </font>。

- **created：**<font color=FF0000 size=4> **在实例创建完成后被立即同步调用** </font>。在这一步中，<font color=FF0000> 实例已完成对选项的处理</font>，<font color=FF0000> 意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数</font>。然而，<font color=FF0000> 挂载阶段还没开始，且 `$el` property 目前尚不可用</font>。

- **beforeMount：**<font color=FF0000 size=4> **在挂载开始之前被调用** </font>：<mark style=background-color:hotpink>相关的 render 函数首次被调用</mark>。

  <mark>**该钩子在服务器端渲染期间不被调用。**</mark>

- **mounted：**<font color=FF0000 size=4> **在实例挂载完成后被调用**，这时候传递给 app.mount 的元素已经被新创建的 vm.\$el 替换了</font>。如果根实例被挂载到了一个文档内的元素上，当 mounted 被调用时， vm.\$el 也会在文档内。 注意<font color=FF0000 size=4> **mounted 不会保证所有的子组件也都被挂载完成**</font>（言外之意，仅仅是当前组件已经挂载成功了）。<font color=FF0000> 如果你希望等待整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick：</font>

  ```js
  mounted() {
    this.$nextTick(function () {
      // 仅在整个视图都被渲染之后才会运行的代码
    })
  }
  ```

  <mark>**该钩子在服务器端渲染期间不被调用。**</mark>

- **beforeUpdate：**<font color=FF0000 size=4> **在数据发生改变后，DOM 被更新之前被调用** </font>。这里<mark style=background-color:aqua>适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器</mark>。

  **<mark>该钩子在服务器端渲染期间不被调用</mark>，<font color=FF0000>因为只有初次渲染会在服务器端进行。</font>**

- **updated：**<font color=FF0000 size=4> **在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用** </font>。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。<mark style=background-color:aqua>如果要相应状态改变，通常最好使用计算属性或侦听器取而代之</mark>。

  注意，<font color=FF0000>（和上面的mounted 一样） **updated 不会保证所有的子组件也都被重新渲染完毕**</font>。<font color=FF0000> 如果你希望等待整个视图都渲染完毕，可以在 updated 内部使用 vm.$nextTick</font>：

  ```js
  updated() {
    this.$nextTick(function () {
      // 仅在整个视图都被重新渲染完毕之后才会运行的代码
    })
  }
  ```

- **beforeUnmount：**<font color=FF0000 size=4> **在卸载组件实例之前调用** </font>。<mark style=background-color:aqua>在这个阶段，实例仍然是完全正常的</mark>。

  <mark>**该钩子在服务器端渲染期间不被调用。**</mark>

- **unmounted：**<font color=FF0000 size=4> **卸载组件实例后调用** </font>。调用此钩子时，<font color=FF0000> 组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载</font>。

  <mark>**该钩子在服务器端渲染期间不被调用。**</mark>

**其他的生命周期**

- **actived：**<font color=FF0000> 被 keep-alive 缓存的组件激活时调用</font>。

  **该钩子在服务器端渲染期间不被调用。**

- **deactived：**<font color=FF0000> 被 keep-alive 缓存的组件失活时调用</font>。

  **该钩子在服务器端渲染期间不被调用。**

- **errorCaptured：**在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。

  **类型：**

  ```ts
  (err: Error, instance: Component, info: string) => ?boolean
  ```

- **renderTracked：**<font color=FF0000> 跟踪虚拟 DOM 重新渲染时调用</font>。钩子接收 debugger event 作为参数。<font color=FF0000> 此事件告诉你哪个操作**跟踪**了组件，以及该操作的目标对象和键</font>。

  **类型：**

  ```ts
  (e: DebuggerEvent) => void
  ```

- **renderTriggered：**<font color=FF0000> 当虚拟 DOM 重新渲染被触发时调用</font>。和 renderTracked 类似，接收 debugger event 作为参数。<font color=FF0000> 此事件告诉你是什么操作**触发**了重新渲染，以及该操作的目标对象和键</font>。

  **类型：**

  ```ts
  (e: DebuggerEvent) => void
  ```

摘自：[Vue3官方文档 - 生命周期钩子](https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html)

**补充**

**选项式 API 的生命周期选项和组合式 API 之间的映射：**

- ~~beforeCreate~~ -> <font color=FF0000> 使用 setup()</font>
- ~~created~~ -> <font color=FF0000> 使用 setup()</font>

- beforeMount -> onBeforeMount

- mounted -> onMounted

- beforeUpdate -> onBeforeUpdate

- updated -> onUpdated

- beforeUnmount -> onBeforeUnmount

- unmounted -> onUnmounted

- errorCaptured -> onErrorCaptured

- renderTracked -> onRenderTracked

- renderTriggered -> onRenderTriggered

- activated -> onActivated

- deactivated -> onDeactivated

摘自：[Vue3官方文档 - 组合式 API - 生命周期钩子](https://v3.cn.vuejs.org/api/composition-api.html#生命周期钩子)



#### watch和watchEffect的相同与区别

**watch 与 watchEffect 相同的行为**

watch 与 watchEffect 在手动停止侦听、清除副作用 (将 onInvalidate 作为第三个参数传递给回调)、刷新时机和调试方面有相同的行为。

**与 watchEffect 相比，watch 允许我们：**

- 惰性地执行副作用；
- 更具体地说明应触发侦听器重新运行的状态；
- 访问被侦听状态的先前值和当前值。

摘自：https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#watch



#### watch的使用

- 如果侦听的是 <font color=FF0000>单个数据源</font>，侦听器数据源可以是 <font color=FF0000>返回值的 getter 函数</font>，也可以<font color=FF0000>直接是 ref</font>

  ```js
  // 侦听一个 getter
  const state = reactive({ count: 0 })
  watch(
    () => state.count,
    (count, prevCount) => {
      /* ... */
    }
  )
  
  // 直接侦听ref
  const count = ref(0)
  watch(count, (count, prevCount) => {
    /* ... */
  })
  ```

- 如果侦听的是 <font color=FF0000>多个数据源</font>，侦听器还可以<font color=FF0000>使用数组同时侦听多个源</font>：

  ```js
  const firstName = ref('')
  const lastName = ref('')
  
  watch([firstName, lastName], (newValues, prevValues) => {
    console.log(newValues, prevValues)
  })
  
  firstName.value = 'John' // logs: ["John", ""] ["", ""]
  lastName.value = 'Smith' // logs: ["John", "Smith"] ["John", ""]
  ```

  尽管如此，如果你在同一个函数里同时改变这些被侦听的来源，侦听器仍只会执行一次。原因是watch是一个微任务，同步代码优先执行，所以一次同步事件队列，只会侦听一次。

- 使用侦听器来比较一个数组或对象的值，这些值是响应式的，要求它有一个由值构成的副本。

  ```js
  const numbers = reactive([1, 2, 3, 4])
  
  watch(
    () => [...numbers],
    (numbers, prevNumbers) => { console.log(numbers, prevNumbers) }
  )
  
  numbers.push(5) // logs: [1,2,3,4,5] [1,2,3,4]
  ```

  尝试检查深度嵌套对象或数组中的 property 变化时，仍然需要 deep 选项设置为 true

更多的示例 可以参考官方文档中的：https://v3.cn.vuejs.org/api/options-data.html#watch

```js
const app = createApp({
  data() {
    return {
      a: 1,
      b: 2,
      c: {
        d: 4
      },
      e: 5,
      f: 6
    }
  },
  watch: {
    // 侦听顶级 property
    a(val, oldVal) {
      console.log(`new: ${val}, old: ${oldVal}`)
    },
    // 字符串方法名。这里的someMethods定义在 methods中
    b: 'someMethod',
    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深
    c: {
      handler(val, oldVal) {
        console.log('c changed')
      },
      deep: true
    },
    // 侦听单个嵌套 property
    'c.d': function (val, oldVal) {
      // do something
    },
    // 该回调将会在侦听开始之后被立即调用
    e: {
      handler(val, oldVal) {
        console.log('e changed')
      },
      immediate: true
    },
    // 你可以传入回调数组，它们会被逐一调用
    f: [
      'handle1',
      function handle2(val, oldVal) {
        console.log('handle2 triggered')
      },
      {
        handler: function handle3(val, oldVal) {
          console.log('handle3 triggered')
        }
        /* ... */
      }
    ]
  },
  methods: {
    someMethod() {
      console.log('b changed')
    },
    handle1() {
      console.log('handle 1 triggered')
    }
  }
})

const vm = app.mount('#app')

vm.a = 3 // => new: 3, old: 1
```



在 Vue3 中的 main.js 文件中：

```js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'

createApp.use(router).use(store).mounted('#app')
```

而在 Vue2 中是 `import vue from 'vue'` ，这样写用了解构赋值的方法，不需要将 vue 完全引入项目，便于进行 tree shaking，减小项目的体积。



#### Vue3 中reactive 和 ref 的区别 以及 ref 为什么要用 .value 取值

区别

- reactive API对**传入的类型是有限制的**，它要求我们必须传入的是**一个对象或者数组类型**（如果传入一个基本数据类型(String、Number、Boolean）会报一个警告
- ref 可以被用于 基本数据类型

因为Vue3 使用 Proxy 实现响应式，而 Proxy只能代理引用类型；所以，ref 使用 refImpl 对象对 ref 包装的变量进行了包装。

学习自：codingstartup交流群 群友



## Vue Router

#### router-link

**为什么使用router-link而不使用\<a> ？**

请注意，我们没有使用常规的 a 标签，而是使用一个自定义组件 router-link 来创建链接。<font color=FF0000> 这使得 Vue Router 可以在**不重新加载页面的情况下更改 URL，处理 URL 的生成以及编码** </font>。

摘自：[Vue Router 4官方文档 - 入门 - router-view](https://next.router.vuejs.org/zh/guide/#:~:text=router-view-,%23,-router-view%20%E5%B0%86)

另外，router-link 还可以实现一些Vue router自定义的功能，这是 \<a> 所做不到的。

> - 当（router-link）被点击后，内部会立刻把 `to` 的值传到 `router.push()`，所以这个值可以是一个 地址字符串 或者是 [描述目标位置的对象](https://next.router.vuejs.org/zh/api/#routelocationraw) （<font color=FF0000>即：router.push() 中可以使用的对象，及对象中设定的参数（path、params、query），均可以使用</font> ）。（这里示例略，详见下面引用链接）
>
> - **replace属性：**<font color=FF0000>设置 `replace` 属性的话，当点击时，会调用 `router.replace()`</font>，而不是 `router.push()`，所以<font color=FF0000>导航后不会留下历史记录</font>。
>
>   ```vue
>   <router-link to="/abc" replace></router-link>
>   ```
>
> - **custom属性：**类型：boolean，默认值：false。
>
>   custom属性表示：<font color=FF0000>\<router-link> 是否应该将其内容包裹在 \<a> 元素中</font>。<font color=FF0000>**在使用 v-slot 创建自定义 RouterLink 时很有用**</font>。<font color=FF0000 size=4>**默认情况下**，\<router-link> 会将其内容（个人注：这里的内容表示：\<router-link>中包含的标签/内容）包裹在 \<a> 元素中，即使使用 v-slot 也是如此</font>。传递 `custom` prop，可以去除这种行为。
>
>   ```vue
>   <router-link to="/home" custom v-slot="{ navigate, href, route }">
>     <a :href="href" @click="navigate">{{ route.fullPath }}</a>
>   </router-link>
>   ```
>
>   渲染成 `<a href="/home">/home</a>`。
>
>   ```vue
>   <router-link to="/home" v-slot="{ route }">
>     <span>{{ route.fullPath }}</span>
>   </router-link>
>   ```
>
>   渲染成 `<a href="/home"><span>/home</span></a>`。
>
>   > **补充：**custom === true 表示 <font color=FF0000>不会把 \<router-link> 中间的内容用 \<a> 标签包起来（也就<font size=4> **无法自动实现路由跳转的功能，需要手动实现**</font>）</font>
>   >
>   > 摘自：[vue-router@4 路由 - \<router-link custom> custom](https://zhuanlan.zhihu.com/p/423504666)
>
> - **\<router-link> 的 v-slot：**\<router-link> <font color=FF0000>通过一个作用域插槽暴露底层的定制能力</font>。注意：记得把 `custom` 配置传递给 \<router-link>，以防止它将内容包裹在 \<a> 元素内。
>
>   ```vue
>   <router-link to="/about"
>                custom
>                v-slot="{ href, route, navigate, isActive, isExactActive }"
>   >
>     <NavLink :active="isActive" :href="href" @click="navigate">{{ route.fullPath }}</NavLink>
>   </router-link>
>   ```
>
> 以上摘自：[Vue-router - API 参考 - \<router-link> Props](https://next.router.vuejs.org/zh/api/#router-link-props)



#### router-view

**router-view 的 prop**

- **name：** 类型为string，默认值为 "default"；如果 \<router-view> 设置了 name，则会渲染对应的路由配置中 components 下的相应组件
- **route：**类型为RouteLocationNormalized

**router-view 的 v-slot**

- \<router-view> 暴露了一个 v-slot API，主要使用 \<transition> 和 \<keep-alive> 组件来包裹你的路由组件。

- **v-slot 包含如下参数：**

  - **Component：**要传递给 \<component> 的 VNodes 是 prop。

  - **route：**解析出的标准化路由地址。

示例如下：

```vue
<Suspense>
  <template #default>
    <router-view v-slot="{ Component, route }">
      <transition :name="route.meta.transition || 'fade'" mode="out-in">
        <keep-alive>
          <component
            :is="Component"
            :key="route.meta.usePathKey ? route.path : undefined"
          />
        </keep-alive>
      </transition>
    </router-view>
  </template>
  <template #fallback> Loading... </template>
</Suspense>
```

摘自：[Vue router API router-view](https://next.router.vuejs.org/zh/api/#router-view-props)

**补充：**有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。

你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。

如果 router-view 没有设置名字，那么默认为 default。

```vue
<router-view class="view one"></router-view>
<router-view class="view two" name="a"></router-view>
<router-view class="view three" name="b"></router-view>
```

摘自：[Vue Router 10 条高级技巧](https://segmentfault.com/a/1190000039921701)



#### hash路由 和 history路由

##### 两者区别

- 进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）。**注：**这正是 historyApiFallback 所解决的问题。

  history的这种模式需要后台配置支持。比如：当我们进行项目的主页的时候，一切正常，可以访问，但是当我们刷新页面或者直接访问路径的时候就会返回404，那是因为在history模式下，只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起http请求，但是这个目标在服务器上又不存在，所以会返回404

- hash路由 支持低版本的浏览器（兼容性更好），而 history路由 是HTML5新增的 API

- hash 模式下，仅hash符号之前的内容会被包含在请求中，如 http://www.abc.com，因此对于后端来说：即使没有做到对路由的全覆盖，也不会返回404错误。

  history模式下，前端的URL必须和实际向后端发起请求的URL一致。如 http://www.abc.com/book/id。如果后端缺少对/book/id 的路由处理，将返回404错误

摘自：[VUE hash路由和history路由的区别](https://www.jianshu.com/p/f598d49b484c)

##### hash路由 和 history路由 实现原理

- hash路由的原理，是通过监听 hashchange 事件 实现
- history路由的原理，是通过 history API，最主要的 API 有以下两个：history.pushState() 和 history.repalceState()



#### useLink

返回 v-slot API 暴露的所有内容。



#### START_LOCATION

- **类型：**RouteLocationNormalized

- **详细内容**：

  <font color=FF0000>路由所在的初始路由地址</font>。可用于导航守卫中，以区分初始导航。

  ```js
  import { START_LOCATION } from 'vue-router'
  
  router.beforeEach((to, from) => {
    if (from === START_LOCATION) {
      // 初始导航
    }
  })
  ```



#### \$router 和 $route

在 router/index.js 文件夹下，会创建router示例，其中会创建一个routers数组，其中包含的 path和component 的对象就是一个一个route

- vue-router中路由name必须是唯一的

- 路由记录（name）独一无二的名称。

参考自：[Vue Router 4官方文档 - 动态路由 - 删除路由](https://next.router.vuejs.org/zh/guide/advanced/dynamic-routing.html#%E5%88%A0%E9%99%A4%E8%B7%AF%E7%94%B1) / https://next.router.vuejs.org/zh/api/#name-1

**\$router和\$router的区别**

- **this.$router：**router 实例

- **this.$route：**当前激活的路由地址。这个属性是只读的，并且它的属性是不可改变的，但是它可以被观察。

参考自：https://next.router.vuejs.org/zh/api/#navigationguard

**Composition API 中的使用**

- **useRoute：**<font color=FF0000>返回当前路由地址</font>。<font color=FF0000>相当于在模板中使用 \$route</font>。必须在 setup() 中调用。函数签名如下：

  ```ts
  export declare function useRoute(): RouteLocationNormalized
  ```

- **useRouter：**<font color=FF0000>返回 router 实例</font>。<font color=FF0000>相当于在模板中使用 \$router</font>。必须在 setup() 中调用。函数签名如下：

  ```ts
  export declare function useRouter(): Router
  ```

摘自：[Vue router - API](https://next.router.vuejs.org/zh/api/#useroute)



#### router的属性和方法

- **currentRoute：**只读，当前路由地址（个人注：感觉和 this.$route 没什么区别 ）

- **options：**只读，创建 Router 时传递的原始配置对象

- **addRoute：**有两种功能

  - 添加一条新的路由记录<font color=FF0000>作为现有路由的子路由</font>。如果路由有一个 name，并且已经有一个与之名字相同的路由，它会先删除之前的路由。函数签名如下：

    ```ts
    addRoute(parentName: string | symbol, route: RouteRecordRaw): () => void
    ```

    | 参数       | 类型             | 描述                                 |
    | ---------- | ---------------- | ------------------------------------ |
    | parentName | string \| symbol | 父路由记录，route 应该被添加到的位置 |
    | route      | RouteRecordRaw   | 要添加的路由记录                     |

  - <font color=FF0000>添加一条新的路由记录到路由</font>。如果路由有一个 name，并且已经有一个与之名字相同的路由，它会先删除之前的路由。**函数签名如下：**

    ```ts
    addRoute(route: RouteRecordRaw): () => void
    ```

    | 参数  | 类型           | 描述             |
    | ----- | -------------- | ---------------- |
    | route | RouteRecordRaw | 要添加的路由记录 |

- **getRoutes：**<font color=FF0000>获取所有 路由记录的完整列表</font>。函数签名如下：

  ```ts
  getRoutes(): RouteRecord[]
  ```

- **hasRoute：**<font color=FF0000>确认是否存在指定名称的路由</font>。函数签名如下：

  ```ts
  hasRoute(name: string | symbol): boolean
  ```

  | 参数 | 类型             | 描述             |
  | ---- | ---------------- | ---------------- |
  | name | string \| symbol | 要确认的路由名称 |

- **resolve：**<font color=FF0000>返回路由地址的标准化版本</font>。还包括一个包含任何现有 base 的 href 属性（准确的说：是完整链接）。函数签名如下：

  ```ts
  resolve(to: RouteLocationRaw): RouteLocation & {href: string}
  ```

  | 参数 | 类型             | 描述                 |
  | ---- | ---------------- | -------------------- |
  | to   | RouteLocationRaw | 要解析的原始路由地址 |

摘自：[Vue router - api - router方法](https://next.router.vuejs.org/zh/api/#router-方法)



#### RouteLocationNormalized

标准化的路由地址，（个人感觉：就是 this.$route？）

- fullPath：URL 编码与路由地址有关。包括 `path`、 `query` 和 `hash`。

摘自：https://next.router.vuejs.org/zh/api/#routelocationnormalized



#### 路由守卫

- **全局守卫**
  - **router.beforeEach：**全局前置守卫，**添加一个导航守卫，在任何导航前执行**。返回一个删除注册钩子的函数。
  - **router.beforeResolve:** 全局解析守卫，**添加一个导航守卫，在导航即将解析之前执行**。**在这个状态下，所有的组件都已经被获取，并且其他导航守卫也已经成功**。返回一个删除已注册守卫的函数。
  - **router.afterEach：**全局后置守卫，**添加一个导航钩子，在每次导航后执行**。返回一个删除注册钩子的函数。

- **路由守卫**
  - **beforeEnter：**在进入特定于此记录的守卫之前。注意如果记录有重定向属性，则 beforeEnter 无效。
- **组件守卫**
  - beforeRouteEnter
  - beforeRouteUpdate
  - beforeRouteLeave

**完整的导航解析流程**（<font color=FF0000 size=4> **所有路由守卫执行顺序** </font>）

1. 导航被触发。
2. 在失活的<mark style=background-color:aqua>组件</mark>里调用 <mark style=background-color:aqua>beforeRouteLeave</mark> 守卫。
3. 调用<mark style=background-color:hotpink>全局</mark>的 <mark style=background-color:hotpink>beforeEach</mark> 守卫。
4. 在重用的<mark style=background-color:aqua>组件</mark>里调用 <mark style=background-color:aqua>beforeRouteUpdate</mark> 守卫(2.2+)。
5. 在<mark>路由配置</mark>里调用 <mark>beforeEnter</mark>。
6. 解析异步路由组件。
7. 在被激活的<mark style=background-color:aqua>组件</mark>里调用 <mark style=background-color:aqua>beforeRouteEnter</mark>。
8. 调用<mark style=background-color:hotpink>全局</mark>的 <mark style=background-color:hotpink>beforeResolve</mark> 守卫(2.5+)。
9. 导航被确认。
10. 调用<mark style=background-color:hotpink>全局</mark>的 <mark style=background-color:hotpink>afterEach</mark> 钩子。
11. 触发 DOM 更新。
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

摘自：[Vue Router 4官方文档 - 导航守卫](https://next.router.vuejs.org/zh/guide/advanced/navigation-guards.html)



#### watch侦听路由变化的方法

- 方法一

  ```js
  watch:{
    $route(to,from){
      console.log(to.path);
    }
  }
  ```

- 方法二：

  ```js
  watch: {
    $route: {
      handler: function(val, oldVal){
        console.log(val);
      },
      // 深度观察监听
      deep: true
    }
  }
  ```

- 方法三：

  ```js
  watch: {
    '$route':'getPath'
  },
  methods: {
    getPath(){
      console.log(this.$route.path);
    }
  }
  ```

摘自：[vue 监听路由变化](https://www.cnblogs.com/crazycode2/p/8727410.html)



## Vuex

#### Getters

> 在 store 上注册 getter，getter 方法接受以下参数：
>
> ```js
> state,     // 如果在模块中定义则为模块的局部状态
> getters,   // 等同于 store.getters
> ```
>
> 当<font color=FF0000>定义在一个模块里</font>时会特别一些：
>
> ```js
> state,       // 如果在模块中定义则为模块的局部状态
> getters,     // 等同于 store.getters
> rootState    // 等同于 store.state
> rootGetters  // 所有 getters
> ```
>
> 注册的 getter 暴露为 store.getters



#### Actions

> 在 store 上注册 action。处理函数总是接受 context 作为第一个参数，payload 作为第二个参数（可选）。
>
> **context 对象包含以下属性：**
>
> ```js
> {
>   	state,      // 等同于 `store.state`，若在模块中则为局部状态
>   	rootState,  // 等同于 `store.state`，只存在于模块中
>   	commit,     // 等同于 `store.commit`
>   	dispatch,   // 等同于 `store.dispatch`
>   	getters,    // 等同于 `store.getters`
>   	rootGetters // 等同于 `store.getters`，只存在于模块中
> }
> ```
>
> 同时如果有第二个参数 payload 的话也能够接收
>
> 摘自：https://next.vuex.vuejs.org/zh/api/#actions



#### mapXXX

mapState、mapGetters 应该被放在computed中；mapMutations、mapActions 应该被放在 methods中

另外，mapXXX都可以加上 <font color=FF0000 size=4>**可选的** 第一个参数 namespace </font>

参见：https://next.vuex.vuejs.org/zh/api/#组件绑定的辅助函数



#### dispatch 和 promise

> store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise。
>
> 摘自：[Vuex文档 - actions - 组合](https://next.vuex.vuejs.org/zh/guide/actions.html#组合-action)



#### namespace

加上 namespace的原因：

> <font color=FF0000 size=4>**模块内部的 action 和 mutation 仍然是注册在全局命名空间的**</font>——这样使得多个模块能够对同一个 action 或 mutation 作出响应。<font color=FF0000>Getter 同样也默认注册在全局命名空间</font>，但是目前这并非出于功能上的目的（仅仅是维持现状来避免非兼容性变更）。必须注意，不要在不同的、无命名空间的模块中定义两个相同的 getter 从而导致错误。
>
> <font color=FF0000>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块</font>
>
> 摘自：https://next.vuex.vuejs.org/zh/guide/modules.html#命名空间 



#### createNamespacedHelpers

> ```js
> createNamespacedHelpers(namespace: string): Object
> ```
>
> 创建基于命名空间的组件绑定辅助函数。其返回一个包含 mapState、mapGetters、mapActions 和 mapMutations 的对象。它们都已经绑定在了给定的命名空间上。
>
> https://next.vuex.vuejs.org/zh/api/#createnamespacedhelpers

示例如下：

```js
import { createNamespacedHelpers } from 'vuex'

const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')

export default {
  computed: {
    // 在 `some/nested/module` 中查找
    ...mapState({
      a: state => state.a,
      b: state => state.b
    })
  },
  methods: {
    // 在 `some/nested/module` 中查找
    ...mapActions([
      'foo',
      'bar'
    ])
  }
}
```

摘自：https://next.vuex.vuejs.org/zh/guide/modules.html#带命名空间的绑定函数 

这样写不需要加上复杂的前缀什么的



## Pinia

#### 什么是store

> A Store (like Pinia) is an entity holding state and business logic that isn't bound to your Component tree. In other words, it hosts global state. It's a bit like a component that is always there and that everybody can read off and write to. <font color=FF0000>It has three concepts, the state, getters and actions and it's safe to assume these concepts are the equivalent of data, computed and methods in components</font>
>
> 摘自：https://pinia.vuejs.org/getting-started.html#what-is-a-store



#### mapState

在pinia中，不推荐使用mapGetters，mapGetters仅仅用于Vuex4的迁移。mapGetters相关功能，通过mapState实现。



## Vue CLI

#### vue add 和 npm install的区别

vue add可能会改变现有的项目结构，但是npm install仅仅是安装包而不会改变项目的结构

- 如果你下载的库, 特别是 Ui 库, 希望对脚手架结构产生影响，那就选择 vue add

- 如果不希望对脚手架结构产生影响, 只是单纯的使用, 比如 axios 这个插件，那就选择 npm install

摘自：[Vue创建一个新的项目、vue add 和npm install区别](https://codeleading.com/article/35174593221/)

**补充：**

vue add 的设计意图是为了安装和调用 Vue CLI 插件。这不意味着替换掉普通的 npm 包。对于这些普通的 npm 包，你仍然需要选用包管理器。

摘自：[Vue CLI官方文档 - 插件和 Preset](https://cli.vuejs.org/zh/guide/browser-compatibility.html#插件)



#### 文件chunk-vendors.xxx.js是做什么的

是<font color=FF0000> 为更好的缓存而做的自动的 vendor chunk splitting</font>

摘自：[Vue3 CLI文档 - CLI 服务 - vue-cli-service build](https://cli.vuejs.org/zh/guide/cli-service.html#vue-cli-service-build)



## Vite

> **server.proxy**
>
> **类型：Record\<string, string | ProxyOptions>**
>
> 为开发服务器配置自定义代理规则。期望接收一个 { key: options } 对象。如果 key 值以 `^` 开头，将会被解释为 RegExp
>
> 摘自：https://cn.vitejs.dev/config/#server-proxy

补充：类似的webpack 中的配置应该也是：如果 key 值以 `^` 开头，将会被解释为 RegExp



## 网络

#### **同源的定义**

如果两个 URL 的 <font color=FF0000 size=4>protocol、port（如果有指定的话）和 host 都相同</font> 的话，则这两个 URL 是同源。这个方案也被称为 “协议/主机/端口 元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。

**下表给出了与 URL `http://store.company.com/dir/page.html` 的源进行对比的示例：**

| URL                                               | 结果 | 原因                               |
| :------------------------------------------------ | :--- | :--------------------------------- |
| `http://store.company.com/dir2/other.html`        | 同源 | 只有路径不同                       |
| `http://store.company.com/dir/inner/another.html` | 同源 | 只有路径不同                       |
| `https://store.company.com/secure.html`           | 失败 | 协议不同                           |
| `http://store.company.com:81/dir/etc.html`        | 失败 | 端口不同 ( `http://` 默认端口是80) |
| `http://news.company.com/dir/other.html`          | 失败 | 主机不同                           |

摘自：[MDN - 浏览器的同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)
