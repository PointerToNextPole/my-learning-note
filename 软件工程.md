# 软件工程



## <font color=FF0000>**技术选型**</font>

<font size=3>**什么是技术选型**</br>

技术选型指的是根据实际业务管理的需要，对硬件、软件及所要用到的技术进行规格选择。

选自：[**什么叫“技术选型”--百度知道**](https://zhidao.baidu.com/question/89975098.html)

</font>

## <font color=FF0000>开发环境、测试环境、预发布环境、生产环境的区别</font>

<font size=3>一个软件产品<mark>从开发到用户使用</mark>都涉及哪些环境：<mark>**开发环境、测试环境、回归环境、预发布环境、生产环境**</mark>。

- **开发环境：**开发同学<mark>开发时使用的环境</mark>，每位开发同学在自己的dev分支上干活，提测前或者开发到一定程度，各位同学会合并代码，进行联调
- **测试环境：**<mark>测试的环境</mark>，一般会由测试同学自己来部署，然后在此环境进行测试。bug修复后，需要发版更新测试环境来回归bug
- **回归环境：**<mark>回归bug的环境</mark>，其实就是测试环境，在测试环境上测试、回归验证bug
- **预发布环境：**<mark>测试环境到生产环境的过渡。测试环境可能会受到一些限制，一些流程或者数据没有测试到，就可以在预发布环境进行验证，从而保证产品上线质量</mark>
- **生产环境：**<mark>即线上环境，用户使用的环境</mark>。由特定人员来维护，一般人没有权限去修改

选自：[**开发环境、测试环境、预发布环境、生产环境的区别**](https://www.jianshu.com/p/ba20b064fd25)

</font>

## <font color=FF0000>**数据库拆分与数据库中间件**</font>

####  痛点

传统的架构模式就是 应用连接数据库直接对数据进行访问，这种架构特点就是简单方便。

但<mark>随着目前数据量不断的增大我们就遇到了问题：</mark>

- 单个表数据量太大
- 单个库数据量太大
- 单台数据量服务器压力很大
- 读写速度遇到瓶颈

当面临以上问题时，我们会想到的<mark>**第一种解决方式**</mark>就是 <mark>向上扩展 </mark>(scale up) 简单来说就是<mark>不断增加硬件性能。这种方式只能暂时解决问题，当业务量不断增长时还是解决不了问题。</mark>特别是淘宝，facebook，youtube 这种业务成线性，甚至指数级上升的情况

此时我们不得不依赖于<mark>**第二种方式**</mark>： <mark>水平扩展</mark> 。 <mark>直接增加机器，把数据库放到不同服务器上，在应用到数据库之间加一个 proxy 进行路由，这样就可以解决上面的问题了。</mark>

摘自：[**分布式数据库中间件对比总结**](https://blog.csdn.net/w892824196/article/details/82660415)

#### 数据拆分

互联网当下的<mark>数据库拆分过程基本遵循的顺序</mark>是：<mark>垂直拆分、读写分离、分库分表 (水平拆分)</mark>

- **垂直拆分：**指的是将一个包含了很多表的数据库，<mark>根据表的功能的不同（根据业务），拆分为多个小的数据库</mark>，每个库包含部分表。

  - 垂直拆分的<mark>一个典型场景</mark>是：刚开始，可能公司的技术团队规模比较小，所有的数据都位于一个库中。随着公司业务的发展，数据量变大，需要进行数据拆分。
  - <mark>另一个典型应用场景</mark>是服务化 (SOA) 改造。

- **读写分离：**随着业务的不断发展，用户数量和并发量不断上升。这时<mark>如果仅靠单个数据库实例来支撑所有访问压力, 几乎是在自寻死路 。数据库读的压力太大，单台 mysql 实例扛不住</mark>，此时大部分 Mysql DBA 就会将数据库设置成 读写分离状态 。即<mark>**一个**<font color=FF0000>**Master节点(主库) ** </font>对应**多个**<font color=FF0000>**Salve节点(从库)**</font></mark>。可以将 slave 节点的数据理解为 master 节点数据的全量备份。

- **分库分表：**经过垂直分区后的 Master/Salve 模式完全可以承受住难以想象的高并发访问操作，但是否可以永远 高枕无忧 了？答案是否定的，一旦业务表中的数据量大了，从维护和性能角度来看，无论是任何的 CRUD 操作，对于数据库而言都是一件极其耗费资源的事情。即便设置了索引， 仍然无法掩盖因为数据量过大从而导致的数据库性能下降的事实 ，因此这个时候 Mysql DBA 或许就该对数据库进行<mark>水平分区 （sharding，即分库分表 ）</mark>

  水平分表从具体实现上又可以分为 <font color=FF0000>**3种**</font>：<mark>**只分表、只分库、分库分表**</mark>；示图如下：

  <img src="http://5b0988e595225.cdn.sohucs.com/images/20190827/06315d8ef17b48b3b7717c2e1dfd7049.jpeg" alt="img" style="zoom:60%;" />)

  - **只分表：**<mark>将</mark> db 库中的 user <mark>表拆分</mark>为 2 个分表，user_0 和 user_1，<mark>这两个表还位于同一个库中</mark>。适用场景：如果库中的多个表中只有某张表或者少数表数据量过大，那么只需要针对这些表进行拆分，其他表保持不变。

  - **只分库：**<mark>将</mark> db <mark>库拆分</mark>为 db_0 和 db_1 两个库，<mark>同时在 db_0 和 db_1 库中各自新建一个 user 表，db_0.user 表和 db_1.user 表中各自**只存原来的 db.user 表中的部分数据**</mark>。

  - **分库分表：**将 db <mark>库拆分</mark>为 db_0 和 db_1 两个库，<mark>db_0 中包含 user_0、user_1 两个分表</mark>，<mark>db_1 中包含 user_2、user_3 两个分表</mark>。下图演示了在分库分表的情况下，数据是如何拆分的：

    <img src="http://5b0988e595225.cdn.sohucs.com/images/20190827/b6279aa921644d33ace6cc1d3d691a1d.png" style="zoom:80%;" />

    <mark>**假设 db 库的 user 表中原来有 4000W 条数据**，现在将 db 库拆分为 2 个分库 db_0 和 db_1，user 表拆分为 user_0、user_1、user_2、user_3 四个分表，**每个分表存储 1000W 条数据**。</mark>

  #### **分库分表的好处**：

  <mark>如果说<font color=FF0000>读写分离</font>实现了<font color=FF0000>数据库读能力的水平扩展</font>，那么<font color=FF0000>分库分表</font>就是实现了<font color=FF0000>写能力的水平扩展</font>。</mark>

  - **存储能力的水平扩展：**在<mark style=color:red>**读写分离**</mark>的情况下，<mark>每个集群中的 master 和 slave 基本上数据是完全一致的，从存储能力来说，在存在海量数据的情况下，可能由于磁盘空间的限制，无法存储所有的数据</mark>。

    而在<mark style=color:red>**分库分表**</mark>的情况下，我们可以搭建多个 mysql 主从复制集群，每个集群只存储部分分片的数据，实现存储能力的水平扩展。

  - **写能力的水平扩展：**在<mark style=color:red>**读写分离**</mark>的情况下，由于<mark>每个集群只有一个 master，所有的写操作压力都集中在这一个节点上，在写入并发非常高的情况下，这里会成为整个系统的瓶颈</mark>。

    而在<mark style=color:red>**分库分表**</mark>的情况下，<mark>每个分片所属的集群都有一个 master 节点，都可以执行写入操作，实现写能力的水平扩展</mark>。此外减小建立索引开销，降低写操作的锁操作耗时等，都会带来很多显然的好处。

选自：[**史上最全数据库中间件详解**](https://www.sohu.com/a/336811296_505827)，<mark>**由于时间关系这篇博文还有一半没有读完，写的非常好，强烈推荐！！！**</mark>



## <font color=FF0000>静态资源和动态资源</font>

**静态资源：** 当用户多次访问这个资源，资源的源代码永远不会改变的资源。可以理解为前端的固定页面，这里面包含HTML、CSS、JS、图片等等，不需要查数据库也不需要程序处理，直接就能够显示的页面，如果想修改内容则必须修改页面，但是访问效率相当高。
**动态资源：**当用户多次访问这个资源，资源的源代码可能会发送改变。需要程序处理或者从数据库中读数据，能够根据不同的条件在页面显示不同的数据，内容更新不需要修改页面但是访问速度不及静态页面。

摘自：[动态资源与静态资源](https://www.cnblogs.com/toov5/p/9919979.html) 和 [静态资源和动态资源区别](https://blog.csdn.net/qwertyuiopasdfgg/article/details/89647201)