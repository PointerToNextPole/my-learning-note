# 正则表达式



### **修饰符**

//todo

正则表达式中常用的模式修饰符有i、g、m、s、U、x、a、D、e 等

https://blog.csdn.net/qq_36340642/article/details/79352876



#### 元字符

- **常见元字符（metacharacter）**

  |  代码  |                             说明                             |
  | :----: | :----------------------------------------------------------: |
  | **.**  |     匹配<font color=FF0000>除换行符以外的任意字符</font>     |
  | **\w** |                 匹配字母或数字或下划线或汉字                 |
  | **\s** | 匹配<font color=FF0000>任意的空白符</font>（包括空格，制表符(Tab)，换行符，中文全角空格等） |
  | **\d** |                           匹配数字                           |
  | **\b** | 匹配<font color=FF0000>单词的开始或结束</font>（即：单词的分界处） |
  | **^**  |          匹配<font color=FF0000>字符串的开始</font>          |
  | **$**  |          匹配<font color=FF0000>字符串的结束</font>          |
  | **(**  |                   用于创建分组（子表达式）                   |
  | **)**  |                             同上                             |

- **常见的限定符**

  | 代码/语法 |                             说明                             |
  | :-------: | :----------------------------------------------------------: |
  |   *****   | 重复<font color=FF0000>零次</font>或<font color=FF0000>更多次</font> |
  |   **+**   | 重复<font color=FF0000>一次</font>或<font color=FF0000>更多次</font> |
  |   **?**   | 重复<font color=FF0000>零次</font>或<font color=FF0000>一次</font> |
  |  **{n}**  |              重复<font color=FF0000>n次</font>               |
  | **{n,}**  | 重复<font color=FF0000>n次</font>或<font color=FF0000>更多次</font> |
  | **{n,m}** | 重复<font color=FF0000>n次</font>到<font color=FF0000>m次</font> |

注意：<font color=FF0000>正则表达式里的**「单词」**</font>不同于英语中的意思，<font color=FF0000>它的意思是：不少于一个的连续的 **`\w`**</font>



#### **字符转义**

如果你<font color=FF0000>想查找元字符本身</font>的话，比如你查找`.`，或者`*`，就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用`\.`和`\*`。当然，要查找`\`本身，你也得用`\\`。

补充，转义字符还包括：`\(`用于转义`(`

例如：`deerchao\.cn`匹配`deerchao.cn`，`C:\\Windows`匹配`C:\Windows`。



#### **字符类**

如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？

很简单，你只需要在方括号里列出它们就行了，像<font color=FF0000>`[aeiou]`</font>就<font color=FF0000>匹配任何一个</font>（英文元音）<font color=FF0000>字母</font>，<font color=FF0000>`[.?!]`</font><font color=FF0000>匹配标点符号(`.`或`?`或`!`)</font>。

我们也<font color=FF0000>可以</font>轻松地<font color=FF0000>指定一个字符**范围**</font>，像<font color=FF0000>[0-9]</font>代表的含意与\d就是完全一致的：一位数字；同理<font color=FF0000>[a-z0-9A-Z_]</font>也完全等同于\w（如果只考虑英文的话）。

**示例**：`\(?0\d{2}[) -]?\d{8}`

这个表达式可以匹配几种格式的电话号码，比如：*010)88886666*，或*022-22334455*，或*02912345678*等。

- `\(`：是一个转义字符，转义`(`
- `?`：表示转义的`(`可以出现0次或者1次
- `0`：就是0
- `\d{2}`：表示数字数字出现两次
- `[) -]?`：表示`)`， ` `， `-`中的一个，出现0次或者1次
- `\d{8}`：表示数字数字出现8次

<img src="https://i.loli.net/2020/09/11/r9G7K5HuWMUtic8.png" style="zoom: 40%;" />

#### **分枝条件**

上面的`\(?0\d{2}[) -]?\d{8}`表达式也能匹配*010)12345678或(022-87654321`这样的“不正确”的格式。要解决这个问题，我们需要用到**分枝条件**。

正则表达式里的**分枝条件**指的是有几种规则，<font color=FF0000>如果满足其中任意一种规则都应该当成匹配</font>，具体方法是<font color=FF0000>用|把不同的规则分隔开。</font>

**示例：**`0\d{2}-\d{8}|0\d{3}-\d{7}`

<img src="https://i.loli.net/2020/09/11/b8aQJsYctmSCFuO.png" style="zoom:31%;" />



#### 分组

想要重复多个字符又该怎么办？你可以<font color=FF0000>用小括号来指定**子表达式**(也叫做**分组**)</font>

示例：`(\d{1,3}\.){3}\d{1,3}`

是一个<font color=FF0000>简单的</font>IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个**分组**)重复3次，最后再加上一个一到三位的数字(\d{1,3})。

<img src="https://i.loli.net/2020/09/11/fkXdO1L2gvH7iwx.png" style="zoom:50%;" />

不幸的是，它也将匹配 *256.300.888.999* 这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：

**<font color=FF0000>(</font> <font color=aqua>(</font>2[0-4]\d <font color=fuchsia>|</font> 25[0-5] <font color=fuchsia>| </font>[01]?\d\d?<font color=aqua>)</font> \\.<font color=FF0000>)</font>{3}  <font color=aqua>(</font>2[0-4]\d <font color=fuchsia>| </font>25[0-5] <font color=fuchsia>| </font>[01]?\d\d?<font color=aqua>)</font>**

**关于分组的补充：**

- <font color=FF0000>**分组0对应整个正则表达式**</font>

- 实际上<font color=FF0000>**组号分配过程是要从左向右扫描两遍的**</font>：<mark>第一遍只给未命名组分配，第二遍只给命名组分配</mark>－－因此<font color=FF0000>所有命名组的组号都大于未命名的组号</font>

- 你可以<font color=FF0000>使用 **(?:exp)** 这样的语法来**剥夺一个分组对组号分配的参与权**</font>

  

#### **使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：**

- **捕获**
  - **(exp)**：匹配exp,并捕获文本到自动命名的组里
  - **(?\<name>exp)**：匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
  - **(?:exp)**：匹配exp,不捕获匹配的文本，也不给此分组分配组号
- **零宽断言**
  - **(?=exp)**：匹配exp前面的位置
  - **(?<=exp)**：匹配exp后面的位置
  - **(?!exp)**：匹配后面跟的不是exp的位置
  - **(?<!exp)**：匹配前面不是exp的位置
- **注释**
  - **(?#comment)**：这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读



#### 反义

有时需要<font color=FF0000>查找不属于某个能简单定义的字符类的字符</font>。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**：

|  代码/语法   |                             说明                             |
| :----------: | :----------------------------------------------------------: |
|    **\W**    | 匹配<font color=FF0000>任意**不是**字母，数字，下划线，汉字的字符</font> |
|    **\S**    |    匹配<font color=FF0000>任意**不是**空白符的字符</font>    |
|    **\D**    |      匹配<font color=FF0000>任意**非**数字的字符</font>      |
|    **\B**    |  匹配<font color=FF0000>**不是**单词开头或结束的位置</font>  |
|   **[^x]**   |    匹配<font color=FF0000>**除了**x以外的任意字符</font>     |
| **[^aeiou]** | 匹配<font color=FF0000>**除了**aeiou这几个字母以外的任意字符</font> |

<font color=FF0000>**注意：反义的代码就是「正义」字符的小写变成大写。**</font>

**示例：**

- `\S+`：匹配不包含空白符的字符串（由于加上了可重复1次或者多次的`+`，所以由字符变成了字符串）。

- `<a[^>]+>`：匹配用尖括号括起来的以a开头的字符串。



#### 后向引用

使用小括号指定一个子表达式后，<font color=FF0000>**匹配这个子表达式的文本**</font>(也就是此分组捕获的内容)<font color=FF0000>可以在（父？）表达式或其它程序中作进一步的处理</font>。默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

**后向引用**用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。

示例：**\b(\w+)\b \s+\1\b**可以用来匹配重复的单词，像*go go*, 或者*kitty kitty*。这个表达式<font color=FF0000>首先是一个单词</font>，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，<font color=FF0000>这个单词会被捕获到编号为1的分组中</font>，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。

你<font color=FF0000>也可以自己指定子表达式的**组名**</font>。<font color=FF0000>要指定一个子表达式的组名，请使用这样的语法：**(?\<Word>\w+)**</font>（<font color=FF0000>或者把尖括号换成'也行：**(?'Word'\w+)**</font>），<font color=FF0000>这样就把\w+的组名指定为Word了</font>。<font color=FF0000>要**反向引用**这个分组**捕获**的内容，你可以使用\k\<Word></font>，所以上一个例子也可以写成这样：\b<font color=FF0000>(?\<Word>\w+)</font>\b\s+<font color=FF0000>\k\<Word></font>\b。

另外，<font color=FF0000>**(?:exp)**</font>不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。



#### 零宽断言

接下来的四个用于<font color=FF0000>查找在某些内容（但并不包括这些内容）**之前**或**之后**的东西</font>，也就是说它们像`\b`、`^`、 `$`那样用于指定一个位置，<font color=FF0000>这个位置应该满足一定的条件（即断言）</font>，因此它们也被称为<font color=FF0000>**零宽断言**</font>。最好还是拿例子来说明吧：

<font color=FF0000>**(?=exp)**</font>：也叫<font color=FF0000>**零宽度正预测先行断言**</font>，它 断言自身出现的位置 的后面 能匹配表达式exp。<mark>比如 \b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找<font color=FF0000>*I'm*</font> <font color=fuchsia>***sing***</font><font color=FF0000>*ing while you're <font color=fuchsia>**danc**</font>ing.*</font>时，它会匹配<font color=fuchsia>**sing**</font>和<font color=fuchsia>**danc**</font></mark>。

<font color=FF0000>**(?<=exp)**</font>也叫<font color=FF0000>**零宽度正回顾后发断言**</font>，它 断言自身出现的位置 的前面 能匹配表达式exp。<mark>比如 (?<=\bre)\w+\b 会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找<font color=FF0000>*re*</font><font color=fuchsia>***ading***</font> <font color=FF0000>*a book*</font>时，它匹配<font color=fuchsia>**ading**</font></mark>。

假如你想要给一个<font color=FF0000>很长的数字</font>中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?<=\d)\d{3})+\b，用它对*1234567890*进行查找时结果是234567890。

下面这个例子同时使用了这两种断言：(?<=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。



#### <font color=FF0000>负向</font>零宽断言

前面我们提到过怎么查找<font color=FF0000>**不是某个字符或不在某个字符类里**的字符的方法（**反义**）</font>。但是如果我们只是想要**确保某个字符没有出现，但并不想去匹配它**时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：

\b\w\*q\[^u]\w\*\b匹配包含**后面不是字母u的字母q**的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像**Iraq**,**Benq**，这个表达式就会出错。这是因为\[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的\[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w\*\b将会匹配下一个单词，于是\b\w\*q\[^u]\w\*\b就能匹配整个*Iraq fighting*。<mark>**负向零宽断言**能解决这样的问题，因为<font color=FF0000>它只匹配一个位置，并不**消费**任何字符</font>。现在，我们可以这样来解决这个问题：\b\w\*q(?!u)\w\*\b</mark>。

<font color=FF0000>**零宽度负预测先行断言 **(?!exp)</font>，断言此位置的**后面**不能匹配表达式exp。<mark>例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词</mark>。

同理，我们可以用<font color=FF0000>(?<!exp)，**零宽度负回顾后发断言**</font>来断言此位置的**前面**不能匹配表达式exp：<mark>(?<![a-z])\d{7}匹配前面不是小写字母的七位数字</mark>。

一个更复杂的例子：(?<=<(\w+)>).\*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容。(?<=<(\w+)>)指定了这样的**前缀**：被尖括号括起来的单词(比如可能是\<b>)，然后是.\*(任意的字符串)，最后是一个**后缀**(?=<\/\1>)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。



#### 注释

小括号的另一种用途是<font color=FF0000>通过语法(?#comment)来包含注释</font>。例如：2[0-4]\d<font color=FF0000>(?#200-249)</font>|25\[0-5\]<font color=FF0000>\(?#250-255\)</font>|\[01\]?\d\d?\(?\#0\-199\)。

要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：

```
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的内容
        # (即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容
        # 查找尖括号括起来的内容
)       # 后缀结束
```



#### 贪婪与懒惰

当正则表达式中包含能接受重复的限定符时，<font color=FF0000>通常的行为是</font>（在使整个表达式能得到匹配的前提下）<font color=FF0000>匹配**尽可能多**的字符</font>。以这个表达式为例：a\.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索*aabab\*的话，它会匹配整个字符串aabab。<font color=FF0000>这被称为**贪婪**匹配</font>。

<font color=FF0000>有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符</font>。前面给出的限定符都可以被转化为懒惰匹配模式，<font color=FF0000>只要**在它后面**加上一个**问号?**</font>。这样\.\*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

a\.\*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于*aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。<font color=FF0000>**补充：**</font>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为<font color=FF0000>正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：**最先开始的匹配拥有最高的优先权——The match that begins earliest wins**</font>。

**懒惰限定符**（就是限定词加上`?`）

| 代码/语法 |              说明               |
| :-------: | :-----------------------------: |
|    *?     |   重复任意次，但尽可能少重复    |
|    +?     | 重复1次或更多次，但尽可能少重复 |
|    ??     |  重复0次或1次，但尽可能少重复   |
|  {n,m}?   |   重复n到m次，但尽可能少重复    |
|   {n,}?   |   重复n次以上，但尽可能少重复   |



#### 平衡组/递归匹配

<font color=FF0000>**注意：**</font>这里介绍的平衡组语法是由.Net Framework支持的；其它语言／库不一定支持这种功能，或者支持此功能但需要使用不同的语法。

有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\(.+\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。<mark>假如原来的字符串里的左括号和右括号出现的次数不相等，比如*( 5 / ( 3 + 2 ) ) )*，那我们的匹配结果里两者的个数也不会相等</mark>。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？

为了避免(和\\(把你的大脑彻底搞糊涂，我们还是<font color=FF0000>用尖括号代替圆括号</font>吧。现在我们的问题变成了如何把\*xx \<aa \\\<bbb\> \\\<bbb\> aa\> yy\*这样的字符串里，最长的配对的尖括号内的内容捕获出来？

这里需要用到以下的语法构造：

- <font color=FF0000>**(?'group')**</font> 把捕获的内容<font color=FF0000>命名为group</font>，<font color=FF0000>并压入**堆栈(Stack)**</font>
- <font color=FF0000>**(?'-group')**</font> 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- <font color=FF0000>**(?(group)yes|no)**</font> 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
- <font color=FF0000>**(?!)**</font> 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

我们需要做的是每碰到了左括号，就在压入一个"Open"，每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。

```
<                   #最外层的左括号
  [^<>]*            #它后面非括号的内容
  (
      (
        (?'Open'<)  #左括号，压入"Open"
        [^<>]*      #左括号后面的内容
      )+
      (
        (?'-Open'>) #右括号，弹出一个"Open"
        [^<>]*      #右括号后面的内容
      )+
  )*
  (?(Open)(?!))     #最外层的右括号前检查
                    #若还有未弹出的"Open"
                    #则匹配失败

>                #最外层的右括号
```

平衡组的一个最常见的应用就是匹配HTML，下面这个例子可以匹配嵌套的\<div>标签：\<div\[^\>\]\*\>\[^\<\>\]\*\(\(\(?\'Open\'\<div\[^\>\]\*\>\)\[^\<\>\]\*)\+\(\(?\'\-Open\'\</div\>)\[^\<\>\]\*\)\+\)\*(?\(Open\)\(?!)\)\</div\>

摘自：[正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm#negation)

