# 正则表达式



### **修饰符**

//todo

正则表达式中常用的模式修饰符有i、g、m、s、U、x、a、D、e 等

https://blog.csdn.net/qq_36340642/article/details/79352876



#### 元字符

- **常见元字符（metacharacter）**

  |  代码  |                             说明                             |
  | :----: | :----------------------------------------------------------: |
  | **.**  |     匹配<font color=FF0000>除换行符以外的任意字符</font>     |
  | **\w** |                 匹配字母或数字或下划线或汉字                 |
  | **\s** | 匹配<font color=FF0000>任意的空白符</font>（包括空格，制表符(Tab)，换行符，中文全角空格等） |
  | **\d** |                           匹配数字                           |
  | **\b** | 匹配<font color=FF0000>单词的开始或结束</font>（即：单词的分界处） |
  | **^**  |          匹配<font color=FF0000>字符串的开始</font>          |
  | **$**  |          匹配<font color=FF0000>字符串的结束</font>          |
  | **(**  |                   用于创建分组（子表达式）                   |
  | **)**  |                             同上                             |

- **常见的限定符**

  | 代码/语法 |                             说明                             |
  | :-------: | :----------------------------------------------------------: |
  |   *****   | 重复<font color=FF0000>零次</font>或<font color=FF0000>更多次</font> |
  |   **+**   | 重复<font color=FF0000>一次</font>或<font color=FF0000>更多次</font> |
  |   **?**   | 重复<font color=FF0000>零次</font>或<font color=FF0000>一次</font> |
  |  **{n}**  |              重复<font color=FF0000>n次</font>               |
  | **{n,}**  | 重复<font color=FF0000>n次</font>或<font color=FF0000>更多次</font> |
  | **{n,m}** | 重复<font color=FF0000>n次</font>到<font color=FF0000>m次</font> |

注意：<font color=FF0000>正则表达式里的**「单词」**</font>不同于英语中的意思，<font color=FF0000>它的意思是：不少于一个的连续的 **`\w`**</font>



#### **字符转义**

如果你<font color=FF0000>想查找元字符本身</font>的话，比如你查找`.`，或者`*`，就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用`\.`和`\*`。当然，要查找`\`本身，你也得用`\\`。

补充，转义字符还包括：`\(`用于转义`(`

例如：`deerchao\.cn`匹配`deerchao.cn`，`C:\\Windows`匹配`C:\Windows`。



#### **字符类**

如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？

很简单，你只需要在方括号里列出它们就行了，像<font color=FF0000>`[aeiou]`</font>就<font color=FF0000>匹配任何一个</font>（英文元音）<font color=FF0000>字母</font>，<font color=FF0000>`[.?!]`</font><font color=FF0000>匹配标点符号(`.`或`?`或`!`)</font>。

我们也<font color=FF0000>可以</font>轻松地<font color=FF0000>指定一个字符**范围**</font>，像<font color=FF0000>[0-9]</font>代表的含意与\d就是完全一致的：一位数字；同理<font color=FF0000>[a-z0-9A-Z_]</font>也完全等同于\w（如果只考虑英文的话）。

**示例**：`\(?0\d{2}[) -]?\d{8}`

这个表达式可以匹配几种格式的电话号码，比如：*010)88886666*，或*022-22334455*，或*02912345678*等。

- `\(`：是一个转义字符，转义`(`
- `?`：表示转义的`(`可以出现0次或者1次
- `0`：就是0
- `\d{2}`：表示数字数字出现两次
- `[) -]?`：表示`)`， ` `， `-`中的一个，出现0次或者1次
- `\d{8}`：表示数字数字出现8次

<img src="https://i.loli.net/2020/09/11/r9G7K5HuWMUtic8.png" style="zoom: 40%;" />

#### **分枝条件**

上面的`\(?0\d{2}[) -]?\d{8}`表达式也能匹配*010)12345678或(022-87654321`这样的“不正确”的格式。要解决这个问题，我们需要用到**分枝条件**。

正则表达式里的**分枝条件**指的是有几种规则，<font color=FF0000>如果满足其中任意一种规则都应该当成匹配</font>，具体方法是<font color=FF0000>用|把不同的规则分隔开。</font>

**示例：**`0\d{2}-\d{8}|0\d{3}-\d{7}`

<img src="https://i.loli.net/2020/09/11/b8aQJsYctmSCFuO.png" style="zoom:31%;" />



#### 分组

想要重复多个字符又该怎么办？你可以<font color=FF0000>用小括号来指定**子表达式**(也叫做**分组**)</font>

示例：`(\d{1,3}\.){3}\d{1,3}`

是一个<font color=FF0000>简单的</font>IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配1到3位的数字，(\d{1,3}\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个**分组**)重复3次，最后再加上一个一到三位的数字(\d{1,3})。

<img src="https://i.loli.net/2020/09/11/fkXdO1L2gvH7iwx.png" style="zoom:50%;" />

不幸的是，它也将匹配 *256.300.888.999* 这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：

**<font color=FF0000>(</font> <font color=aqua>(</font>2[0-4]\d <font color=fuchsia>|</font> 25[0-5] <font color=fuchsia>| </font>[01]?\d\d?<font color=aqua>)</font> \\.<font color=FF0000>)</font>{3}  <font color=aqua>(</font>2[0-4]\d <font color=fuchsia>| </font>25[0-5] <font color=fuchsia>| </font>[01]?\d\d?<font color=aqua>)</font>**

**关于分组的补充：**

- <font color=FF0000>**分组0对应整个正则表达式**</font>

- 实际上<font color=FF0000>**组号分配过程是要从左向右扫描两遍的**</font>：<mark>第一遍只给未命名组分配，第二遍只给命名组分配</mark>－－因此<font color=FF0000>所有命名组的组号都大于未命名的组号</font>

- 你可以<font color=FF0000>使用 **(?:exp)** 这样的语法来**剥夺一个分组对组号分配的参与权**</font>

  

#### **使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：**

- **捕获**
  - **(exp)**：匹配exp,并捕获文本到自动命名的组里
  - **(?\<name>exp)**：匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
  - **(?:exp)**：匹配exp,不捕获匹配的文本，也不给此分组分配组号
- **零宽断言**
  - **(?=exp)**：匹配exp前面的位置
  - **(?<=exp)**：匹配exp后面的位置
  - **(?!exp)**：匹配后面跟的不是exp的位置
  - **(?<!exp)**：匹配前面不是exp的位置
- **注释**
  - **(?#comment)**：这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读



#### 反义

有时需要<font color=FF0000>查找不属于某个能简单定义的字符类的字符</font>。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到**反义**：

|  代码/语法   |                             说明                             |
| :----------: | :----------------------------------------------------------: |
|    **\W**    | 匹配<font color=FF0000>任意**不是**字母，数字，下划线，汉字的字符</font> |
|    **\S**    |    匹配<font color=FF0000>任意**不是**空白符的字符</font>    |
|    **\D**    |      匹配<font color=FF0000>任意**非**数字的字符</font>      |
|    **\B**    |  匹配<font color=FF0000>**不是**单词开头或结束的位置</font>  |
|   **[^x]**   |    匹配<font color=FF0000>**除了**x以外的任意字符</font>     |
| **[^aeiou]** | 匹配<font color=FF0000>**除了**aeiou这几个字母以外的任意字符</font> |

<font color=FF0000>**注意：反义的代码就是「正义」字符的小写变成大写。**</font>

**示例：**

- `\S+`：匹配不包含空白符的字符串（由于加上了可重复1次或者多次的`+`，所以由字符变成了字符串）。

- `<a[^>]+>`：匹配用尖括号括起来的以a开头的字符串。



#### 后向引用

使用小括号指定一个子表达式后，<font color=FF0000>**匹配这个子表达式的文本**</font>(也就是此分组捕获的内容)<font color=FF0000>可以在（父？）表达式或其它程序中作进一步的处理</font>。默认情况下，每个分组会自动拥有一个**组号**，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。

**后向引用**用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。

示例：**\b(\w+)\b \s+\1\b**可以用来匹配重复的单词，像*go go*, 或者*kitty kitty*。这个表达式<font color=FF0000>首先是一个单词</font>，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，<font color=FF0000>这个单词会被捕获到编号为1的分组中</font>，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。

你<font color=FF0000>也可以自己指定子表达式的**组名**</font>。<font color=FF0000>要指定一个子表达式的组名，请使用这样的语法：**(?\<Word>\w+)**</font>（<font color=FF0000>或者把尖括号换成'也行：**(?'Word'\w+)**</font>），<font color=FF0000>这样就把\w+的组名指定为Word了</font>。<font color=FF0000>要**反向引用**这个分组**捕获**的内容，你可以使用\k\<Word></font>，所以上一个例子也可以写成这样：\b<font color=FF0000>(?\<Word>\w+)</font>\b\s+<font color=FF0000>\k\<Word></font>\b。

另外，<font color=FF0000>**(?:exp)**</font>不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。



#### 零宽断言

接下来的四个用于<font color=FF0000>查找在某些内容（但并不包括这些内容）**之前**或**之后**的东西</font>，也就是说它们像`\b`、`^`、 `$`那样用于指定一个位置，<font color=FF0000>这个位置应该满足一定的条件（即断言）</font>，因此它们也被称为**零宽断言**。最好还是拿例子来说明吧：





摘自：[正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm#negation)

