#  linux & macOS 备忘录



### macOS 快捷键

#### 基础键

- **⌘ : Command** <font color=FF0000>**Option键在键盘映射中相当于windows中的win键 / meta键**</font>
- **⇧ : Shift**
- **⌥ : Option** <font color=FF0000>**Option键在键盘映射中相当于windows中的Alt键**</font>
- **⌃ : Control** <font color=FF0000>**Control键在键盘映射中相当于windows中的Ctrl键**</font>
- **⏎ / ⌅ : Return / Enter**
- **⇪ : caps lock**
- **⎋ : Escape (Esc)**
- **␣ : Space**
- **⌫ : Delete**
- **⌦ : 向前删除键（Fn+Delete）**
- **↑ : 上箭头**
- **↓ : 下箭头**
- **← : 左箭头**
- **→ : 右箭头**
- **⇞ : Page Up（Fn+↑）**
- **⇟ :  Page Down（Fn+↓）**
- **↖ / Home : ( Fn + ←)**
- **↘ / End : (Fn + →)**
- **⇥ : 右制表符（Tab键）**
- **⇤ : 左制表符（Shift+Tab）**
- **⏏︎ : eject 介质推出键**

#### 快捷键

- **⌘ + Z 撤销**
- **⇧ + ⌘ + Z 反撤销**

- **␣ 向下翻页**

- **⇧ + ␣ 向上翻页**

- **⌘ + ← 移动到光标所在行首**
- **⌘ + → 移动到光标所在行尾**
- **⌘ + ⌫: 删除至行首**

- **⌥ + ← 移动到光标所在前一个单词**
- **⌥ + → 移动到光标所在后一个单词**
- **⌥ + ⌫  删除一个单词**

- **⌥ + F3 显示dock**
- **⌘ + ` 同一应用间切换界面**

- **⇧ + ⌘ + G (Finder中使用)前往路径**

- **⌃ + ⌘ + F 最大化应用/ 取消**

- **⌃ + ⌘ + ␣  打开“字符检视器”**

- **⇧ + ⌘ + ␣ + 4 截取特定窗口**

- **⇧ + ⌘ + ⌃ + 4 截取的图片直接放到剪切板中**

##### 输入法相关

- **⌃ + ⇧ + ⌘ + C 简体转换为繁体（似乎无效…）**

- **⌃ + ⌥ + ⇧ + ⌘ + C 繁体转换为简体**

- **⌃ + ⌥ + ␣ 切换输入法**

##### 特殊字符

- **⇧ + ⌥ + 9 / 英文输入法下⎋下面的一个键    打出欧美姓名中的圆点 ·**
- **⇧ + ⌥ + K 打出**

##### 在浏览器之类的app选中文本

- **三指选中当前词语**
- **⇧ + ⌥ + ← / →  ：向前向后以词为单位选中文本**    

- **⇧ + ⌥ + ↑ / ↓ ：向上向下以行为单位选中文本**



##### ⌘ + ␣ 

- **短按：**spotlight
- **长按：**呼出 / 关闭 Siri



##### 查单词

- **单指长按 / 三指按住：**在官方应用中调出字典查词

- **⌃ + ⌘ +D：**在非官方应用中打开字典查词，如下所示：

  <img src="https://s1.ax1x.com/2020/10/28/B3xx7F.png" style="zoom: 45%;" />

- 在 spotlight 中查词，不过：可能所查单词不在第一个选项中：如下所示。只需要按下 **⌘ + L** 即可将光标移动到字典选项处

  |                          开始                          |                   使用**⌘ + L**选中                    |
  | :----------------------------------------------------: | :----------------------------------------------------: |
  | ![](https://i.loli.net/2020/10/28/HXsaGPgTZry2L5e.png) | ![](https://i.loli.net/2020/10/28/arEv7TKuqQRZj9g.png) |

- 使用**⌥ + ⎋**以读单词



##### ⌃ + 方向键

- **⌃ + ←：相当于四指滑动的左滑，前往左侧的页面**
- **⌃ + →：相当于四指滑动的右滑，前往右侧的页面**
- **⌃ + ↑：相当于四指滑动的上滑，显示所有页面，以及当前页面所有应用**
- **⌃ + ↓：相当于四指滑动的下滑，显示当前页面所有的此应用**



##### Chrome 相关

- **⌥ + ⌘ + I：打开/ 关闭 Developer Tools**
- **⌥ + ⌘ + J：打开 / 关闭 Developer Tools 并进入控制台**
- **⇧ + ⌘ + C： 打开 检查元素**
- **⇧ + ⌘ + P：**在控制台时，按下，会出现命令菜单 ( Command Menu )，类似于 Mac 的 spotlight



##### 更多快捷键，请参看设置中的键盘选项

<img src="https://s1.ax1x.com/2020/09/02/wpQmKP.png" style="zoom:45%;" />



### Mac 使用



#### Spotlight 使用

##### 快捷键

- ⌘ + R ：搜索文件名，打开光标出的文件所在文件夹。

  > 💡其他方法：
  >
  > - 按住 ⌘ ，并用光标选择文件；可以进入文件所在的文件夹。
  >
  >   另外，按住 ⌘ ，就会在 spotlight 中展示文件的路径
  >
  > - 按下 ⌘ + ⏎ 

- ⌘ + L ：查单词，详见  [[#查单词]]

##### 类型查找

###### 前缀搜索

- `author:` ：文件作者

- `comment:` ：文件备注

- `created:` ：文件创建日期

- `date:` ：文件日期

  > 当您使用 Mac 多年时，有意义的是在特定日期范围内搜索文件。这将很容易地帮助您在指定日期内过滤所需的文件。您可以通过以下方式使用 “date:” 关键字根据日期进行过滤：
  >
  > - 日期：今天
  > - 日期：昨天
  > - 日期：2020/6/29
  > - 日期：2020/6 / 4-2020 / 6/29
  >
  > 确保根据Mac使用正确的日期格式。如有疑问，请在“日期和时间”偏好设置部分检查正确的日期格式。
  >
  > 摘自：[Mac新手用户需要了解的14个Spotlight搜索技巧](https://zhuanlan.zhihu.com/p/151785840) 

- `filename:` ：文件名称

- `from:` ：从 ... 寄来的邮件

- `subject:` ：标题是 ... 的邮件

- `intext:` ：包含的 ... 字样的文件内容

- `kind:` ：文件的种类

  > <font color=dodgerBlue>**如果你想通过文件类型进行查找**</font>：可以在 Spotlight 中输入 “kind:(file type)” ，这里的 “file type” 可以是 “image”、“moive”、“music”、“email”、“application”、“text”、“archive” 等。
  >
  > > 💡 还有 “bookmark” 、“app”
  >
  > <font color=dodgerBlue>**如果想通过文件格式进行查找**</font>：就在 Spotlight 中输入 “kind:(file format)”，这里 “format” 可以是 “jpeg”、“gif”、“pdf”、“mp3”、“mp4”、“zip” 等等。比如你想查找 pdf 文件，就在 Spotlight 中输入 “kind:pdf” ，之后 Spotlight 就会列出最近使用过的 pdf 文件，点击下面的 “在Finder中显示全部” 就可以在 Finder 中打开所有的 pdf 文件。
  >
  > 摘自：[Spotlight--Mac上的查询利器 - 李宇的文章 - 知乎](https://zhuanlan.zhihu.com/p/29796308)

- `label:` ：标签的颜色

- `modified:` ：文件最后更新的日期

###### 条件搜索

- AND ：搜索包含 ... 和 ... 

- AND NOT ：搜索包含 ... 但不包含 ... 

- NOT ：搜索不包含 ... 

  > 💡 可以使用 “-” 替代（和搜索引擎中的用法一致）
  >
  > 了解自：[Mac新手用户需要了解的14个Spotlight搜索技巧](https://zhuanlan.zhihu.com/p/151785840) 的 “13.不包括在Spotlight中”

- OR ：搜索包含 ... 或 ...

摘自：[身為 Mac 用戶，你不可不知道的 24 個 Spotlight 搜尋技巧！](https://mrwuli.com/mac-spotlight-tips/)

> 💡 值得补充的是：
>
> 上面所说的搜索条件，在 finder 的搜索框中同样可用。如下示例：输入 “filename: frontend AND kind:image”，搜到了一张名为 frontend-demo 的 gif。
>
> <img src="https://s2.loli.net/2023/03/08/oUW8HYhdzjlQk6y.png" alt="image-20230308225440510" style="zoom:50%;" />





##### Mac 软件推荐

[Awesome Mac](https://wangchujiang.com/awesome-mac/README-zh.html)



##### 修改终端用户名

```sh
sudo scutil --set HostName yourTargetName
```

##### cd 命令，在命令行中进入查找输出的地址，如：

```bash
#方法一
cd `brew --prefix go`
#方法二
cd $(brew --prefix go)
```

##### 创建文件夹并进入该文件夹

```sh
mkdir folder-name && cd $_
```

这里的 `&&` 和 `$_`下面都有解释。

##### 类似的：`open` 命令

```bash
open `brew --prefix go`    #打开软件
open folder                #在访达中打开文件夹
open folder/fileName.filetype     #打开默认的打开方式打开文件（如pdf）
```



#### open 命令

##### 使用默认应用打开<font color=FF0000>指定</font>文件

```sh
open fileName
```

##### 使用默认应用打开<font color=FF0000>一批（对应规则的）</font>文件

```sh
open *.fileType
```

##### 用<font color=FF0000>指定的应用程序</font>来打开<font color=FF0000>指定</font>的文件

```sh
open -a appName fileName
```

##### 用系统<font color=FF0000>默认的文本编辑器</font>来打开指定的<font color=FF0000>文本文件</font>

```sh
open -e txtFileName
```

##### 使用<font color=FF0000>默认对应的文本编辑器</font>打开文件

```sh
open -t fileName
```

##### 打开文件， 如果是macOS则使用Finder打开文件夹

```sh
open foldName
open .
```

##### 打开<font color=FF0000>文件所在文件夹</font>

```sh
open -R fileName
```

##### 打开某个url，注意：要加上 `http://` 或 `https://`

```sh
open https://url
```

摘自：[用open命令实现从终端到可视化界面的切换](https://www.jianshu.com/p/10395015ebc8)



#### mdfind 命令

mdfind 命令是 Spotlight 的终端界面，所以如果 Spotlight 被禁用的话，mdfind 命令也会无法使用。

mdfind 命令查找文件比 Spotlight 还要快，其基本用法如下：

```bash
mdfind -name queryFileName
```

如果要查找包含某些文本的文件，则可以输入如下命令；这样就会查找所有包含 John 的文件。

```text
mdfind "John"
```

mdfind 命令还可以通过 `-onlyin` 参数搜索特定文件夹的内容，比如

```bash
mdfind -onlyin ~/Library queryTxt
```

摘自：[Mac中用mdfind命令快速查找文件 - 东东来了的文章 - 知乎](https://zhuanlan.zhihu.com/p/86138761)



#### Homebrew 使用

Homebrew 是使用 ruby 开发的 Mac的软件包管理器

Homebrew 安装软件时将会<font color=FF0000>自动下载各种依赖</font>，这一点非常方便。

##### 命令列表

|     操作     | 命令 |
| :----------- | :--- |
| <font color=FF0000>更新Homebrew</font> |  `brew update`  |
| 查看Homebrew版本，及brew/cask状况 | `brew -v` |
|   <font color=FF0000>更新**所有**安装过的</font>软件包   | `brew upgrade` |
| <font color=FF0000>更新**指定**的</font>软件包 | `brew upgrade wget` |
| <font color=FF0000>查找</font>软件包 | `brew search wget` |
| <font color=FF0000>安装</font>软件包 | `brew install wget` |
| <font color=FF0000>卸载</font>软件包 | `brew uninstall wget` |
| <font color=FF0000>列出已安装</font>的软件包 | `brew list` |
| <font color=FF0000>查看</font>软件包<font color=FF0000>信息</font> | `brew info wget` |
|   <font color=FF0000>列出</font>软件包的<font color=FF0000>依赖关系</font>   | `brew deps wget` |
| 查看安装的扩展列表 | `brew tap` |
| <font color=FF0000>列出可以更新的</font>软件包 | `brew outdated` |
| <font color=FF0000>Homebrew不会自动移除旧版本的软件包</font>，移除旧版本软件包 | `brew cleanup` |
| 查看哪些软件包要被清除 | `brew cleanup -n` |
| 清除n天前的缓存（默认n=14） | `brew cleanup --prune n` |
| 查看Homebrew安装位置 | `brew --prefix` |
| 查看软件包在Homebrew中安装的位置 | `brew --prefix wget` |
| 查看 brew 配置 | `brew config` |

##### brew list 命令补充

上面表格中提到了 `brew list` 作用是 “列出已安装的软件包”，不过 `brew list` 后面也是可以添加参数的，比如 brew 安装的应用名称，通过该命令 可以确定应用的安装位置。如下：

<img src="https://s2.loli.net/2022/08/21/XCA9ptgIS4Wq6vK.png" alt="image-20220821190046643" style="zoom:50%;" />

另外，通过通过 `brew info appName` 也可以得到 安装路径

<img src="https://s2.loli.net/2022/08/21/dMJSzWKNnparyFw.png" alt="image-20220821193622196" style="zoom:50%;" />

学习自：[Mac下获取Homebrew安装的软件路径](https://juejin.cn/post/6844903561705291789)

##### 关于 taps ( third-party-repositories )，相关命令：`brew tap`

brew tap可以为brew的软件的 跟踪, 更新, 安装添加更多的的`tap formulae`

如果你在核心仓库没有找到你需要的软件,那么你就需要安装第三方的仓库去安装你需要的软件

tap命令的仓库源默认来至于Github，但是这个命令也不限制于这一个地方

- **brew tap** 

  没有参数会自动更新已经存在的`tap`并列出当前已经`tapped`的仓库

- **brew tap \<user>/\<repo>** 

  在本地对这个 `https://github.com/user/repo` 仓库上做了一个浅度的克隆，完成之后 `brew` 就可以在这个仓库包含的 `formulae`上工作，好比就在 `Homebrew` 规范的仓库，你可使用 `brew install` 或者 `brew uninstall `安装或者卸载这个仓库上的软件。当你执行 `brew update` 这个命令时，`tap` 和 `formulae` 就会自定更新

- **brew tap \<user>/\<repo> URL** 

  在本地对这个 `URL` 仓库上做了一个浅度的克隆,和上面一个参数命令是不一样的,`URL`没有默认关联到`Github`,这个`URL`没有要求必须是 `HTTP` 协议，任何位置和任何协议而且**Git**也是能很好的处理的

- **brew untap \<user>/\<repo> [\<user>/\<repo> \<user>/\<repo> ...]**

  移除已经安装的`tap`。这个仓库被删除，`brew` 就不在可用在这个仓库的 `formulae`。可以同时删除几个仓库

**仓库命名的规范**

- 在 `Github`上,你的仓库名称必须是`homebrew-something`,为了使用一个参数的`brew tap`命令,`homebrew-`这个前缀不是可选的,是必须的。
  对于两个参数的`brew tap`命令没有这个限制,但是必须给出明确的全部的`URL`地址
- 当你在命令行使用`brew tap`时，你可以省略 `homebrew-` 这个前缀的

也就是说:`brew tap username/foobar `是作为长版本 `brew tap username/homebrew-foobar` 使用的一个简写。**`brew` 可以自己添加 `homebrew-` 前缀的在需要的时候**

摘自： [homebrew的tap功能详解](https://segmentfault.com/a/1190000012826983)

##### brew link

对于homebrew管理的应用上来说，在安装后可能表现为：不能识别该命令；这些问题实际上是很fatal的，会导致一系列的后续错误。

摘自：[深入理解brew link命令](https://blog.csdn.net/weixin_33730836/article/details/86400319)

`brew link` creates symlinks to installations you performed manually in `Cellar`. This allows you to have the flexibility to install things on your own but still have those participate as dependencies in `homebrew` formulas.

摘自：[stack overflow - What does “brew link” do?](https://stackoverflow.com/questions/33268389/what-does-brew-link-do)

##### brew 信息搜索

可以使用 `brew search` 搜索 brew 中的软件，也可以使用 `brew info` 查看软件的信息。

除了上面的方法之外，还可以通过访问 [Homebrew Formulae](https://formulae.brew.sh) 在网页端进行搜索。

##### brew service

// TODO 可以参考下 [使用brew services管理服务](https://www.jianshu.com/p/6c3b26490861) ，其中提及了 Mac 的 `launchctl` 加载开机自动运行的服务的命令



#### Mac 用命令行进行设置

##### Mac 自带截图，如何去除影印

```sh
# 去阴影
defaults write com.apple.screencapture disable-shadow -bool TRUE
# 有阴影
defaults write com.apple.screencapture disable-shadow -bool FALSE
```

##### 更多的设置

更多的设置，参见：https://github.com/mathiasbynens/dotfiles/blob/main/.macos



#### macOS 清理 DNS 缓存

```sh
sudo killall -HUP mDNSResponder
```



#### macOS 重启音频服务

有的时候（间隔半年左右），Mac 会出现 没有声音的情况，这时候运行如下命令即可：

```sh
sudo killall coreaudiod
```



### Linux 相关

#### 相关资料

[Linux commands chect sheet - pdf](https://phoenixnap.com/kb/wp-content/uploads/2021/11/linux-commands-cheat-sheet-by-pnap.pdf)

[Linux大神都是怎么记住这么多命令的？ - 知乎](https://www.zhihu.com/question/452895041)

RUNOOB Linux 命令总结：[Linux 命令大全](https://www.runoob.com/linux/linux-command-manual.html)



#### Linux 命令缩写由来

- ls: list
- rm: remove 
- mkdir: make directory
- mkfs: make filesystem
- mknod: make node
- chown: change owner
- cp: copy
- insmod: install module 
- lsmod: list modules
- rmmod: remove module
- env: environment 
- cat: concatenate
- gcc: GNU Compiler Collection
- man: manual
- ps: processes
- pwd: print working directory
- ifconfig: interface configuration
- sync: synchronize
- tty: teletypewriter

//TODO 还有更多

https://web.archive.org/web/20160812022408/https://www.zhihu.com/question/49073893/（原链接被删除了...只找到了 archive）



#### double dash : `--`

##### 问了下 new bing ，得到如下答案

<img src="https://s2.loli.net/2023/03/15/kSocVDZ42KOWJ9j.png" alt="image-20230308005044277" style="zoom:50%;" />

有点点 类似于转义。



#### Linux 命令行 flags、switches、options 区别

> 👀 由于在中文网中没有搜索到解答，甚至感觉完全混为一谈；英文网中没找到找到权威的解答，且解答与解答间相互矛盾...所以，<font color=fuchsia>**当前的笔记，<font size=4>只供参考</font>**</font>

##### 关于 flags & switches

先说总结（从下面引用得来）的结论：switches （开关）更多表示一种状态：表示 启用什么或关闭什么，后面不跟参数 ( arguments )；而 flag 后面跟参数，flag 表示 键值对的“键”，后面的参数即 键值对的“值”。

> According to [Build Awesome Command-Line Applications in Ruby 2](https://rads.stackoverflow.com/amzn/click/com/1934356913) the main distinction is : <font color=dodgerBlue>**a `switch` doesn't take arguments, while a `flag` does**</font>. Quoting directly from the book (page 15):
>
> <img src="https://s2.loli.net/2022/07/23/ibSmXh1Ua6FtYkQ.png" alt="enter image description here" style="zoom: 43%;" />
>
> Typically, if a switch is in the long-form (for example `--foo` ) , which turns “on” some behavior, there is also another switch preceded with `no-` (for example `--no-foo`) that turns “off” the behavior.
>
> Finally, long-form flags take their argument via an equal sign, whereas in the short form of a flag, an equal sign is typically not used.For example, the `curl` command, which makes HTTP requests, provides both short-form and long-form flags to specify an HTTP request method: `-X` and `--request`, respectively. The following example invocations show how to properly pass arguments to those flags:
>
> ```sh
> curl -X POST http://www.google.com
> curl --request=POST http://www.google.com
> ```
>
> 摘自：[Is there a difference between a command line flag and a command line option?](https://superuser.com/questions/1070059/is-there-a-difference-between-a-command-line-flag-and-a-command-line-option)

另外，options 是 flag 的总称？参考：https://developpaper.com/question/how-to-distinguish-arguments-flags-options-from-the-command-line/



#### 切换到 root 用户模式

```bash
sudo su
sudo -i  # 进入root目录
su root # 存疑

# 退出管理员模式
exit
```



#### 打开外接存储设备

进入根目录，进入Volume文件夹，这里存放所有外接存储设备



#### bc命令（Basic Calculator）

开启一个CLI下的计算器，同时：按下quit以退出。如下示图：

<img src="https://i.loli.net/2020/10/26/z8nFIPWBCyDaef9.png" alt="BuATWn.png" style="zoom:50%;" />



#### echo 命令

```bash
# >> 表示在文件末尾追加命令
echo 'add content'>>filename

# > 表示删除原有内容，并添加
echo 'add content'>filename
```



#### rm 命令

##### 删除文件

```bash
rm -f fileName  # -f表示强行删除
```

##### 删除文件夹

```bash
rm -rf folderName # -r表示递归，-f表示强行删除
```



#### file 命令

使用 `fiel -I fileName.ext` 命令，可以查看文件的 MIME 格式 和 编码格式。示例如下：

<img src="https://s2.loli.net/2022/03/24/eKQnYp4H2c3PGqd.png" style="zoom:65%;" />



#### 管道 与 |

##### Pipeline 定义

在 类Unix 操作系统（以及一些其他借用了这个设计的操作系统，如 Windows ）中，<font color=fuchsia>管道 ( Pipeline ) 是一系列 将 <font size=4>**标准输入输出**</font> 链接起来的 <font size=4>**进程**</font></font>，其中<font color=fuchsia>每一个进程的输出被直接作为下一个进程的输入</font>（ 👀 `|` 两边都是进程。如果 `|` 右边改成一个 txt 文件，将会报错，因为它不是一个进程。这也是 `|` 和`>` 一个很大的区别）。 <font color=red>**每一个链接都由匿名管道实现**</font>。管道中的组成元素也被称作过滤程序。

这个概念是由道格拉斯·麦克罗伊为 Unix 命令行发明的，因与物理上的管道相似而得名。

##### | 的用法

这个特殊的 `|` 字符告诉命令行解释器 ( Shell ) <font color=FF0000>**将前一个命令的输出通过“管道”导入到接下来的一行命令作为输入**</font>。

摘自：[wiki - 管道 (Unix)](https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix))



#### 重定向

在计算机领域，**重定向** 是大多数命令行解释器所具有的功能，包括各种可以将标准流重定向用户规定地点的 Unix shells。类 Unix 操作系统的程序可以透过 `dup2(2)` 系统调用完成重定向，或者透过缺少一些灵活性但是更高一级层次的 `freopen(3)` 和 `popen(3)` 来完成。

##### 重定向标准输入输出

重定向一般透过在命令间插入特定的符号来实现。特别的，<font color=dodgerBlue>这些符号的语法如下所示</font>：

```bash
command1 >file1
```

上面这个命令执行 `command1` 然后将输出的内容存入 `file1` 。注意<font color=red>任何 `file1` 内的已经存在的内容将被新内容替代</font>（ 👀 覆盖）。如果<font color=fuchsia>要将新内容添加在文件末尾，请使用 `>>` 操作符</font>。

```
command1 <file1
```

执行 `command1` ，使用 `file1` 作为用来替代键盘的输入源。

```
command1  <infile > outfile
```

同时替换输入和输出，执行 `command1` ，从文件 `infile` 读取内容，然后将输出写入到 `outfile` 中。

摘自：[wiki - 重定向 (计算机)](https://zh.wikipedia.org/wiki/%E9%87%8D%E5%AE%9A%E5%90%91_(%E8%AE%A1%E7%AE%97%E6%9C%BA))



#### `&` , `;` , `&&` ,  `||` , `()` , `{}`

<font size=4>**`&`**</font> 命令<font color=FF0000>**同时**执行</font>（并发）

```sh
command1 & command2 & command3   
```

<font size=4>**`;`**</font> <font color=FF0000>**不管**前面命令执行成功没有，后面的命令**继续执行**</font>

```sh
command1; command2; command3
```

<font size=4>**`&&`**</font> <font color=FF0000>**只有**前面命令执行成功，后面命令**才继续执行**</font>（继发）

```sh
command1 && command2 [&& command3 ...]
```

- 命令之间使用 && 连接，实现逻辑与的功能。

- 只有在 && 左边的命令返回真（命令返回值 $? == 0），&& 右边的命令才会被执行。

- 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。

<font size=4>**`||`**</font> 如果<font color=FF0000>前面的命令**没有执行成功**</font>，<font color=FF0000>后面的命令**就开始执行**</font>

```sh
command1 || command2 [|| command3 ...]
```

- 命令之间使用 || 连接，实现逻辑或的功能。

- 只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。

- 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。

<font size=4>**`()`**</font>  为了在当前shell中执行一组命令，可以用命令分隔符(即",")隔开每一个命令，并把所有的命令用圆括号()括起来。

```sh
(command1; command2; command3 [; ...] )
```

- 一条命令需要独占一个物理行，如果需要将多条命令放在同一行，命令之间使用命令分隔符`;`分隔。执行的效果等同于多个独立的命令单独执行的效果。

- <font color=FF0000>`()` 表示在当前 shell 中**将多个命令作为一个整体执行**</font>。<font color=LightSeaGreen>需要注意的是，使用 `()` 括起来的命令在执行前面都不会切换当前工作目录，也就是说命令组合都是在当前工作目录下被执行的，尽管命令中有切换目录的命令</font>。

- 命令组合常和命令执行控制结合起来使用


<font size=4>**`{}`**</font> 如果使用`{}`来代替`()`，那么相应的命令将在子shell而不是当前shell中作为一个整体被执行，只有在{}中所有命令的输出作为一个整体被重定向时，其中的命令才被放到子shell中执行，否则在当前shell执行。

```bash
{ command1; command2; command3 [; ...] }
```

<font color=FF0000>**注意：**在使用{}时，{}与命令之间必须使用一个空格</font>

摘自：[Linux 命令行 &&与||](https://www.jianshu.com/p/25b0d6c9dc9f)

**//todo**

**花括号扩展（Brace expansion）**



#### Shell 变量

Shell 变量分为 环境变量（全局变量）和 普通变量（局部变量）

// TODO 下面研究下：环境变量、和特殊变量的关系、set env export 命令。由于还有更重要的事情，这里等等再说。



#### Shell 特殊变量

#####  `$0` , `$#` , `$*` , `$@` , `$?` , `$$` , `$!` , `$_` 和命令行参数 `$n`

变量名只能包含数字、字母和下划线，因为<font color=FF0000>某些包含其他字符的变量有特殊含义，这样的变量被称为**特殊变量**</font>。

- **\$0 ：** <font color=FF0000>**获取**</font>当前执行<font color=FF0000>脚本的**文件名**包括**路径**</font>
  
  - **dirname \$0 ：**  <font color=FF0000>只取</font>当前执行脚本的<font color=FF0000>路径</font>
  - **basename \$0 ：**  <font color=FF0000>只取</font>当前执行脚本<font color=FF0000>文件名</font>
  
- **\$# ：**获取执行命令行(脚本)<font color=FF0000>参数的总个数</font>

- **\$@ ：** 获取这个执行程序的<font color=FF0000>所有参数</font>

- **\$* ：** 获取当前shell 的所有参数（注意与\$\$@区别）

- **\$! ：** 获取<font color=FF0000>**上一个**执行命令的**PID**</font>

- **\$\$ ：** 获取<font color=FF0000>**当前**shell的**PID**</font>

- **\$\_ ：** 获取<font color=FF0000>在此**之前执行**的命令或者脚本的**最后一个参数**</font>

- **\$? ：** 获取<font color=FF0000>**上一个**命令的**退出状态**</font>

  所谓<font color=FF0000>退出状态</font>，就是<font color=FF0000>上一个命令执行后的返回结果</font>。退出时**返回值的表示含义如下**：

  - **0**： 表示运行成功
  - **2** ：权限拒绝
  - **1~125**： 表示运行失败，脚本命令、系统命令或者参数传递错误
  - **126** ：找到了该命令，但是无法执行
  - **127** ：未找到要运行的命令
  - **128** ：命令被系统强制结束

- **\$n ：** <font color=FF0000>传递给脚本或函数的参数</font>。n 是一个数字，表示第几个参数。例如，第一个参数是 `$1` ，第二个参数是 `$2` 。

##### `$*` 和 `$@` 的区别

`$*` 和 `$@` 都表示传递给函数或脚本的所有参数，不被双引号`" "`包含时，都以 `$1` ，`$2` … `$n` 的形式输出所有参数。

但是当它们被双引号`" "`包含时，<font color=FF0000>**`$*`** </font>会将<font color=FF0000>所有的参数作为一个整体</font>，以 <font color=FF0000>`$1`，`$2` … `$n` 的形式输出所有参数</font>；<font color=FF0000>**`$@`** </font>会将<font color=FF0000>各个参数分开</font>，以<font color=FF0000> `$1`，`$2` … `$n` 的形式输出所有参数</font>。

摘自：[Shell特殊变量： \$0, \$#, \$*, \$@, \$?, \$$, \$!,\$_和命令行参数\$n](https://blog.csdn.net/w746805370/article/details/51044352)

##### `!$`

>  `!$` refers to the last argument from the previous bash command.  	
>
> **翻译：!$表示：上一条bash命令的最后一个参数**

摘自：[stack overflow - What does ./!\$ mean in Linux?](https://stackoverflow.com/questions/38515790/what-does-mean-in-linux)



#### tree 命令

##### 最常用的两个规则

- **tree -L N**  查看文件夹的树状结构，最多深入N层
- **-a**               显示所有文件和目录（包括隐藏文件）

##### 更详细的

- <font color=FF0000>**-a**</font>   显示所有文件和目录。
- **-A**   使用ASNI绘图字符显示树状图而非以ASCII字符组合。
- <font color=FF0000>**-C**</font>   在文件和目录清单<font color=FF0000>加上色彩</font>，便于区分各种类型。
- <font color=FF0000>**-d**</font>   <font color=FF0000>显示目录名称而非内容</font>。
- <font color=FF0000>**-D**</font>   <font color=FF0000>列出文件或目录的更改时间</font>。
- **-f**   在每个文件或目录之前，显示完整的相对路径名称。
- **-F**   在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/”,”=”,”@”,”|”号。
- **-g**   列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。
- **-i**   不以阶梯状列出文件或目录名称。
- **-I**   <范本样式> 不显示符合范本样式的文件或目录名称。
- **-l**   如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。
- **-n**   不在文件和目录清单加上色彩。
- **-N**   直接列出文件和目录名称，包括控制字符。
- <font color=FF0000>**-p**</font>   <font color=FF0000>列出权限标示</font>。
- **-P**   <范本样式> 只显示符合范本样式的文件或目录名称。
- **-q**   用”?”号取代控制字符，列出文件和目录名称。
- <font color=FF0000>**-s**</font>   <font color=FF0000>列出文件或目录大小</font>。
- **-t**   用文件和目录的更改时间排序。
- <font color=FF0000>**-u**</font>   <font color=FF0000>列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码</font>。
- **-x** 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外

摘自：[命令行使用之tree命令](https://www.jianshu.com/p/f117be185c6f)



#### grep 命令

**grep**（ **<font color=FF0000>global</font>** search **<font color=FF0000>regular expression(RE)</font>** and **<font color=FF0000>print</font>** out the line，全面搜索正则表达式并把行打印出来）是一种强大的<font color=FF0000>文本搜索工具</font>，它<font color=FF0000>能使用正则表达式搜索文本，并把匹配的行打印出来</font>。

摘自：[linux命令大全 - grep命令](https://man.linuxde.net/grep)

##### **命令行参数**

```bash
-a / --text                                   #不要忽略二进制的数据。
-A<显示行数> / --after-context=<显示行数>        #除了显示符合范本样式的那一列之外，并显示该行之后的内容。
-b / --byte-offset                            #在显示符合样式的那一行之前，标示出该行第一个字符的编号。
-B<显示行数> / --before-context=<显示行数>       #除了显示符合样式的那一行之外，并显示该行之前的内容。
-c / --count                                  #计算符合样式的列数。
-C<显示行数> / --context=<显示行数>/-<显示行数>   #除了显示符合样式的那一行之外，并显示该行之前后的内容。
-d <动作> / --directories=<动作>               #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。
-e<范本样式> / --regexp=<范本样式>               #指定字符串做为查找文件内容的样式。
-E / --extended-regexp                        #将样式为延伸的正则表达式来使用。
-f<规则文件> / --file=<规则文件>                 #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。
-F / --fixed-regexp                           #将样式视为固定字符串的列表。
-G / --basic-regexp                           #将样式视为普通的表示法来使用。
-h / --no-filename                            #在显示符合样式的那一行之前，不标示该行所属的文件名称。
-H / --with-filename                          #在显示符合样式的那一行之前，表示该行所属的文件名称。
-i / --ignore-case                            #忽略字符大小写的差别。
-l / --file-with- matches                     #列出文件内容符合指定的样式的文件名称。
-L / --files-without-match                    #列出文件内容不符合指定的样式的文件名称。
-n / --line-number                            #在显示符合样式的那一行之前，标示出该行的列数编号。
-o / --only-matching                          #只显示匹配PATTERN 部分。
-q / --quiet/--silent                         #不显示任何信息。
-r / --recursive                              #此参数的效果和指定"-d recurse"参数相同。
-s / --no-messages                            #不显示错误信息。
-v / --revert-match                           #显示不包含匹配文本的所有行。
-V / --version                                #显示版本信息。                
-w / --word-regexp                            #只显示全字符合的列。
-x --line-regexp                              #只显示全列符合的列。
-y                                            #此参数的效果和指定"-i"参数相同。
```

摘自：[RUNOOB - Linux grep 命令](https://www.runoob.com/linux/linux-comm-grep.html)



#### ps 命令

ps 命令是 Process Status 的缩写，用来<font color=FF0000>列出系统中当前运行的那些进程</font>。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程。ps 为我们提供了进程的<font color=FF0000>一次性</font>的查看，它所提供的查看结果并不动态连续的；如果<font color=FF0000>想要动态的显示进程信息</font>，就可以使用top命令。

要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。<font color=FF0000>使用该命令可以确定：有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等</font>。总之大部分信息都是可以通过执行该命令得到的。

##### linux 上进程有 5 种状态

| 状态名称                                                     | 状态码                                        |
| :----------------------------------------------------------- | :-------------------------------------------- |
| 运行(正在运行或在运行队列中等待)                             | R 运行 runnable (on run queue)                |
| 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)         | S 中断 sleeping                               |
| 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) | D 不可中断 uninterruptible sleep (usually IO) |
| 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) | Z 僵死 a defunct (”zombie”) process           |
| 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) | T 停止 traced or stopped                      |

##### 命令参数

- `a`         ：显示所有进程
- `-a`        ：显示同一终端下的所有程序
- `-A`        ：显示所有进程
- `c`         ：显示进程的真实名称
- `-N`        ：反向选择
- `-e`        ：等于“-A”
- `e`         ：显示环境变量
- `f`         ：显示程序间的关系
- `-H`        ：显示树状结构
- `r`         ：显示当前终端的进程
- `T`         ：显示当前终端的所有程序
- `u`         ：指定用户的所有进程
- `-au`       ：显示较详细的资讯
- `-aux`      ：显示所有包含其他使用者的行程 
- `-C`        ：<命令> 列出指定命令的状况
- `--lines`   ：<行数> 每页显示的行数
- `--width`   ：<字符数> 每页显示的字符数
- `--help`    ：显示帮助信息
- `--version` ：显示版本显示

摘自：[每天一个linux命令（41）：ps命令](https://www.cnblogs.com/peida/archive/2012/12/19/2824418.html)

##### `ps [options]` 输出示例

<img src="https://i.loli.net/2020/10/26/cPDQRw63uYlG4a5.png" alt="ageYqI.png" style="zoom:55%;" />

- `USER` ：行程拥有者
- `PID` ：pid
- `%CPU` ：占用的 CPU 使用率
- `%MEM` ：占用的记忆体使用率
- `VSZ` ：占用的虚拟记忆体大小
- `RSS` ：占用的记忆体大小
- `TTY` ：终端的次要装置号码 (minor device number of tty)
- `STAT` ：该行程的状态（上面的 R S D Z T）
- `START` ：行程开始时间
- `TIME` ：执行的时间
- `COMMAND` ：执行的指令

摘自：[RUNOOB - Linux ps命令](https://www.runoob.com/linux/linux-comm-ps.html)



#### killall

Linux 系统中的 killall 命令用于杀死指定名字的进程 ( kill processes by name )。我们可以使用kill命令杀死指定进程 PID 的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用 `ps`等命令再配合 `grep` 来查找进程，而 `killall` 把这两个过程合二为一，是一个很好用的命令。

##### 命令格式

```sh
killall [参数] [进程名]
```

##### 命令参数

- `-Z`        ：只杀死拥有scontext 的进程
- `-e`        ：要求匹配进程名称
- `-I`        ：忽略小写
- `-g`        ：杀死进程组而不是进程
- `-i`        ：交互模式，杀死进程前先询问用户
- `-l`        ：列出所有的已知信号名称
- `-q`        ：不输出警告信息
- `-s`        ：发送指定的信号
- `-v`        ：报告信号是否成功发送
- `-w`        ：等待进程死亡
- `--help`    ：显示帮助信息
- `--version` ：显示版本显示

摘自：[每天一个linux命令（43）：killall命令](https://www.cnblogs.com/peida/archive/2012/12/21/2827366.html)



#### ./configure、make、make install

##### ./configure

`./configure` 是用来<font color=FF0000>检测你的安装平台的目标特征</font>的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。另外，这一步<font color=FF0000>一般用来生成 Makefile，为下一步的编译做准备</font>

##### make

`make` 是用来<font color=FF0000>编译</font>的，它<font color=FF0000>从Makefile中读取指令</font>，<font color=FF0000>然后编译</font>。

> 👀 注：<font color=red>**感觉**</font>（不确定...） makefile 之于 make，类似于 webpack.config.js 之于 webpack。

##### make install

`make install` 是用来安装的，它也<font color=FF0000>从Makefile中读取指令</font>，<font color=FF0000>安装到指定的位置</font>

摘自：[Linux 命令详解（三）./configure、make、make install 命令](https://www.cnblogs.com/tinywan/p/7230039.html)

> 👀 注：关于 make、makefile、cmake 等的区别，可以参考：[make makefile cmake qmake都是什么，有什么区别？ - 知乎](https://www.zhihu.com/question/27455963) 这里暂时不做笔记。



#### ssh 命令

- 以用户名userName连接主机IP命令如下：

  ```bash
  ssh userName@hostIP
  ```

- 如果本地用户名与远程用户名一致，登录时可以省略用户名。

  ```bash
  ssh hostIP
  ```

- SSH的<font color=FF0000>默认端口是22</font>，也就是说，你的登录请求会送进远程主机的22端口。使用<font color=FF0000>p参数</font>，可以修改这个端口。

  ```bash
  ssh -p 2222 userName@hostIP
  ```

摘自：[ssh用法及命令](https://blog.csdn.net/pipisorry/article/details/52269785)（后面还有更深层次的内容，有空看完）



#### tail 命令

tail 命令将指定的文件的<font color=FF0000>**最后部分输出（tail）**</font>到标准设备，一般是终端。即：将把某个文件的最后几行显示到终端上，如果<font color=FF0000>该文件有更新，tail会自动刷新</font>，确保你看到最新的文件内容。

**命令格式：**

```bash
tail [ -f ] [ -c Number | -n Number | -m Number| -b Number | -k Number ] [ File ]
```

**参数说明：**

- `-f`  ：同于 `--follow=descriptor` ，该参数用于<font color=FF0000>**监视File文件增长（非常重要）**</font>。
- `-F` ：等同于 `--follow=name --retry` ，根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件名，会继续追踪
- `-c` ：Number 从 Number 字节位置读取指定文件。
- `-n` ：Number 从 Number 行位置读取指定文件。
- `-m `：Number 从 Number 多字节字符位置读取指定文件，比如你的文件如果包含中文字，如果指定 `-c` 参数，可能导致截断，但使用 `-m` 则会避免该问题。
- `-b` ：Number 从 Number 表示的 512 字节块位置读取指定文件。
- `-k` ：Number 从 Number 表示的 1KB 块位置读取指定文件。
- `File` ：指定操作的目标文件名

摘自：[玩转Linux命令 tail命令详解](https://www.jianshu.com/p/ee44fe0c5bae)

另外：`tailf` 命令等同于 `tail -f -n 10`（貌似 `tail -f` 或 `-F` 默认也是打印最后10行，然后追踪文件），<font color=red>与 `tail -f` 不同的是：如果文件不增长，它不会去访问磁盘文件</font>，所以tailf特别适合那些便携机上跟踪日志文件，因为它减少了磁盘访问，可以省电



#### more 命令

more 命令，<mark>功能类似 cat</mark> ，cat 命令是整个文件的内容从上到下显示在屏幕上。 <mark>more会以<font color=FF0000>一页一页的显示</font>方便使用者逐页阅读，而最基本的指令就是<font color=FF0000>按空白键（space）就往下一页显示</font></mark>，<font color=FF0000>按 b 键就会往回（back）一页显示</font>，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。

<font color=FF0000>另外，值得注意的是：space显示下一页，b显示上一页是在linux中一个较为常见的用法，比如man命令也是这样</font>

##### 命令格式

```sh
more [-dlfpcsu] [-num] [+/pattern] [+linenum] [file...]
```

##### 命令参数

- `+num`      ：从第n行开始显示
- `-num`      ：定义屏幕大小为n行
- `+/pattern` ：在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 
- `-c`        ：从顶部清屏，然后显示
- `-d`        ：提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能
- `-f` 		    ：计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）
- `-l`        ：忽略Ctrl+l（换页）字符
- `-p`        ：通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似
- `-s`        ：把连续的多个空行显示为一行
- `-u`        ：把文件内容中的下画线去掉

##### 常用操作命令

- Enter      向下n行，需要定义。默认为1行
- ⌃ + F       向下滚动一屏
- 空格键    向下滚动一屏
- ⌃ + B      返回上一屏
- =             输出当前行的行号
- :f             输出文件名和当前行的行号
- V             调用vi编辑器
- !命令      调用Shell，并执行命令 
- q             退出more

摘自：[每天一个linux命令(12)：more命令](https://www.cnblogs.com/peida/archive/2012/11/02/2750588.html)



#### curl 和 wget

curl由于可自定义各种请求参数所以在模拟web请求方面更擅长，wget由于支持ftp和Recursive所以在下载文件方面更擅长。类比的话curl是浏览器，而wget是迅雷。

摘自：[curl和wget的区别和使用](https://www.cnblogs.com/lsdb/p/7171779.html)



#### Linux 下不同的文件类型有不同的颜色

- <font style=color:blue>蓝色</font>：表示目录;
- <font style=color:green>绿色</font>：表示可执行文件，可执行的程序;
- <font style=color:red>红色</font>：表示压缩文件或包文件;
- <font style=color:activeborder>浅蓝色</font>：表示链接文件;
- <font style=color:grey>灰色</font>：表示其它文件;
- 红色闪烁：表示链接的文件有问题了
- <font style=color:yellow>黄色</font>：表示设备文件

摘自：[linux下chmod +x的意思？为什么要进行chmod +x](https://blog.csdn.net/u012106306/article/details/80436911)



#### cat  (concatenate)

cat 命令<font color=FF0000>连接文件并打印到标准输出设备上</font>，cat 经常用来显示文件的内容，类似于下的 `type` 命令。

注意：当文件较大时，文本在屏幕上迅速闪过（滚屏），用户往往看不清所显示的内容。因此，一般用 more 等命令分屏显示。为了控制滚屏，可以按 Ctrl+S 键，停止滚屏；按 Ctrl+Q 键可以恢复滚屏。按 Ctrl+C（中断）键可以终止该命令的执行，并且返回 Shell 提示符状态。



#### wc 命令

Linux `wc` 命令用于计算字数。

利用 `wc` 指令我们可以计算文件的 Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为"-"，则 `wc` 指令会从标准输入设备读取数据。

##### 语法

```sh
wc [-clw][--help][--version][文件...]
```

##### 参数

- `-c` 或 `--bytes` 或 `--chars` 只显示Bytes数
- `-l` 或 `--lines` 显示行数
- `-w` 或 `--words` 只显示字数
- `--help` 在线帮助
- `--version` 显示版本信息

摘自：[RUNOOB - Linux wc命令](https://www.runoob.com/linux/linux-comm-wc.html)



#### Linux 权限详解

Linux 下文件的权限类型一般包括 <font color=FF0000>读，写，执行</font>。对应字母为<font color=FF0000> r、w、x</font>。

Linux 下<font color=FF0000>权限的粒度</font>有 <font color=FF0000>拥有者 、群组 、其它组</font> 三种。每个文件都可以针对三个粒度，设置不同的 r/ w/ x (读/ 写/ 执行) 权限。通常情况下，一个文件只能归属于一个用户和组， 如果其它的用户想有这个文件的权限，则可以将该用户加入具备权限的群组，一个用户可以同时归属于多个组。

##### chmod 命令语法

```bash
chmod [可选项] <mode> <file...>  # 更改文件权限
```

<font color=FF0000>**TL;DR**</font>

参数说明：

> **[可选项]**
>
> ```bash
>   -c, --changes       like verbose but report only when a change is made (若该档案权限确实已经更改，才显示其更改动作)
>   -f, --silent, --quiet  suppress most error messages  （若该档案权限无法被更改也不要显示错误讯息）
>   -v, --verbose          output a diagnostic for every file processed（显示权限变更的详细资料）
>   --no-preserve-root  do not treat '/' specially (the default)
>   --preserve-root    fail to operate recursively on '/'
>   --reference=RFILE  use RFILE's mode instead of MODE values
>   -R, --recursive  change files and directories recursively 以递归的方式对目前目录下的所有档案与子目录进行相同的权限变更
>   --help		显示此帮助信息
>   --version		显示版本信息
> ```
>
> **[mode]**  权限设定字串，详细格式如下 ：
>
> ```bash
> [ugoa...] [[+-=][rwxX]...] [,...]，
> ```
>
> 其中
> [ugoa...]
>
>     - u 表示该档案的拥有者
>     - g 表示与该档案的拥有者属于同一个群体(group)者，
>     - o 表示其他以外的人，
>     - a 表示所有（包含上面三者）且：<font color=FF0000>chmod a+x 等价于 chmod +x</font>。
>
> [+-=]
>
> - `+` 表示增加权限
> - `-`  表示取消权限
> - `=` 表示唯一设定权限。
>
> [rwxX]
>
> - r 表示可读取
> - w 表示可写入
> - x 表示可执行
> - X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。
>
> [file...]
>     文件列表（单个或者多个文件、文件夹）

##### 数字权限使用格式

**语法：**

```bash
chmod [1-7][1-7][1-7] file
# 三个数字分别对应u g o
# 即：以上命令等价于：chmod u=权限,g=权限,o=权限 file...
```

**解释：**

linux中规定 数字<font color=FF0000> 4 、2 和 1 表示读、写、执行权限</font>，即<font color=FF0000> r=4，w=2，x=1</font> 。此时其他的权限组合也可以用其他的八进制数字表示出来，如：

rwx = 4 + 2 + 1 = 7  若要同时设置 rwx (可读写运行） 权限则将该权限位 设置 为 4 + 2 + 1 = 7

rw = 4 + 2 = 6          若要同时设置 rw- （可读写不可运行）权限则将该权限位 设置 为 4 + 2 = 6

rx = 4 +1 = 5.           若要同时设置 r-x （可读可运行不可写）权限则将该权限位 设置 为 4 +1 = 5

摘自：[Linux权限详解（chmod、600、644、666、700、711、755、777、4755、6755、7755）](https://blog.csdn.net/u013197629/article/details/73608613)，另外，还有该文章还有更多内容。



#### chown

chown（英文全拼：change ownerp）命令用于设置文件所有者和文件关联组的命令。

利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 。

chown 需要超级用户 root 的权限才能执行此命令。只有超级用户和属于组的文件所有者才能变更文件关联组。非超级用户如需要设置关联组可能需要使用 chgrp 命令

##### 语法

```bash
chown [-cfhvR] [--help] [--version] user[:group] file...
```

##### 参数

- `user` : 新的文件拥有者的使用者 ID
- `group` : 新的文件拥有者的使用者组(group)
- `-c` : 显示更改的部分的信息
- `-f` : 忽略错误信息
- `-h` :修复符号链接
- `-v` : 显示详细的处理信息
- `-R` : 处理指定目录以及其子目录下的所有文件
- `--help` : 显示辅助说明
- `--version` : 显示版本

摘自：[Linux chown 命令](https://www.runoob.com/linux/linux-comm-chown.html)



#### which 命令

which 指令会在环境变量 `$PATH` 设置的目录里查找符合条件的文件

**参数：**

- `n<文件名长度>` ：指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
- `-p<文件名长度>` ：与 `-n` 参数相同，但此处的 `<文件名长度>` 包括了文件的路径。
- `-w` ：指定输出时栏位的宽度。
- `-V` ：显示版本信息。

摘自：[RUNOOB - Linux which命令](https://www.runoob.com/linux/linux-comm-which.html)



#### type 命令

The **`type`** command <font color=fuchsia>is used to describe how its argument would be translated **if used as commands**</font>. It is <font color=red>also used to find out whether it is built-in or external binary file</font>.

##### Syntax

```sh
type [Options] command-names
```

##### Options

- **-a :** This option <font color=red>is used to find out whether it is an alias, keyword or a function</font> and it <font color=red>**also displays the path of an executable, if available**</font>.

  <img src="https://s2.loli.net/2022/08/28/1DVvR2otaBlAzbL.png" alt="img" style="zoom:95%;" />

- **-t :** This option will <font color=red>display a single word as an output</font>.

  - `alias` : if command is a shell alias
  - `keyword` : if command is a shell reserved word
  - `builtin` : if command is a shell builtin
  - `function` : if command is a shell function
  - `file` : if command is a disk file

  ![img](https://s2.loli.net/2022/08/28/9Wm8Tyd34XbZpuI.png)

  > 👀 注：需要注意的是：经过测试，`-t` 选项在 zsh 环境下无法使用，在 bash 环境下是可以的。

- **-p :** This option <font color=red>displays the name of the disk file</font> which would be executed by the shell. <font color=red>It will return nothing if the command is not a disk file</font>.

  ![img](https://s2.loli.net/2022/08/28/Ub17scxIHXZwtTL.png)

摘自：[type command in Linux with Examples](https://www.geeksforgeeks.org/type-command-in-linux-with-examples/)

> 💡 **补充**
>
> 你可以用 `type 命令` 来判断这个命令到底是可执行文件、shell 内置命令还是别名。
>
> 摘自：[the-art-of-command-line / 命令行的艺术](https://github.com/jlevy/the-art-of-command-line)



#### lsof 命令

lsof ( list open files ) 是一个查看当前系统文件的工具。在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如 传输控制协议 ( TCP ) 和 用户数据报协议 ( UDP ) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。

**参数**

- `-a` ：列出打开文件存在的进程
- `-c<进程名>` ：列出指定进程所打开的文件
- `-g` ：列出GID号进程详情
- `-d<文件号>` ：列出占用该文件号的进程
- `+d<目录>` ：列出目录下被打开的文件
- `+D<目录>` ：递归列出目录下被打开的文件
- `-n<目录>` ：列出使用NFS的文件
- `-i<条件>` ：列出符合条件的进程。（4、6、协议、:端口、 @ip ）
- -p<进程号>` ：列出指定进程号所打开的文件
- `-u` ：列出UID号进程详情
- `-h` ：显示帮助信息
- `-v` ：显示版本信息



#### Unix 信号

在计算机科学中，<font color=FF0000>信号（英语：Signals）是Unix、类Unix以及其他POSIX兼容的**操作系统中进程间通讯的一种有限制的方式**</font>。它<font color=FF0000>**是一种<font size=4> 异步 </font>的通知机制，用来提醒进程一个事件已经发生**</font>。<font color=FF0000>当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，此时，**任何非原子操作都将被中断**</font>。<font color=FF0000>**如果进程定义了信号的处理函数，那么它将被执行，否则就执行默认的处理函数**</font>。

信号<font color=FF0000>类似于中断</font>，不同之处在于<font color=FF0000>中断由处理器调解并由内核处理</font>，而<font color=FF0000>信号由内核调解(可能通过系统调用)并由进程处理</font>。内核可以将中断作为信号传递给导致中断的进程(典型的例子有SIGSEGV、SIGBUS、SIGILL和SIGFPE)。

<mark>信号起源于20世纪70年代的贝尔实验室Unix，最近在POSIX标准中有所规定</mark>。

**发送信号**

- **在一个运行的程序的控制终端键入特定的组合键可以向它发送某些信号：**
  - **Ctrl-C** 发送INT信号（SIGINT）；默认情况下，这会<font color=FF0000>导致进程终止</font>
  - **Ctrl-Z** 发送TSTP信号（SIGTSTP）；默认情况下，这会<font color=FF0000>导致进程挂起</font>
  - **Ctrl-\\** 发送QUIT信号（SIGQUIT）；默认情况下，这会<font color=FF0000>导致进程终止并且将内存中的信息转储到硬盘（核心转储）</font>。
  - **这些组合键可以通过stty命令来修改**
- kill() 系统调用会在权限允许的情况下向进程发送特定的信号，类似地，kill命令允许用户向进程发送信号。raise(3)库函数可以将特定信号发送给当前进程。
- <font color=FF0000>像除数为零、段错误这些异常也会产生信号</font>（这里分别是SIGFPE和SIGSEGV，<font color=FF0000>默认都会导致进程终止和核心转储</font> ）
- 内核可以向进程发送信号以告知它一个事件发生了。例如当进程将数据写入一个已经被关闭的管道是将会收到SIGPIPE信号，默认情况下会使进程关闭。

**处理信号**

<font color=FF0000>信号处理函数可以通过 signal() 系统调用来设置</font>。如果没有为一个信号设置对应的处理函数，就会使用默认的处理函数，否则信号就被进程截获并调用相应的处理函数。<font color=FF0000>在没有处理函数的情况下，程序可以指定两种行为：忽略这个信号（SIG_IGN）或者用默认的处理函数（SIG_DFL）</font>。但是<font color=FF0000>有两个信号是无法被截获并处理的：SIGKILL和SIGSTOP</font>。

**风险**

<font color=FF0000>因为竞态条件的存在，信号的处理是有弱点的</font>。<font color=FF0000>因为信号是异步的，所以在处理一个信号的过程中，进程可能收到另一个信号（甚至是相同的信号）</font>。<mark>sigprocmask() 系统调用可以用来阻塞和恢复信号的传递。信号可以造成进程中系统调用的中断，并在信号处理完后重新开始未完成的系统调用</mark>。信号处理函数应该没有任何不想要的副作用，比如，errno的改变、信号掩码的改变、信号处理方法的改变，以及其他全局进程性质的改变。在信号处理函数内使用不可重入函数，如malloc和printf，也是不安全的。

**信号列表**

**单一UNIX规范规定了在<signal.h>中定义的信号有：**

> 备注：打星号的部分表示这是X/Open System Interfaces (XSI)扩充的部分。使用引号的文字是引用自SUS。 

- **SIGABRT 和 SIGIOT：**SIGABRT 和 SIGIOT 信号能让程序异常终止（abort）。 该信号通常是由进程自身调用 C标准函数库 的 abort() 函数来触发， 但它也可以像其它信号一样由外部发送给进程。

- **SIGALRM, SIGVTALRM 和 SIGPROF：**如果你用 setitimer 这一类的报警设置函数设置了一个时限，到达时限时进程会接收到 SIGALRM, SIGVTALRM 或者 SIGPROF。但是这三个信号量的含义各有不同，SIGALRM 计时的是真实时间，SIGVTALRM计时的是进程使用了多少CPU时间，而 SIGPROF 计时的是进程和代表该进程的内核用了多少时间。

- **SIGBUS：**总线发生错误时，进程接收到一个SIGBUS信号。举例来说，存储器访问对齐或者或不存在对应的物理地址都会产生SIGBUS信号。

- **SIGCHLD：**当子进程终止、被中断或被中断后恢复时，SIGCHLD信号被发送到进程。该信号的一个常见用法是指示操作系统在子进程终止后清理其使用的资源，而不显式调用等待系统调用。

- **SIGCONT：**SIGCONT信号指示操作系统继续(重启)先前由SIGSTOP或SIGTSTP信号暂停的进程。Unix 壳的作业控制是该信号的一个重要应用。

- **SIGFPE：**当进程执行了一个错误的算术运算时，例如被零除，信号被发送到一个进程。这可能包括整数被零除，以及整数在除结果中溢出(在C中只有INT_MIN/-1、INT64_MIN/-1和%-1会触发该行为)。注意该信号与浮点数溢出无关。

- **SIGHUP：**检测到控制中断挂起或者控制进程死亡时，进程会收到 SIGHUP。现在操作系统，该信号通常意味着使用的 虚拟终端 已经被关闭。许多 守护进程 在接收到该信号时，会重载他们的设置和重新打开日志文件（logfiles），而不是去退出程序。nohup 命令用于无视该信号。

- **SIGILL：**当进程试图执行非法、格式错误、未知或特权指令时，SIGILL信号被发送到该进程。

- **SIGINT：**当用户希望中断进程时，SIGINT信号由用户的控制终端发送到进程。这通常通过按下Ctrl+C来发送，但是在某些系统中，可以使用“DELETE”键或“BREAK”键。

- **SIGKILL：**主条目：SIGKILL。发送SIGKILL信号到一个进程可以使其立即终止(KILL)。与SIGTERM和SIGINT相不同的是，这个信号不能被捕获或忽略，接收过程在接收到这个信号时不能执行任何清理。 以下例外情况适用:

  - 僵尸进程不能被杀死，因为它们已经死了，正在等待它们的父进程来收获它们。
  - 处于阻塞状态的进程不会死亡，直到它们再次醒来。
  - init 进程是特殊的: init不接收任何它不打算处理的信号，因此它会忽略SIGKILL。[1]这条规则有一个例外，Linux 上的 init 如果被 ptrace 了，那么它是可以接收 SIGKILL 并被杀死的。
  -  处于不可中断的睡眠的进程即使发送了SIGKILL，也有可能不会终止(并释放其资源)。这是少数 Unix 系统必须重新启动才能解决临时软件问题的几种情况之一。

  当在大多数系统关闭程序中终止进程时，如果进程没有响应 SIGTERM 而自动退出，SIGKILL 是最后的手段。为了加快电脑关机过程，苹果OS X 10.6(又名雪豹)向标记自己为“clean”的进程发送SIGKILL，从而加快关机时间，而且可能不会产生任何不良影响。[4]。在 Linux 中执行 killall -9 命令具有类似不过更危险的效果；它不让程序保存未保存的数据。

- **SIGPIPE：**当一个进程试图写入一个没有连接到另一端进程的管道时，SIGPIPE信号会被发送到该进程。

- **SIGPOLL：**当一个事件发生在一个正在显式监视的文件描述符上时，就会发送SIGPOLL信号。有效使用这种用法可以进行异步 I/O，因为内核将代替调用者轮询描述符。它提供了主动轮询的替代方案。

- **SIGRTMIN 到 SIGRTMAX：**SIGRTMIN至SIGRTMAX信号用于用户自定义的目的。它们是实时信号。

- **SIGTTIN 和 SIGTTOU：**当进程在后台试图分别从tty读取或写入时，SIGTTIN和SIGTTOU信号会被发送到该进程。通常，这些信号仅由作业控制下的进程接收；守护进程没有控制终端，因此永远不会接收这些信号。

- **SIGQUIT：**当用户在进程的控制终端请求退出进程并进行核心转储时，SIGQUIT信号会被发送到该进程。

- **SIGSEGV：**当进程试图访问无效内存引用时发生存储器区块错误，SIGSEGV信号会被发送到该进程。

- **SIGSTOP：**当操作系统暂停进程的运行时，会产生SIGSTOP信号。SIGSTOP信号无法被捕获或无视。

- **SIGSYS：**当系统调用时传入非法的参数，会产生SIGSYS信号。实际上，SIGSYS信号很少会出现，因为应用程序依赖库调用系统调用。SIGSYS可以被违反Linux Seccomp安全规则的应用程序捕获。SIGSYS也可用于模拟外部系统调用，例如：在Linux上模拟 Windows系统调用。

- **SIGTERM：**当用户请求终止进程时，会产生SIGTERM信号。SIGTERM信号可以被捕获或无视。这允许该进程在结束前释放掉所占用的资源并保存其状态。SIGINT和SIGTERM非常相似。

- **SIGTSTP：**当用户在进程的控制终端请求退出进程时，会产生SIGTSTP信号。SIGTSTP信号可以被捕获或无视。SIGTSTP信号的产生通常是由于用户按下Ctrl+Z。

**默认行为**

|   信号    | 可移植代号 |    默认行为     |                   描述                    |
| :-------: | :--------: | :-------------: | :---------------------------------------: |
|  SIGABRT  |     6      | 终止 (核心转储) |               进程终止信号                |
|  SIGALRM  |     14     |      终止       |                计时器告警                 |
|  SIGBUS   |   不适用   | 终止 (核心转储) |          访问内存对象未定义区域           |
|  SIGCHLD  |   不适用   |      忽略       |          子进程终止、暂停、继续           |
|  SIGCONT  |   不适用   |      继续       |         如果被暂停，重新继续执行          |
|  SIGFPE   |     8      | 终止 (核心转储) |              错误的算术运算               |
|  SIGHUP   |     1      |      终止       |                   挂起                    |
|  SIGILL   |     4      | 终止 (核心转储) |                非法的指令                 |
|  SIGINT   |     2      |      终止       |               终端中断信号                |
|  SIGKILL  |     9      |      终止       |       杀死 (无法被捕获或忽略的信号)       |
|  SIGPIPE  |     13     |      终止       |       写入一个没有连接另一端的管道        |
|  SIGPOLL  |   不适用   |      终止       |                可轮询事件                 |
|  SIGPROF  |   不适用   |      终止       |            性能调优定时器超时             |
|  SIGQUIT  |     3      | 终止 (核心转储) |               终端退出信号                |
|  SIGSEGV  |     11     | 终止 (核心转储) |              非法的内存引用               |
|  SIGSTOP  |   不适用   |      暂停       |    暂停执行（无法被捕获或忽略的信号）     |
|  SIGSYS   |   不适用   | 终止 (核心转储) |              错误的系统调用               |
|  SIGTERM  |     15     |      终止       |                 终止信号                  |
|  SIGTRAP  |     5      | 终止 (核心转储) |               追踪/断点陷阱               |
|  SIGTSTP  |   不适用   |      暂停       |               终端中止信号                |
|  SIGTTIN  |   不适用   |      暂停       |              后台进程尝试读               |
|  SIGTTOU  |   不适用   |      暂停       |              后台进程尝试写               |
|  SIGUSR1  |   不适用   |      终止       |              用户自定义信号1              |
|  SIGUSR2  |   不适用   |      终止       |              用户自定义信号2              |
|  SIGURG   |   不适用   |      忽略       | Out-of-band data is available at a socket |
| SIGVTALRM |   不适用   |      终止       |              虚拟定时器超时               |
|  SIGXCPU  |   不适用   | 终止 (核心转储) |              超出CPU时间限制              |
|  SIGXFSZ  |   不适用   | 终止 (核心转储) |             超出文件大小限制              |
| SIGWINCH  |   不适用   |      忽略       |            终端窗口大小已变化             |

摘自：[wiki - Unix信号](https://zh.wikipedia.org/wiki/Unix信号)



#### crontab



#### ifconfig



#### ln 命令

Linux `ln` ( link files ) 命令是一个非常重要命令，它的功能是<font color=fuchsia>为某一个文件在另外一个位置建立一个同步的链接</font>。

当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用 `ln` 命令链接（link ) 它就可以，不必重复的占用磁盘空间。

##### 语法

```sh
ln [参数][源文件或目录][目标文件或目录]
```

###### 参数格式

- 必要参数：[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]

- 选择参数：[--help] [--version]

##### 命令功能

Linux 文件系统中，有所谓的<font color=red>链接 ( link )</font>，我们<font color=red>可以将其视为档案的别名</font>；<font color=red>而链接又可分为两种：硬链接( hard link ) 与 软链接( symbolic link )</font>，<font color=fuchsia>硬链接的意思是一个档案可以有多个名称</font>，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。<font color=fuchsia>硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统</font>。

不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。

##### 软链接

- 软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式
- 软链接可以 跨文件系统 ，硬链接不可以
- <font color=fuchsia>软链接可以对一个不存在的文件名进行链接</font>
- <font color=red>软链接可以对目录进行链接</font>

##### 硬链接

- 硬链接，以文件副本的形式存在。但不占用实际空间。
- 不允许给目录创建硬链接
- 硬链接只有在同一个文件系统中才能创建

##### 命令参数

###### 必要参数

- `-b` ：删除，覆盖以前建立的链接
- `-d` ：允许超级用户制作目录的硬链接
- `-f` ：强制执行
- `-i` ：交互模式，文件存在则提示用户是否覆盖
- `-n` ：把符号链接视为一般目录
- `-s` ：软链接(符号链接)
- `-v` ：显示详细的处理过程

###### 选择参数

- `-S` ：`-S<字尾备份字符串>`  或 `--suffix=<字尾备份字符串>`
- `-V` ：`-V<备份方式>` 或 `--version-control=<备份方式>`
- `--help` ：显示帮助信息
- `--version` ：显示版本信息

摘自：[RUNOOB - Linux ln 命令](https://www.runoob.com/linux/linux-comm-ln.html)



### Bash

#### 变量类型

运行shell时，会同时存在**三种变量**：

- **局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
- **环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
- **shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行



#### 单引号和双引号的区别

单引号将剥夺其中的所有字符的特殊含义，而双引号中的 '\$'（参数替换）和 '\`'（命令替换）是例外。所以，两者基本上没有什么区别，除非在内容中遇到了参数替换符 \$ 和命令替换符 '\`'。所以下面的结果：

单引号

```bash
num=3
echo ‘$num’  # 结果：$num
```

双引号

```bash
echo “$num”  # 结果：3
```



#### Bash 获取字符串长度

```bash
string="abcd"
echo ${#string} #输出 4
```



#### Bash提取子字符串

以下实例从字符串第 **2** 个字符开始截取 **4** 个字符：

```
string="runoob is a great site"
echo ${string:1:4} # 输出 unoo
```



#### Bash查找子字符串

查找字符 **i** 或 **o** 的位置(哪个字母先出现就计算哪个)，脚本中' **`**' 是反引号，而不是单引号 ' **'** '

```bash
string="runoob is a great site"
echo `expr index "$string" io`  # 输出 4
```



#### 获取数组的长度

获取数组长度的方法与获取字符串长度的方法相同，例如：

```bash
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
```



#### Bash的注释

##### 行内注释（Inline comments）

```bash
# your comments
```

##### 注释块（Block comments）

###### 方法一

  ```bash
  :<<!
  your comments
  ...
  !
  ```

  类似的：

  ```bash
  :<<EOF
  your comments
  ...
  EOF
  ```

  ```bash
  :<<'
  your comments
  ...
  '
  ```

###### 方法二

```bash
if false; then
your comments
fi
```

###### 方法三

```bash
&& {
your comments
}
```


摘自：[shell脚本注释方法](https://www.cnblogs.com/Braveliu/p/10855771.html)



### iTerm2 使用

#### 快捷键

- 新建标签：⌘ + t

- 关闭标签：⌘ + w

- 切换标签：⌘ + 数字 ⌘ + 左右方向键

- 切换全屏：⌘ + enter

- 查找：⌘ + f

- 分屏
  - 垂直分屏：⌘ + d
  - 水平分屏：⌘ +⇧ + d

- 切换屏幕：⌘ + ⌥ + 方向键 ⌘ + [ 或 ⌘ + ]

- 查看历史命令：⌘ + ;

  <img src="https://i.loli.net/2020/08/14/3HbJQrVvmDOESKA.png" style="zoom: 45%;" />

- 查看剪贴板历史：⌘ +⇧ + h

- **到行首：⌃ + a**

- **到行尾：⌃ + e**

- 前进后退：⌃ + f / b (相当于左右方向键)

- 上一条命令：⌃ + p

- 搜索命令历史：⌃ + r

  <img src="https://i.loli.net/2020/08/14/NyGkMtgEbeIR96J.png" style="zoom: 45%;" />

- **删除家族**

  - 删除当前光标的字符：⌃ + d
  - 删除光标之前的字符：⌃ + h
  - **<font color=FF0000>删除光标之前的单词：⌃ + w</font>**
  - 删除到文本末尾：⌃ + k
  - **<font color=FF0000>清除当前行：⌃ + u</font>**

- 交换光标处文本：⌃ + t

- 清屏：⌘ + r / ⌃ + l

- ⌘ + 数字在各 tab 标签直接来回切换

- 选择即复制 + 鼠标中键粘贴，这个很实用

- ⌘ + f 所查找的内容会被自动复制

- ⌘ + d 横着分屏 / ⌘ +⇧ + d 竖着分屏

- ⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏

- 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令

- ⌘ +⇧ + h 会列出剪切板历史

- ⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了

- ⌘← / ⌘→ 到一行命令最左边/最右边 ，这个功能同 C+a / C+e

- ⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在Iterm中已经预定义好了，⌥f  / ⌥b，看个人习惯了

- ⌘+d：垂直分割；

- ⌘+shift+d：水平分割

- **自动完成**：输入打头几个字母，然后输入**⌘+;** iterm2将自动列出之前输入过的类似命令。

- **自动完成**输入打头几个字母，然后输入**⌘+;** iterm2将自动列出之前输入过的类似命令。

- **全屏切换**

  ⌘+enter进入与返回全屏模式

  Exposé所有Tab

  ⌘+⌥+e,并且可以搜索

以上摘自：[iTerm 2 常用快捷键](https://www.cnblogs.com/ckmiao/p/6279195.html)

#### 主题设置

可以通过 修改 `$HOME/.zshrc` 的 `ZSH_THEME` 以设置 theme，较为常见的是 `agnoster`。另外，可以在 `$HOME/.oh-my-zsh/themes` 下面设置目标主题的设置，比如 `agnoster.zsh-theme`。

另外，可以参考视频：[2022年打造程序员完美的终端环境，颜值爆表，效率 X 10倍 The Ultimate Guide to Your Terminal for Better Productivity](https://www.youtube.com/watch?v=AWtc3SQQPpI) 以及对应的文档 [打造程序员完美的终端环境，颜值爆表，效率 X 10倍](https://vikingz.me/best-terminal-setup/)

关于 zsh 的插件，可以看下 https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins ，这是一个 plugin 列表。