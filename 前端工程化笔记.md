# 前端工程化笔记



## pnpm

#### pnpm env \<cmd>

管理 Node.js 环境。💡 类似于 nvm 和 n 等包管理工具

##### 命令行

安装并使用指定版本的 Node.js。

###### 安装 LTS 版本的 Node.js

```bash
pnpm env use --global lts
pnpm env use --global argon
```

###### 安装 v16 的Node.js

```bash
pnpm env use --global 16
```

###### 安装 Node.js 的预发行版本

```bash
pnpm env use --global nightly
pnpm env use --global rc
pnpm env use --global 16.0.0-rc.0
pnpm env use --global rc/14
```

###### 安装最新版本的 Node.js

```bash
pnpm env use --global latest
```

##### 配置项

- `--global` , `-g`：此更改将全局生效。

摘自：[pnpm doc - pnpm env \<cmd>](https://pnpm.io/zh/cli/env)



#### Workspace

pnpm has <font color=dodgerBlue>built-in support for monorepositories</font>（👀 即 monorepo ），You can <font color=red>create a workspace to unite multiple projects inside a single repository</font>.

<font color=red>A workspace **must** have a [`pnpm-workspace.yaml`](https://pnpm.io/pnpm-workspace_yaml) file in its root</font>. A workspace also <font color=LightSeaGreen>**may** have an [`.npmrc`](https://pnpm.io/npmrc) in its root</font>.

##### Workspace protocol ( `workspace:`)

<font color=dodgerBlue>By default</font>, <font color=red>pnpm will link packages from the workspace</font> <font color=LightSeaGreen>if the available packages match the declared ranges</font>. For instance, <font color=red>`foo@1.0.0` is linked into `bar` **if `bar` has `"foo": "^1.0.0"` in its dependencies**</font> and <font color=fuchsia>`foo@1.0.0` is in the workspace</font>. However, if `bar` has `"foo": "2.0.0"` in dependencies and <font color=dodgerBlue>**`foo@2.0.0` is not in the workspace**</font>, `foo@2.0.0` will be installed from the registry（👀 注意与下面 workspace 的行为对比）. This behavior introduces some uncertainty（🌏 该行为将会引入不确定性）.

Luckily, <font color=red>**pnpm supports the `workspace:` protocol**</font>. <font color=dodgerBlue>When this protocol is used</font>, <font color=fuchsia>pnpm will **refuse to resolve to anything other than a local workspace package**</font>. So, <font color=dodgerBlue>**if you set `"foo": "workspace:2.0.0"`**</font> , <font color=fuchsia>**this time installation will fail** because `"foo@2.0.0"` isn't present in the workspace</font>.

This protocol is especially useful when the [link-workspace-packages](https://pnpm.io/npmrc#link-workspace-packages) option is set to `false` . <font color=red>In that case, pnpm will only link packages from the workspace **if the `workspace:` protocol is used**</font>.

###### Referencing workspace packages through aliases

<font color=dodgerBlue>Let's say you have a package in the workspace named `foo`</font> . <font color=dodgerBlue>**Usually**</font>, <font color=red>you would reference it as `"foo": "workspace:*"`</font> .

If you want to use a different alias, the following syntax will work too: `"bar": "workspace:foo@*"` .

<font color=fuchsia>Before publish, **aliases are converted to regular aliased dependencies**</font>. The <font color=LightSeaGreen>above example will become: `"bar": "npm:foo@1.0.0"`</font> .

###### Referencing workspace packages through their relative path

In a workspace with 2 packages:

```text
+ packages
    + foo
    + bar
```

`bar` may have `foo` in its dependencies declared as `"foo": "workspace:../foo"` . Before publishing, these specs are converted to regular version specs supported by all package managers.

###### Publishing workspace packages

When a workspace package is packed into an archive (whether it's through `pnpm pack` or one of the publish commands like `pnpm publish` ), <font color=dodgerBlue>we **dynamically replace** any `workspace:` dependency by</font>:

- The corresponding version in the target workspace (if you use `workspace:*` , `workspace:~` , or `workspace:^` )
- The associated semver range (for any other range type)

So for example, if we have `foo` , `bar` , `qar` , `zoo` in the workspace and they all are at version `1.5.0` , the following:

```json
{
    "dependencies": {
        "foo": "workspace:*",
        "bar": "workspace:~",
        "qar": "workspace:^",
        "zoo": "workspace:^1.5.0"
    }
}
```

<font color=dodgerBlue>Will be transformed into:</font>

```json
{
    "dependencies": {
        "foo": "1.5.0",
        "bar": "~1.5.0",
        "qar": "^1.5.0",
        "zoo": "^1.5.0"
    }
}
```

This feature allows you to depend on your local workspace packages while <font color=fuchsia>still being able to publish the resulting packages to the remote registry without needing intermediary publish steps</font> - <font color=red>your consumers will be able to use your published workspaces as any other package</font>, still benefitting from the guarantees semver offers.

摘自：[pnpm doc - Workspace](https://pnpm.io/workspaces#workspace-protocol-workspace)



## Babel

##### 一些资料

- [Babel 官网](https://babel.dev)
- [babel-handbook](https://github.com/jamiebuilds/babel-handbook)

- [神说要有光 - Babel 插件通关秘籍 ](https://juejin.cn/book/6946117847848321055/section) 这也是这里 Babel 笔记的主要摘抄



### 《Babel 插件通关秘籍》笔记



#### Babel 介绍

babel 是 JS 的转译器 (  JavaScript Transpiler ) 👀 详见 [[#编译器和转译器]]

##### 命名演化

babel 最开始叫 6to5，顾名思义是 es6 转 es5，但是后来随着 es 标准的演进，有了 es7、es8 等， 6to5 的名字已经不合适了，所以改名为了 babel。

##### Babel 的三种用途

###### 转译 ES Next、TypeScript、Flow 等到目标环境支持的 js

这个是<font color=red>最常用的功能</font>，用来把代码中的 ES Next 的新的语法、TypeScript 和 Flow 的语法转成基于目标环境支持的语法的实现。并且还可以把目标环境不支持的 api 进行 polyfill。

> 💡 还有 jsx 的编译

<font color=red>babel7 提供了 @babel/preset-env 的包</font>，可以<font color=red>指定目标 env 来按需转换，转换更加的精准，产物更小</font>。

###### 一些特定用途的代码转换

babel 是一个转译器，暴露了很多 api，用这些 api 可以完成<font color=red>代码到 AST 的解析、转换、以及目标代码的生成</font>。

<font color=dodgerBlue>开发者可以用它来完成一些特定用途的转换</font>，比如<font color=red>函数插桩</font>（<font color=red>函数中自动插入一些代码</font>，例如<font color=red>埋点代码</font>）、<font color=red>自动国际化</font>等。<font color=LightSeaGreen>流行的小程序转译工具 taro，就是基于 babel 的 api 来实现的</font>。

###### 代码的静态分析

<font color=red>对代码进行 parse 之后，会生成 AST，通过 AST 能够理解代码结构</font>，除了转换 AST 再打印成目标代码之外，也同样<font color=red>可以**用于分析代码的信息，进行一些静态检查**</font>。

- <font color=red>linter 工具</font>就是分析 AST 的结构，对代码规范进行检查。
- <font color=LightSeaGreen>api 文档自动生成工具</font>，可以提取源码中的注释，然后生成文档。
- <font color=red>type checker</font> 会根据从 AST 中提取的或者推导的类型信息，对 AST 进行类型是否一致的检查，从而减少运行时因类型导致的错误。👀 比如 tsc
- <font color=red>压缩混淆工具</font>，这个也是分析代码结构，进行删除死代码、变量名混淆、常量折叠等各种编译优化，生成体积更小、性能更优的代码。
- JS 解释器，除了对 AST 进行各种信息的提取和检查以外，我们<font color=red>还可以直接解释执行 AST</font>。



#### Babel 的编译流程

##### 编译器和转译器

编译的定义就是从一种编程语言转成另一种编程语言。主要指的是高级语言到低级语言。

<font color=LightSeaGreen>一般编译器 Compiler 是指高级语言到低级语言的转换工具</font>。而<font color=fuchsia>从 **高级语言** 到 **高级语言** 的 **转换工具**，被叫做 <font size=4>**转换编译器**</font>，简称 **转译器** ( Transpiler )</font>。Babel 就是一个 JavaScript Transpiler。

##### Babel 的编译流程

<font color=fuchsia>Babel 是 **source to source 的转换**</font>，整体编译流程分为三步：

- **parse**：通过 <font color=red>parser 把源码转成抽象语法树 ( AST )</font>
- **transform**：<font color=red>遍历 AST，调用各种 transform 插件对 AST 进行增删改</font>
- **generate**：把<font color=red>转换后的 AST 打印</font>（👀 生？）<font color=red>成目标代码</font>，并 <font color=fuchsia size=4>**生成 sourcemap**</font>

![img](https://s2.loli.net/2023/01/03/79luiCsc6EPqxfA.png)

##### 为什么 babel 的编译流程会分 parse、transform、generate 这 3 步

源码是一串按照语法格式来组织的字符串，<font color=LightSeaGreen>人能够认识，但是计算机并不认识</font>；<font color=red>想让计算机认识就要转成一种数据结构，通过不同的对象来保存不同的数据，并且按照依赖关系组织起来</font>；这种数据结构就是抽象语法树 ( abstract syntax tree )。

之所以叫“抽象”语法树是因为<font color=red>数据结构中省略掉了一些无具体意义的分隔符比如 `;` `{` `}`等</font> 

> 💡 参考 [编程语言的发展趋势：从没有分号，到DSL](https://mp.weixin.qq.com/s/_SOlzlLG6ua8kXxnPltX0g) 中所说：
>
> > 在大多数情况下，分号是给机器看的，而不是给人看的。**写分号，本质是我们人类在迁就编译器**，毕竟，机器是很傻的。
>
> 类似的，`{}` 括号也是。

有了 AST，计算机就能理解源码字符串的意思，而理解是能够转换的前提，所以编译的第一步需要把源码 parse 成 AST。

转成 AST 之后就可以通过修改 AST 的方式来修改代码，<font color=red>这一步会遍历 AST 并进行各种增删改</font>，<font color=LightSeaGreen>这一步也是 babel 最核心的部分</font>。

经过转换以后的 AST 就是符合要求的代码，就可以再转回字符串，<font color=red>转回字符串的过程中把之前删掉的一些分隔符再加回来</font>。

<font color=dodgerBlue>**简单总结**</font>：**为了让计算机理解代码需要先对源码字符串进行 parse，生成 AST，把对代码的修改转为对 AST 的增删改，转换完 AST 之后再打印成目标代码字符串。**

##### parse、transform、generate 三步做了什么

###### parse

parse 阶段的目的是把源码字符串转换成机器能够理解的 AST，这个过程<font color=fuchsia>分为 **词法分析**、**语法分析**</font>。

比如 `let name = 'guang';` 这样一段源码，我们要<font color=red>先把它分成一个个不能细分的单词</font> ( token )，也就是 `let` , `name` , `=` , `'guang'` ，<font color=fuchsia>这个过程是 **词法分析**</font>，按照单词的构成规则来拆分字符串成单词。

之后要<font color=fuchsia>把 token 进行递归的组装，生成 AST</font>，<font color=fuchsia>这个过程是 **语法分析**</font>；按照不同的语法结构，来把一组单词组合成对象，比如<font color=red>声明语句、赋值表达式等都有对应的 AST 节点</font>。

<img src="https://s2.loli.net/2023/01/03/2r3SovJbGRWmuAx.png" alt="img" style="zoom:35%;" />

###### transform

transform 阶段是对 parse 生成的 AST 的处理，会<font color=red>进行 AST 的遍历</font>，<font color=red>遍历的过程中处理到不同的 AST 节点会</font> <font color=fuchsia>调用注册的 **相应的 visitor 函数**</font>，<font color=red>visitor 函数里可以对 AST 节点进行增删改，返回新的 AST</font>（可以指定是否继续遍历新生成的 AST）。这样遍历完一遍 AST 之后就完成了对代码的修改。

<img src="https://s2.loli.net/2023/01/03/FkptO2ITlQL1vnA.png" alt="img" style="zoom:40%;" />

###### generate

generate 阶段会把 AST 打印成目标代码字符串，并且会生成 sourcemap。<font color=fuchsia>不同的 AST 对应的不同结构的字符串</font>，比如 <font color=red>`IfStatement` 就可以打印成 `if (test) {}` 格式的代码</font>。这样从 AST 根节点进行递归的字符串拼接，就可以生成目标代码的字符串。

<img src="https://s2.loli.net/2023/01/03/F2IV9cSkPGs4NfC.png" alt="img" style="zoom:35%;" />

sourcemap 记录了源码到目标代码的转换关系，通过它我们可以找到目标代码中每一个节点对应的源码位置，用于调试的时候把编译后的代码映射回源码，或者线上报错的时候把报错位置映射到源码。



#### Babel 的 AST

AST 是对源码的抽象，<font color=red>字面量、标识符、表达式、语句、模块语法、class 语法都有各自的 AST</font>。

##### Literal 字面量

`let name = 'guang'` 中，`'guang'` 就是一个字符串字面量 StringLiteral，相应的还有数字字面量 NumericLiteral ，布尔字面量 BooleanLiteral ，字符串字面量 StringLiteral，正则表达式字面量 RegExpLiteral 等。

下面这些字面量都有对应的 Literal 节点：

<img src="https://s2.loli.net/2023/01/23/GBczVNK6COvZX4l.png" alt="" style="zoom: 33%;" />

代码中的字面量很多，babel 就是通过 xxLiteral 来抽象这部分内容的。

##### Identifier

Identifer 是标识符的意思，变量名、属性名、参数名等各种声明和引用的名字，都是 Identifer。





## PostCSS

#### 峰华前端的《13 分钟掌握 PostCSS》笔记

PostCSS 是专门用于处理 CSS 的工具，通过一系列的插件来修改最终样式：可以让开发者使用最新的 CSS 特性（哪怕提案处于 stage 0，配置示例下面有）提高开发效率（通过使用 [PostCSS-Preset-env](https://github.com/csstools/postcss-preset-env) 。不过原库已经 archived，并入了 [postcss-plugins](https://github.com/csstools/postcss-plugins) ）；也可以转译 CSS，兼容大多数浏览器（类似于 Babel ）；PostCSS 通过插件，支持 Sass 之类 CSS 预处理工具。

使用 autoprefixer 可以查看哪些 CSS 属性、值、选择器、@rules 是需要加上浏览器前缀的，使用 `npx autoprefixer --info` 即可输出内容，输出内容略。

使用 PostCSS 命令行工具 PostCSS-Cli 可以通过命令行的方式运行 PostCSS：

```sh
npx postcss input.css -o output.css -u yourPostCssPlugin
```

通用的语法见 [PostCSS CLI - README](https://github.com/postcss/postcss-cli) 。不过这样过于麻烦，可以通过 配置文件（配置 postcss.config.js 文件） 的方法，设置 `yourPostCssPlugin` ；使得即使在不使用 webpack 之类工具的情况下，至少不需要输入 `-u yourPostCssPlugin` 。使用 npm script 甚至可以省去前面（固定）的代码

```js
// postcss.config.js
const postcssPresetEnv = require('postcss-preset-env')

module.exports = {
  plugins: [
    require('stylelint'),
    require('autoprefixer'),
    postcssPresetEnv({
      stage: 0 // 可以使用提案在 stage 0 的新特性
    }),
    require('postcss-pxtorem')
  ]
}
```

CSS 也有自己的 lint 工具  [stylelint](https://github.com/stylelint/stylelint) 以及 它基本的规则 [stylelint-config-standard](https://github.com/stylelint/stylelint-config-standard) ；使用 stylelint 创建 `.stylelintrc.json` 配置文件，并在 postcss.config.js 配置文件中注册（注册见上面）：

```json
// .stylelintrc.json
{
  "extends": "stylelint-config-standard"
}
```

在开发时需要将 px 转换为 rem，这时候可以使用插件 [postcss-pxtorem](https://github.com/cuth/postcss-pxtorem) 类似的有 [px2rem](https://github.com/songsiqi/px2rem)，不过前者 Star 更多

学习自：[13 分钟掌握 PostCSS](bilibili.com/video/BV1Pd4y1S7Mp)

相关的，在 [[Vue3 + TS 学习笔记#PostCSS 工具]] 中也有 PostCSS 的笔记

### Tecvan《零基础理解 PostCSS 的主流程》笔记

官网说：“PostCSS，一个使用 JavaScript 来处理 CSS 的框架” ( A tool for transforming CSS with JavaScript )。这句话高度概括了 PostCSS 的作用，但是太抽象了。按我理解，PostCSS 主要做了三件事：

1. **parse**：<font color=red>把 CSS 文件的字符串解析成抽象语法树 ( Abstract Syntax Tree ) 的框架</font>，<font color=fuchsia>解析过程中会检查 CSS 语法是否正确，不正确会给出错误提示</font>。
2. **runPlugin**：<font color=fuchsia>**执行插件函数**</font>。<font color=fuchsia>**PostCSS 本身不处理任何具体任务**，它提供了以特定属性或者规则命名的事件</font>。有特定功能的插件（如 autoprefixer、CSS Modules ）会注册事件监听器。PostCSS 会在这个阶段，重新扫描 AST，执行注册的监听器函数。
3. **generate**：<font color=fuchsia>插件对 AST 处理后，PostCSS 把处理过的 AST 对象转成 CSS string</font>。

![图片](https://s2.loli.net/2022/08/11/RDNvjWZ72KdySeh.png)

<font color=red>**「如果没有插件」**，那么初始传入的 CSS string 和 generate 生成的 CSS string 是一样的</font>。由此可见，<font color=fuchsia>PostCSS 本身并不处理任何具体的任务，只有当我们为其附加各种插件之后，它才具有实用性</font>。

下面分别详细分析三个阶段做的事。

#### 第一阶段：parse

<font color=dodgerBlue>CSS 规则集 ( rule-set ) 由选择器和声明块组成</font>：

![图片](https://s2.loli.net/2022/08/12/Z9Dtvd1efCRGJhP.png)

- **选择器** 指向您需要设置样式的 HTML 元素
- <font color=red>**声明块** 包含一条或多条用分号分隔的声明</font>
- 每条 **声明** 都包含一个 CSS 属性名称和一个值，以冒号分隔
- 多条 **CSS 声明** 用分号分隔，声明块用花括号括起来

##### 五类对象

<font color=fuchsia>AST 用 **五类对象** 描述 CSS 语法</font>。<font color=dodgerBlue>这里举个具体的例子，再打印出对应的 AST 结果，**对照了解 AST 五类对象和 CSS 语法的对应关系**</font>。

`app.css` 文件中写如下内容：

```css
@import url('./app-02.css');

.container {
  color: red;
}
```

##### Declaration 对象

<font color=fuchsia>Declaration 对象用来 **描述 CSS 中的每一条声明语句**</font>

- **type**：<font color=red>标记当前对象的类型</font>
- **parent**：<font color=red>记录父对象的实例</font>
- **prop**：记录声明中的属性名
- **value**：记录声明中的值
- **raws**：<font color=red>字段记录声明前的字符串、声明属性和值之间的符号的字符串</font>
- 其余字段（比如 `source` 及其子字段、`Symbol(prop)` ）解释见代码中的注释

上边 CSS 文件中的 `color: red;` 会被描述成如下对象：

```json
{
  parent: Rule,    // 外层的选择器被转译成 Rule 对象，是当前声明对象的 parent
  prop: "color",   // prop 字段记录声明的属性
  raws: {          // raws 字段记录声明前、后的字符串，声明属性和值之间的字符串，以及前边语句是否分号结束。
    before: '\n ', // raws.before 字段记录声明前的字符串
    between: ': ', // raws.between 字段记录声明属性和值之间的字符串
  },
  source: { // source 字段记录声明语句的开始、结束位置，以及当前文件的信息
    start: { offset: 45, column: 3, line: 4 },
    end: { offset: 55, column: 13, line: 4 },
    input: Input {
      css: '@import url('./app-02.css');\n\n.container {\n  color: red;\n}',
      file: '/Users/admin/temp/postcss/app.css',
      hasBOM: false,
      Symbol(fromOffsetCache): [0, 29, 30, 43, 57]
    }
  },
  Symbol('isClean'): false,  // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true, // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype 属性
  type: 'decl',      // type 记录对象类型，是个枚举值，声明语句的 type 固定是 decl
  value: "red"       // value 字段记录声明的值
}
```

##### Rule 对象

<font color=fuchsia>Rule 对象是 **描述选择器** 的</font>

- **type**：记录对象的类型
- **parent**：记录父对象的实例
- **nodes**：<font color=red>记录子对象的实例</font>
- **selector**：<font color=red>记录选择器的字符串</font>
- **raws**：<font color=red>记录选择器前的字符串、选择器和大括号之间的字符串、最后一个声明和结束大括号之间的字符串</font>
- 其余字段解释见代码中的注释

上边 `app.css` 文件中 `.container` 经过 postcss 转译后的对象是（每个字段的含义和功能已经以注释的形式进行了解释）：

```json
{
  nodes: [Declaration],  // nodes 记录包含关系，Rule 对象包含 Declaration 对象
  parent: Root,          // 根对象是 Root 对象，是当前声明对象的 parent
  raws: {                // raws 字段记录如下
    before: '\n\n',      // raws.before 字段记录选择器前的字符串
    between: ' ',        // raws.between 字段记录选择器和大括号之间的字符串
    semicolon: true,     // raws.semicolon 字段记录前置声明语句是正常分号结束
    after: '\n'          // raws.after 字段记录最后一个声明和结束大括号之间的字符串
  },
  selector:'.container', // selector 记录 selector
  source: {              // source 字段记录选择器语句的开始、结束位置，以及当前文件的信息
    start: { offset: 30, column: 1, line: 3 },
    input: Input {
      css: '@import url('./app-02.css');\n\n.container {\n  color: red;\n}',
      file: '/Users/admin/temp/postcss/app.css',
      hasBOM: false,
      Symbol(fromOffsetCache): [0, 29, 30, 43, 57]
    },
    end: { offset: 57, column: 1, line: 5 }
  },
  Symbol('isClean'): false, // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true,       // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype
  type: 'rule'              // type 记录对象类型，是个枚举值，声明语句的 type 固定是 rule
}
```

##### AtRule 对象

<font color=fuchsia>CSS 中除了选择器，还有一类语法是 `@` 开头的</font>，例如 `@import`、`@keyframes`、`@font-face`，PostCSS 把这类语法解析成 AtRule 对象。👀 注：它本身的名字也叫 `@rules`

- **type**：记录当前对象的类型
- **parent**：记录当前对象的父对象
- **name**：记录 <font color=red>`@` 紧跟着的单词</font>
- **params**：记录 name 对应的值

例如 `@import url("./app-02.css");` 将被解析成如下对象：

```json
{
  name: "import",                // name 记录 @ 紧跟着的单词
  params: "url('./app-02.css')", // params 记录 name 对应的值
  parent: Root,                  // parent 记录父对象
  raws: {                        // raws 字段记录如下
    before: '',                  // raws.before 记录 @语句前的空字符串
    between: '',                 // raws.between 记录 name 和 { 之间的空字符串
    afterName: '',               // raws.afterName 记录 name 和 @ 语句之间的空字符串
    after: '',                   // raws.after 记录大括号和上一个 rule 之间的空字符串
    semicolon: false             // raws.semicolon 上一个规则是否是分号结束
  },
  source: {                      // source 字段记录@语句的开始，以及当前文件的信息
    start: { offset: 0, column: 1, line: 1 },
    end: { offset: 27, column: 28, line: 1 },
    input: Input {
      css: '@import url('./app-02.css');\n\n.container {\n  color: red;\n}',
      file: '/Users/admin/temp/postcss/app.css',
      hasBOM: false,
      Symbol(fromOffsetCache): [0, 29, 30, 43, 57]
    }
  },
  Symbol('isClean'): false,  // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true,        // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype
  type: 'atrule'          // type 记录对象类型，是个枚举值，声明语句的 type 固定是 atrule
}
```

##### Comment 对象

<font color=fuchsia>CSS 文件中的注释被解析成 Comment 对象</font>。text 字段记录注释内容。`/* 你好 */  `被解析成：

```json
{
  parent: Root,    // parent 记录父对象
  raws: {          // raws 字段记录如下
    before: '',    // raws.before 记录注释语句前的空字符串
    left: ' ',     // raws.left 记录注释语句左侧的空字符串
    right: ' '     // raws.right 记录注释语句右侧的空字符串
  },
  source: {        // source 字段记录注释语句的开始、结束位置，以及当前文件的信息
    start: {…}, 
    input: Input, 
    end: {…}
  },
  Symbol('isClean'): false, // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true,       // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype
  text: '你好',              // text 记录注释内容
  type: 'comment'           // type 记录对象类型，是个枚举值，声明语句的 type 固定是 comment
}
```

##### 图解五类对象之间的继承关系

从上一段可以知道，<mark>CSS 被解析成 Declaration、Rule、Root、AtRule、Comment 对象</mark>。<font color=fuchsia>**这些对象有很多 公共方法，PostCSS 用了面向对象的继承思想，把公共方法和公共属性提取到了父类中**</font>。

<font color=fuchsia>**Root、Rule、AtRule** 都是可以有子节点的</font>，都有 nodes 属性，<font color=fuchsia>**他们三个继承自 Container 类**</font>，对 nodes 的操作方法都写在 Container 类中。

<font color=fuchsia>**Container、Declaration、Comment** **继承自 Node 类**</font>，所有对象都有 `Symbol('isClean')` 、`Symbol('my')`、raws、source、type 属性，都有 `toString()`、`error()` 等方法，这些属性和方法都定义在 Node 类中。

**Container、Node** 是用来提取公共属性和方法，不会生成他们的实例。

<font color=dodgerBlue>五个类之间的继承关系如下图所示：</font>

![Image](https://s2.loli.net/2022/08/12/c6po81SKtVYMnXv.png)

图中没有穷举类的方法，全部的方法 可以看直接看源码文件: https://github.com/postcss/postcss/tree/main/lib

#### 第二阶段：runPlugin

<mark>PostCSS 本身并不处理任何具体的任务，只有当我们为其附加各种插件之后，它才具有实用性</mark>。

<font color=fuchsia>PostCSS 在把 CSS string 解析成 AST 对象后，会扫描一边 AST 对象</font>，<font color=fuchsia>**每一种 AST 的对象都可以有对应的监听器**</font>。<font color=red>在遍历到某类型的对象时，如果有对象的监听器，就会执行其监听器。

##### 第一类监听器

PostCSS 提供的**「以特定属性或者规则命名」**的事件监听器，如下：

> CHILDREN 代表子节点的事件监听器。

```js
// root
['Root', CHILDREN, 'RootExit']

// AtRule
['AtRule', 'AtRule-import', CHILDREN, 'AtRuleExit', 'AtRuleExit-import']

// Rule
['Rule', CHILDREN, 'RuleExit']

// Declaration
['Declaration', 'Declaration-color', 'DeclarationExit', 'DeclarationExit-color']

// Comment
['Comment', 'CommentExit']
```

PostCSS 以 <font color=fuchsia size=4>**深度优先** 的方式遍历 AST 树</font>。

- <mark style="background: lightpink">**遍历到 Root 根对象**，**第一步** 会执行所有插件注册的 Root 事件监听器，**第二步** 检查 Root 是否有子对象，如果有，则遍历子对象，执行子对象对应的事件监听器；如果没有子对象，则直接进入第三步；**第三步** 会执行所有插件注册的 RootExit 事件监听器</mark> （👀 注：这就是 DFS 的步骤）。

  <font color=red>插件注册的 Root、RootExit 事件的监听器 **只能是函数**</font>。函数的第一个参数是当前访问的 AST 的 Root 对象，第二个参数是 postcss 的 Result 对象和一些其他属性，通过 Result 对象可以获取 css string、opts 等信息。

  ```js
  {
    Root: (rootNode, helps) => {},
    RootExit: (rootNode, helps) => {}
  }
  ```

- **遍历到 Rule 对象**，则<mark style="background: lightpink">和访问 Root 根对象是一样的逻辑</mark>，先执行所有插件注册的 Rule 事件监听器，再遍历子对象，最后执行所有插件注册的 RuleExit 事件监听器。<font color=red>插件注册的 Rule、RuleExit 事件的监听器 **只能是函数**</font>。

  ```js
  {
    Rule: (ruleNode, helps) => {},
    RuleExit: (ruleNode, helps) => {}
  }
  ```

- **遍历到 AtRule 对象**。<font color=red>插件注册的 AtRule 的事件监听器 **可以是函数**，**也可以是对象**</font>。对象类型的监听器，对象属性的 key 是 AtRule 对象的 name 值，value 是函数。<mark style="background: lightpink">AtRuleExit 是一样的逻辑</mark>。<font color=fuchsia>事件的执行顺序是：`['AtRule', 'AtRule-import', CHILDREN, 'AtRuleExit', 'AtRuleExit-import']` </font>。CHILDREN 代表子节点的事件。

  ```js
   // 函数
  { 
    AtRule: (atRuleNode, helps) => {}
  }
  
  // 对象
  {
    AtRule: {
      import: (atRuleNode, helps) => {},
      keyframes: (atRuleNode, helps) => {}
    }
  }
  ```

- **遍历到 Declaration 对象**。<font color=red>插件注册的 Declaration 的事件监听器 **可以是函数，也可以是对象**</font>，对象属性的 key 是 Declaration 对象的 prop 值，value 是函数。<mark style="background: lightpink">DeclarationExitExit 是一样的逻辑</mark>。<font color=fuchsia>事件的执行顺序是：`['Declaration', 'Declaration-color', 'DeclarationExit', 'DeclarationExit-color']`</font> 。**Declaration 没有子对象，只需要执行当前对象的事件，不需要深度执行子对象的事件**。

  ```js
  // 函数
  {
    Declaration: (declarationNode, helps) => {}
  }
  
  // 对象
  {
    Declaration: {
      color: (declarationNode, helps) => {},
      border: (declarationNode, helps) => {}
    }
  }
  ```

- **遍历到 Comment 对象**。依次执行所有插件注册的 Comment 事件监听器，再执行所有插件注册的 CommentExit 事件监听器。

##### 第二类监听器

<font color=dodgerBlue>除以特定属性或者规则命名的事件监听器，**PostCSS 还有以下四个**</font>（👀 注：三个方法，一个插件名称）：

```js
{
  postcssPlugin: string,
  prepare: (result) => {},
  Once: (root, helps) => {},
  OnceExit: (root, helps) => {},
}
```

PostCSS 插件事件的整体执行是：`[prepare, Once, ...一类事件, OnceExit]`，<font color=red>**postcssPlugin 是插件名称**</font>，不是事件监听器。

- **postcssPlugin**：字符串类型，<font color=red>插件的名字，在插件执行报错，提示用户是哪个插件报错了</font>。

- **prepare**：函数类型，<font color=red>prepare 是最先执行的，在所有事件执行前执行的</font>，插件多个监听器间共享数据时使用。prepare 的入参是 Result 对象，返回值是监听器对象，通过 Result 对象可以获取 css string、opts 等信息。

  ```js
  {
    postcssPlugin: "PLUGIN NAME",
    prepare(result) {
      const variables = {};
      return {
        Declaration(node) {
          if (node.variable) {
            variables[node.prop] = node.value;
          }
        },
        OnceExit() {
          console.log(variables);
        },
      };
    },
  };
  ```

- **Once**：函数类型，<font color=red>在 prepare 后，一类事件前执行</font>，Once <font color=red>只会执行一次</font>。

  ```js
  {
     Once: (root, helps) => {}
  }
  ```

- **OnceExit**：函数类型，<font color=red>在一类事件后执行</font>，OnceExit <font color=red>只会执行一次</font>。

**插件有哪些？**

[postcss Github - docs - PostCSS plugins](https://github.com/postcss/postcss/blob/main/docs/plugins.md) 列出了大量的 postcss plugin，就相当于 postcss awesome

#### 第三阶段：generate

generate 的过程<font color=fuchsia>依旧是以深度优先的方式遍历 AST 对象，**针对不同的实例对象进行字符串的拼接**</font>。算法对应源码中位置是：`postcss/lib/stringifier.js` 中的 `stringify ` 方法，代码量不大，可自行查看。

摘自：[零基础理解 PostCSS 的主流程](https://mp.weixin.qq.com/s/Bkss0lzPT-TI6GyGxMyn3Q)



## npm & package.json



#### 指定项目运行的系统环境

> 👀 相关内容可以参考 [npm doc - version 8 - package.json](https://docs.npmjs.com/cli/v8/configuring-npm/package-json)

##### 指定 项目运行的 Node 版本

如何指定项目运行的 Node 版本，可以在 package.json 中配置 `engines` 选项；如下示例：

```json
{
  "engines": {
    "node": ">=0.10.3 <15"
  }
}
```

##### 指定 项目运行的 OS 和 CPU 版本

```json
{
  "os": [
    "darwin",
    "linux"
  ],
  "cpu": [
    "x64",
    "ia32"
  ]
}
```

摘自：[npm doc - version 8 - package.json](https://docs.npmjs.com/cli/v8/configuring-npm/package-json)



##### 修改 node_modules 依赖代码

想要修改 node_modules 中依赖部分的代码（比如说：存在 bug），可以使用 [patch-package](https://github.com/ds300/patch-package) ，这个可以说是当前的 最佳实践。

> **About**
>
> Fix broken node modules instantly 🏃🏽‍♀️💨



### corepack

##### 简要介绍

As per [Node.js](https://nodejs.org/api/corepack.html) documentation, the corepack <font color=red>identifies the package manager</font> and <font color=red>installs in the background if needed without any user interaction</font>.

摘自：[How to Configure a React App with TypeScript, TailwindCSS, Yarn and Storybook](https://blog.bitsrc.io/how-to-configure-a-react-app-with-typescript-tailwindcss-yarn-and-storybook-a271df5d9884)

##### What's Corepack

Corepack <font color=red>makes sure you are using the correct version for package manager</font> when you run corresponding commands. <font color=red>Projects might have `packageManager` field in their `package.json`</font> .

Under projects with configuration as shown on the right（ 👀 现在是 below 了 ）, <font color=red>corepack will install `v7.1.5` of `pnpm` (if you don't have it already)</font> and use it to run your commands. <font color=fuchsia>This makes sure everyone working on this project have the same behavior for the dependencies and the lockfile</font>.

```json
// package.json
{
  "packageManager": "pnpm@7.1.5"
}
```

摘自：[GitHub - antfu/contribute](https://github.com/antfu/contribute)

#### Node Doc Intro

> 💡 Added in: v16.9.0, v14.19.0

##### 简介

*[Corepack](https://github.com/nodejs/corepack)* is an <font color=red>experimental tool</font> to help with managing versions of your package managers. It <font color=fuchsia>exposes **binary proxies**</font>（👀 本质上是 包管理工具的 二进制**代理** ）<font color=fuchsia>for each supported package manager</font>（ 👀 目前是 pnpm 和 yarn ） that, when called, will identify whatever package manager is configured for the current project, <font color=fuchsia>transparently install it if needed</font>, and finally <font color=fuchsia>run it without requiring explicit user interactions</font>.

<font color=dodgerBlue>This feature simplifies two core workflows:</font>

- <font color=LightSeaGreen>It eases new contributor onboarding</font>（加入）, since they won't have to follow system-specific installation processes anymore just to have the package manager you want them to.
- It allows you to <font color=LightSeaGreen>ensure that everyone in your team will **use exactly the package manager version** you intend them to</font>, without them having to manually synchronize it each time you need to make an update.

##### Workflows

###### Enabling the feature

<font color=dodgerBlue>Due to its experimental status</font>, Corepack currently needs to be explicitly enabled to have any effect. To do that, <font color=red>run `corepack enable`</font> , which <font color=red>will set up the symlinks in your environment next to the `node` binary</font> (and overwrite the existing symlinks if necessary).

From this point forward, any call to the *supported binaries*（👀 即 supported package manager ） will work without further setup. Should you experience a problem, <font color=red>run `corepack disable` to remove the proxies from your system</font> (and consider opening an issue on the [Corepack repository](https://github.com/nodejs/corepack) to let us know).

###### Configuring a package

The <font color=fuchsia>Corepack proxies will find the closest `package.json` file in your current directory hierarchy</font> to <font color=fuchsia>extract its `"packageManager"` property</font>.

If the value corresponds to a *supported package manager*, Corepack will make sure that all calls to the relevant binaries are run against the requested version, downloading it on demand if needed, and aborting if it cannot be successfully retrieved.

###### Upgrading the global versions

When running outside of an existing project (for example when running `yarn init` ) , <font color=red>Corepack will **by default** use predefined versions roughly corresponding to the latest stable releases from each tool</font>. <font color=fuchsia>Those versions can be overridden by running the `corepack prepare` command</font> along with the package manager version you wish to set:

```bash
corepack prepare yarn@x.y.z --activate
```

Alternately, a tag or range may be used:

```bash
corepack prepare pnpm@latest --activate
corepack prepare yarn@stable --activate
```

摘自：[Node Doc - Corepack](https://nodejs.org/api/corepack.html)
