# 前端工程化笔记



## Monorepo

##### 一些资料

[monorepo.tools](https://monorepo.tools)



##### Multi-Repo 的缺点

- 跨仓库开发：多仓维护成本高
- 开发调试：npm包（修改 -> 发布 -> 安装 成本高），调试麻烦 ( npm link )，
- 版本管理：依赖版本同步升级管理麻烦
- 项目基建：脚手架升级，新老项目规范很难保证统一

##### Monorepo 项目目录结构

```
├── packages/
│   ├── module1/
│   │   ├── src/
│   │   ├── tests/
│   │   ├── package.json
│   │   └── ...
│   ├── module2/
│   │   ├── src/
│   │   ├── tests/
│   │   ├── package.json
│   │   └── ...
│   └── shared/
│       ├── src/
│       ├── tests/
│       ├── package.json
│       └── ...
├── libs/
│   ├── lib1/
│   │   ├── src/
│   │   ├── tests/
│   │   ├── package.json
│   │   └── ...
│   ├── lib2/
│   │   ├── src/
│   │   ├── tests/
│   │   ├── package.json
│   │   └── ...
│   └── ...
├── docs/
├── .gitignore
├── package.json
└── ...
```

> 💡 其中 lib 适用于发包的，即 utils lib

> 💡 关于 monorepo 的项目目录结构可以看下 [Github - babel](https://github.com/babel/babel) 的目录结构。
>
> > 随着前端工程的日益复杂，越来越多的项目开始使用 monorepo。之前对于多个项目的管理，我们一般都是使用多个 git 仓库，但 monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的packages目录下，那么一个子项目就代表一个 package。如果你之前没接触过 monorepo 的概念，建议仔细看看这篇文章 [What Is a Monorepo?](https://www.perforce.com/blog/vcs/what-monorepo)，以及开源的 monorepo 管理工具 [lerna](https://github.com/lerna/lerna)，项目目录结构可以参考一下 [babel](https://github.com/babel/babel) 仓库。
> >
> > 摘自：[关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn?](https://juejin.cn/post/6932046455733485575)

##### Monorepo 项目间代码如何共享？

举个例子：

假设 lib 的包名为 `@my-scope/lib` ，无需发包至 npm。

在一级目录的 package.json 添加包名 `@my-scope/lib: "workspace:*"` 。

在两个 projects 中的代码中引入：

```js
import {method} from '@my-scope/lib';
```

##### 使用 pnpm 的 Monorepo 实战

###### 设置子项目目录数组

创建 Monorepo 项目后，在 `package.json` 文件中添加一个 `workspaces` 字段，并设置为一个包含子项目目录的数组；比如：

```json
"workspaces": [
  "packages/*"
]
```

> 💡 这里开始以为作者搞错了，毕竟 vue3 文档中在 `pnpm-workspace.yaml` 中有如下定义：
>
> ```yaml
> packages:
>   - 'packages/*'
> ```
>
> 以为作者搞错了。但看了下 [npm v9 - package.json # workspaces](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#workspaces) 的内容，发现确实有这个设置。
>
> > ###### workspaces
> >
> > The optional `workspaces` field is an array of file patterns that describes locations within the local file system that the install client should look up to find each [workspace](https://docs.npmjs.com/cli/v9/using-npm/workspaces) that needs to be symlinked to the top level `node_modules` folder.
> >
> > It can describe either the direct paths of the folders to be used as workspaces or it can define globs that will resolve to these same folders.
> >
> > In the following example, all folders located inside the folder `./packages` will be treated as workspaces as long as they have valid `package.json` files inside them:
> >
> > ```json
> > {
> >     "name": "workspace-example",
> >     "workspaces": [
> >       "./packages/*"
> >     ]
> > }
> > ```
> >
> > See [`workspaces`](https://docs.npmjs.com/cli/v9/using-npm/workspaces) for more examples.
>
> 同时问了下 gpt ：“在 `package.json` 中设置 `workspaces` 和 在 `pnpm-workspace.yaml` 中设置 `packages` 是否存在区别？”
>
> <img src="https://s2.loli.net/2023/05/29/sU1pQTHG5qWSzDh.png" alt="image-20230529181659686" style="zoom:50%;" />

新建两个项目（比如说是 vue 项目），在每个子项目的目录下，都有一个独立 `package.json` 文件

在 Monorepo 项目的根目录下运行 `pnpm install` 命令，将会为所有工作空间自动安装依赖

###### 安装公共依赖包

使用 `-w` 选项

```sh
pnpm install react -w
pnpm install rollup -wD # 安装开发依赖
```

> 💡根据 [pnpm doc - `pnpm add <pkg>`](https://pnpm.io/zh/cli/add) 的说法，`-w` 是 `--ignore-workspace-root-check`
>
> > ##### `--ignore-workspace-root-check`
> >
> > 除非使用 `--ignore-workspace-root-check` 或 `-w` 来标记，否则在 root workspace 包添加依赖项时会失败。例如， `pnpm add debug -w`
>
> 💡 根据文档所说，依赖安装时默认是无法以 “Monorepo 全局” 层级安装的

###### 给某个子项目单独安装指定依赖

使用 `--filter` 选项，可见 [[#pnpm 过滤 `--filter`]]

```sh
pnpm add axios --filter @package1
```

###### 模块之间的相互依赖

```sh
pnpm install @package2 -r --filter @package1
```

在设置依赖版本的时候推荐用 `workspace:*` ，这样就可以保持依赖的版本是工作空间里最新版本，不需要每次手动更新依赖版本。

##### pnpm Monorepo 优缺点

###### 优点

- 天然支持 Monorepo（在根目录给所有空间安装依赖、在根目录单独给子包安装依赖）

###### 缺点

- 需要手动提升公共依赖

- 需要手动指定任务 ( dev, build ) 执行，任务不支持并行执行，影响构建速度

- 不支持自动版本控制，需要依赖第三方工具，官方推荐两个工具 [changesets](https://github.com/changesets/changesets)、[Rush](https://rushjs.io)

- 没有通用的脚手架模板

- 不支持缓存

- 不支持依赖分析

> 👀 这里后面还介绍了 Lerna 和 Turborepo 的使用方法和优缺点，由于介绍的有点混乱，且不体系；这里不做摘抄，有时间的话还是专门去了解一下这两个工具。

摘自：[初识Monorepo](https://juejin.cn/post/7237145375311839289)



## 微前端

// TODO

[理解微前端](https://mdnice.com/writing/4cf8361de47d43d887982a755445edd1) ：已经看完，感觉很不错，也涉及了和 component islands pattern 的比较

[mirco-frontends 官网](https://micro-frontends.org)

[martin fowler - Micro Frontends](https://martinfowler.com/articles/micro-frontends.html)



## pnpm



#### `pnpm env <cmd>`

管理 Node.js 环境。💡 类似于 nvm 和 n 等包管理工具

##### 命令行

安装并使用指定版本的 Node.js。

###### 安装 LTS 版本的 Node.js

```bash
pnpm env use --global lts
pnpm env use --global argon
```

###### 安装 v16 的Node.js

```bash
pnpm env use --global 16
```

###### 安装 Node.js 的预发行版本

```bash
pnpm env use --global nightly
pnpm env use --global rc
pnpm env use --global 16.0.0-rc.0
pnpm env use --global rc/14
```

###### 安装最新版本的 Node.js

```bash
pnpm env use --global latest
```

##### 配置项

- `--global` , `-g`：此更改将全局生效。

摘自：[pnpm doc - `pnpm env <cmd>`](https://pnpm.io/zh/cli/env)



#### Workspace

pnpm has <font color=dodgerBlue>built-in support for monorepositories</font>（👀 即 monorepo ），You can <font color=red>create a workspace to unite multiple projects inside a single repository</font>.

<font color=red>A workspace **must** have a [`pnpm-workspace.yaml`](https://pnpm.io/pnpm-workspace_yaml) file in its root</font>. A workspace also <font color=LightSeaGreen>**may** have an `.npmrc` in its root</font>.

##### Workspace protocol ( `workspace:` )

<font color=dodgerBlue>**By default**</font>, <font color=red>pnpm will **link packages from the workspace**</font> <font color=LightSeaGreen>if the available packages match the declared ranges</font>. For instance, <font color=red>`foo@1.0.0` is linked into `bar` **if `bar` has `"foo": "^1.0.0"` in its dependencies**</font> and <font color=fuchsia>`foo@1.0.0` is in the workspace</font>. However, if `bar` has `"foo": "2.0.0"` in dependencies and <font color=dodgerBlue>**`foo@2.0.0` is not in the workspace**</font>, `foo@2.0.0` will be installed from the registry（👀 注意与下面 workspace 的行为对比）. This behavior introduces some uncertainty（🌏 该行为将会引入不确定性）.

Luckily, <font color=red>**pnpm supports the `workspace:` protocol**</font>. <font color=dodgerBlue>When this protocol is used</font>, <font color=fuchsia>pnpm will **refuse to resolve to anything other than a local workspace package**</font>. So, <font color=dodgerBlue>**if you set `"foo": "workspace:2.0.0"`**</font> , <font color=fuchsia>**this time installation will fail** because `"foo@2.0.0"` isn't present in the workspace</font>.

This protocol is especially useful when the [link-workspace-packages](https://pnpm.io/npmrc#link-workspace-packages) option is set to `false` . <font color=dodgerBlue>In that case</font>, <font color=red>pnpm will only link packages from the workspace **if the `workspace:` protocol is used**</font>.

###### Referencing workspace packages through aliases

<font color=dodgerBlue>Let's say you have a package in the workspace named `foo`</font> . <font color=dodgerBlue>**Usually**</font>, <font color=red>you would reference it as `"foo": "workspace:*"`</font> .

If you want to use a different alias, the following syntax will work too: `"bar": "workspace:foo@*"` .

<font color=fuchsia>Before publish, **aliases are converted to regular aliased dependencies**</font>. The <font color=LightSeaGreen>above example will become: `"bar": "npm:foo@1.0.0"`</font> .

###### Referencing workspace packages through their relative path

In a workspace with 2 packages:

```text
+ packages
    + foo
    + bar
```

`bar` may have `foo` in its dependencies declared as `"foo": "workspace:../foo"` . Before publishing, these specs are converted to regular version specs supported by all package managers.

###### Publishing workspace packages

When a workspace package is packed into an archive (whether it's through `pnpm pack` or one of the publish commands like `pnpm publish` ), <font color=dodgerBlue>we **dynamically replace** any `workspace:` dependency by</font>:

- The corresponding version in the target workspace (if you use `workspace:*` , `workspace:~` , or `workspace:^` )
- The associated semver range (for any other range type)

So for example, if we have `foo` , `bar` , `qar` , `zoo` in the workspace and they all are at version `1.5.0` , the following:

```json
{
    "dependencies": {
        "foo": "workspace:*",
        "bar": "workspace:~",
        "qar": "workspace:^",
        "zoo": "workspace:^1.5.0"
    }
}
```

<font color=dodgerBlue>Will be transformed into:</font>

```json
{
    "dependencies": {
        "foo": "1.5.0",
        "bar": "~1.5.0",
        "qar": "^1.5.0",
        "zoo": "^1.5.0"
    }
}
```

This feature allows you to depend on your local workspace packages while <font color=fuchsia>still being able to publish the resulting packages to the remote registry without needing intermediary publish steps</font> - <font color=red>your consumers will be able to use your published workspaces as any other package</font>, still benefitting from the guarantees semver offers.

摘自：[pnpm doc - Workspace](https://pnpm.io/workspaces#workspace-protocol-workspace)



#### pnpm 过滤 `--filter`

// TODO

[pnpm doc - Filtering](https://pnpm.io/zh/filtering)



#### 幻影依赖

[幻影依赖【渡一教育】](https://www.bilibili.com/video/BV1UN4y1k7Ce)



## yarn

#### PnP

通过“沉浸式翻译” GPT-4 翻译浏览了一下 https://classic.yarnpkg.com/en/docs/pnp/ 的内容。不过，感觉自己对于 pnpm 的类似机制并不了解，所以 PnP 看起来也是有些困难，有空可以再看一遍，并做一下笔记...

另外，还有 [Yarn 的 Plug'n'Play 特性](https://loveky.github.io/2019/02/11/yarn-pnp/) ，看完了感觉很不错，官方文档的介绍偏理论，这篇偏实践。



## Babel

##### 一些资料

- [Babel 官网](https://babel.dev)
- [babel-handbook](https://github.com/jamiebuilds/babel-handbook)

- [神说要有光 - Babel 插件通关秘籍 ](https://juejin.cn/book/6946117847848321055/section) 这也是这里 Babel 笔记的主要摘抄



### 《Babel 插件通关秘籍》笔记



#### Babel 介绍

babel 是 JS 的转译器 (  JavaScript Transpiler ) 👀 详见 [[#编译器和转译器]]

##### 命名演化

babel 最开始叫 6to5，顾名思义是 es6 转 es5，但是后来随着 es 标准的演进，有了 es7、es8 等， 6to5 的名字已经不合适了，所以改名为了 babel。

##### Babel 的三种用途

###### 转译 ES Next、TypeScript、Flow 等到目标环境支持的 js

这个是<font color=red>最常用的功能</font>，用来把代码中的 ES Next 的新的语法、TypeScript 和 Flow 的语法转成基于目标环境支持的语法的实现。并且还可以把目标环境不支持的 api 进行 polyfill。

> 💡 还有 jsx 的编译

<font color=red>babel7 提供了 @babel/preset-env 的包</font>，可以<font color=red>指定目标 env 来按需转换，转换更加的精准，产物更小</font>。

###### 一些特定用途的代码转换

babel 是一个转译器，暴露了很多 api，用这些 api 可以完成<font color=red>代码到 AST 的解析、转换、以及目标代码的生成</font>。

<font color=dodgerBlue>开发者可以用它来完成一些特定用途的转换</font>，比如<font color=red>函数插桩</font>（<font color=red>函数中自动插入一些代码</font>，例如<font color=red>埋点代码</font>）、<font color=red>自动国际化</font>等。<font color=LightSeaGreen>流行的小程序转译工具 taro，就是基于 babel 的 api 来实现的</font>。

###### 代码的静态分析

<font color=red>对代码进行 parse 之后，会生成 AST，通过 AST 能够理解代码结构</font>，除了转换 AST 再打印成目标代码之外，也同样<font color=red>可以**用于分析代码的信息，进行一些静态检查**</font>。

- <font color=red>linter 工具</font>就是分析 AST 的结构，对代码规范进行检查。
- <font color=LightSeaGreen>api 文档自动生成工具</font>，可以提取源码中的注释，然后生成文档。
- <font color=red>type checker</font> 会根据从 AST 中提取的或者推导的类型信息，对 AST 进行类型是否一致的检查，从而减少运行时因类型导致的错误。👀 比如 tsc
- <font color=red>压缩混淆工具</font>，这个也是分析代码结构，进行删除死代码、变量名混淆、常量折叠等各种编译优化，生成体积更小、性能更优的代码。
- JS 解释器，除了对 AST 进行各种信息的提取和检查以外，我们<font color=red>还可以直接解释执行 AST</font>。



#### Babel 的编译流程

##### 编译器和转译器

编译的定义就是从一种编程语言转成另一种编程语言。主要指的是高级语言到低级语言。

<font color=LightSeaGreen>一般编译器 Compiler 是指高级语言到低级语言的转换工具</font>。而<font color=fuchsia>从 **高级语言** 到 **高级语言** 的 **转换工具**，被叫做 <font size=4>**转换编译器**</font>，简称 **转译器** ( Transpiler )</font>。Babel 就是一个 JavaScript Transpiler。

##### Babel 的编译流程

<font color=fuchsia>Babel 是 **source to source 的转换**</font>，整体编译流程分为三步：

- **parse**：通过 <font color=red>parser 把源码转成抽象语法树 ( AST )</font>
- **transform**：<font color=red>遍历 AST，调用各种 transform 插件对 AST 进行增删改</font>
- **generate**：把<font color=red>转换后的 AST 打印</font>（👀 生？）<font color=red>成目标代码</font>，并 <font color=fuchsia size=4>**生成 sourcemap**</font>

![img](https://s2.loli.net/2023/01/03/79luiCsc6EPqxfA.png)

##### 为什么 babel 的编译流程会分 parse、transform、generate 这 3 步

源码是一串按照语法格式来组织的字符串，<font color=LightSeaGreen>人能够认识，但是计算机并不认识</font>；<font color=red>想让计算机认识就要转成一种数据结构，通过不同的对象来保存不同的数据，并且按照依赖关系组织起来</font>；这种数据结构就是抽象语法树 ( abstract syntax tree )。

之所以叫“抽象”语法树是因为<font color=red>数据结构中省略掉了一些无具体意义的分隔符比如 `;` `{` `}`等</font> 

> 💡 参考 [编程语言的发展趋势：从没有分号，到DSL](https://mp.weixin.qq.com/s/_SOlzlLG6ua8kXxnPltX0g) 中所说：
>
> > 在大多数情况下，分号是给机器看的，而不是给人看的。**写分号，本质是我们人类在迁就编译器**，毕竟，机器是很傻的。
>
> 类似的，`{}` 括号也是。

有了 AST，计算机就能理解源码字符串的意思，而理解是能够转换的前提，所以编译的第一步需要把源码 parse 成 AST。

转成 AST 之后就可以通过修改 AST 的方式来修改代码，<font color=red>这一步会遍历 AST 并进行各种增删改</font>，<font color=LightSeaGreen>这一步也是 babel 最核心的部分</font>。

经过转换以后的 AST 就是符合要求的代码，就可以再转回字符串，<font color=red>转回字符串的过程中把之前删掉的一些分隔符再加回来</font>。

<font color=dodgerBlue>**简单总结**</font>：**为了让计算机理解代码需要先对源码字符串进行 parse，生成 AST，把对代码的修改转为对 AST 的增删改，转换完 AST 之后再打印成目标代码字符串。**

##### parse、transform、generate 三步做了什么

###### parse

parse 阶段的目的是把源码字符串转换成机器能够理解的 AST，这个过程<font color=fuchsia>分为 **词法分析**、**语法分析**</font>。

比如 `let name = 'guang';` 这样一段源码，我们要<font color=red>先把它分成一个个不能细分的单词</font> ( token )，也就是 `let` , `name` , `=` , `'guang'` ，<font color=fuchsia>这个过程是 **词法分析**</font>，按照单词的构成规则来拆分字符串成单词。

之后要<font color=fuchsia>把 token 进行递归的组装，生成 AST</font>，<font color=fuchsia>这个过程是 **语法分析**</font>；按照不同的语法结构，来把一组单词组合成对象，比如<font color=red>声明语句、赋值表达式等都有对应的 AST 节点</font>。

<img src="https://s2.loli.net/2023/01/03/2r3SovJbGRWmuAx.png" alt="img" style="zoom:35%;" />

###### transform

transform 阶段是对 parse 生成的 AST 的处理，会<font color=red>进行 AST 的遍历</font>，<font color=red>遍历的过程中处理到不同的 AST 节点会</font> <font color=fuchsia>调用注册的 **相应的 visitor 函数**</font>，<font color=red>visitor 函数里可以对 AST 节点进行增删改，返回新的 AST</font>（可以指定是否继续遍历新生成的 AST）。这样遍历完一遍 AST 之后就完成了对代码的修改。

<img src="https://s2.loli.net/2023/01/03/FkptO2ITlQL1vnA.png" alt="img" style="zoom:40%;" />

###### generate

generate 阶段会把 AST 打印成目标代码字符串，并且会生成 sourcemap。<font color=fuchsia>不同的 AST 对应的不同结构的字符串</font>，比如 <font color=red>`IfStatement` 就可以打印成 `if (test) {}` 格式的代码</font>。这样从 AST 根节点进行递归的字符串拼接，就可以生成目标代码的字符串。

<img src="https://s2.loli.net/2023/01/03/F2IV9cSkPGs4NfC.png" alt="img" style="zoom:35%;" />

sourcemap 记录了源码到目标代码的转换关系，通过它我们可以找到目标代码中每一个节点对应的源码位置，用于调试的时候把编译后的代码映射回源码，或者线上报错的时候把报错位置映射到源码。



#### Babel 的 AST

AST 是对源码的抽象，<font color=red>字面量、标识符、表达式、语句、模块语法、class 语法都有各自的 AST</font>。

##### Literal 字面量

`let name = 'guang'` 中，`'guang'` 就是一个字符串字面量 StringLiteral，相应的还有数字字面量 NumericLiteral ，布尔字面量 BooleanLiteral ，字符串字面量 StringLiteral，正则表达式字面量 RegExpLiteral 等。

下面这些字面量都有对应的 Literal 节点：

<img src="https://s2.loli.net/2023/01/23/GBczVNK6COvZX4l.png" alt="" style="zoom: 33%;" />

代码中的字面量很多，babel 就是通过 xxLiteral 来抽象这部分内容的。

##### Identifier

Identifer 是标识符的意思，变量名、属性名、参数名等各种声明和引用的名字，都是 Identifer。



## PostCSS

> 💡 PostCSS 具有丰富的插件生态，详见 [[#插件有哪些？]]

#### 峰华前端的《13 分钟掌握 PostCSS》笔记

PostCSS 是专门用于处理 CSS 的工具，通过一系列的插件来修改最终样式：可以让开发者使用最新的 CSS 特性（哪怕提案处于 stage 0，配置示例见下面代码）提高开发效率（通过使用 [PostCSS-Preset-env](https://github.com/csstools/postcss-preset-env) 。不过原库已经 archived，并入了 [postcss-plugins](https://github.com/csstools/postcss-plugins) 。另外，所有 staged 的 CSS 特性，见 [postcss-preset-env - feature](https://preset-env.cssdb.org/features/) ）；也可以转译 CSS，兼容大多数浏览器（类似于 Babel ）；PostCSS 通过插件，支持 Sass 之类 CSS 预处理工具。

使用 [autoprefixer](https://github.com/postcss/autoprefixer) 可以查看哪些 CSS 属性、值 、选择器、`@rules` 是需要加上浏览器前缀的，使用 `npx autoprefixer --info` 即可输出内容，输出内容略。

使用 PostCSS 命令行工具 [PostCSS CLI](https://github.com/postcss/postcss-cli) 可以通过命令行的方式运行 PostCSS：

```sh
npx postcss input.css -o output.css -u yourPostCssPlugin
```

通用的语法见 [PostCSS CLI - README](https://github.com/postcss/postcss-cli) 。不过这样过于麻烦，可以通过 配置文件（配置 `postcss.config.js` 文件） 的方法，设置 `yourPostCssPlugin` ；使得即使在不使用 webpack 之类工具的情况下，至少不需要输入 `-u yourPostCssPlugin` 。使用 npm scripts 甚至可以省去前面（固定）的代码

```js
// postcss.config.js
const postcssPresetEnv = require('postcss-preset-env')

module.exports = {
  plugins: [
    require('stylelint'),
    require('autoprefixer'),
    postcssPresetEnv({
      stage: 0 // 可以使用提案在 stage 0 的新特性
    }),
    require('postcss-pxtorem')
  ]
}
```

CSS 也有自己的 lint 工具  [stylelint](https://github.com/stylelint/stylelint) 以及 它基本的规则 [stylelint-config-standard](https://github.com/stylelint/stylelint-config-standard) ；使用 stylelint 创建 `.stylelintrc.json` 配置文件，并在 `postcss.config.js` 配置文件中注册（注册见上面）：

```json
// .stylelintrc.json
{
  "extends": "stylelint-config-standard"
}
```

在开发时需要将 px 转换为 rem，这时候可以使用插件 [postcss-pxtorem](https://github.com/cuth/postcss-pxtorem) （类似的有 [px2rem](https://github.com/songsiqi/px2rem) ），不过前者 Star 更多

学习自：[13 分钟掌握 PostCSS](https://bilibili.com/video/BV1Pd4y1S7Mp)

相关的，在 [[Vue3 + TS 学习笔记#PostCSS 工具]] 中也有 PostCSS 的笔记

### Tecvan《零基础理解 PostCSS 的主流程》笔记

官网说：“PostCSS，一个使用 JavaScript 来处理 CSS 的框架” ( A tool for transforming CSS with JavaScript )。这句话高度概括了 PostCSS 的作用，但是太抽象了。按我理解，PostCSS 主要做了三件事：

1. **parse**：<font color=red>把 CSS 文件的字符串解析成抽象语法树 ( Abstract Syntax Tree ) 的框架</font>，<font color=fuchsia>解析过程中会检查 CSS 语法是否正确，不正确会给出错误提示</font>。
2. **runPlugin**：<font color=fuchsia>**执行插件函数**</font>。<font color=fuchsia>**PostCSS 本身不处理任何具体任务**，它提供了以特定属性或者规则命名的事件</font>。有特定功能的插件（如 autoprefixer、CSS Modules ）会注册事件监听器。PostCSS 会在这个阶段，重新扫描 AST，执行注册的监听器函数。
3. **generate**：<font color=fuchsia>插件对 AST 处理后，PostCSS 把处理过的 AST 对象转成 CSS string</font>。

![图片](https://s2.loli.net/2022/08/11/RDNvjWZ72KdySeh.png)

<font color=red>**「如果没有插件」**，那么初始传入的 CSS string 和 generate 生成的 CSS string 是一样的</font>。由此可见，<font color=fuchsia>PostCSS 本身并不处理任何具体的任务，只有当我们为其附加各种插件之后，它才具有实用性</font>。

下面分别详细分析三个阶段做的事。

#### 第一阶段：parse

<font color=dodgerBlue>CSS 规则集 ( rule-set ) 由选择器和声明块组成</font>：

![图片](https://s2.loli.net/2022/08/12/Z9Dtvd1efCRGJhP.png)

- **选择器** 指向您需要设置样式的 HTML 元素
- <font color=red>**声明块** 包含一条或多条用分号分隔的声明</font>
- 每条 **声明** 都包含一个 CSS 属性名称和一个值，以冒号分隔
- 多条 **CSS 声明** 用分号分隔，声明块用花括号括起来

##### 五类对象

<font color=fuchsia>AST 用 **五类对象** 描述 CSS 语法</font>。<font color=dodgerBlue>这里举个具体的例子，再打印出对应的 AST 结果，**对照了解 AST 五类对象和 CSS 语法的对应关系**</font>。

`app.css` 文件中写如下内容：

```css
@import url('./app-02.css');

.container {
  color: red;
}
```

##### Declaration 对象

<font color=fuchsia>Declaration 对象用来 **描述 CSS 中的每一条声明语句**</font>

- **type**：<font color=red>标记当前对象的类型</font>
- **parent**：<font color=red>记录父对象的实例</font>
- **prop**：记录声明中的属性名
- **value**：记录声明中的值
- **raws**：<font color=red>字段记录声明前的字符串、声明属性和值之间的符号的字符串</font>
- 其余字段（比如 `source` 及其子字段、`Symbol(prop)` ）解释见代码中的注释

上边 CSS 文件中的 `color: red;` 会被描述成如下对象：

```json
{
  parent: Rule,    // 外层的选择器被转译成 Rule 对象，是当前声明对象的 parent
  prop: "color",   // prop 字段记录声明的属性
  raws: {          // raws 字段记录声明前、后的字符串，声明属性和值之间的字符串，以及前边语句是否分号结束。
    before: '\n ', // raws.before 字段记录声明前的字符串
    between: ': ', // raws.between 字段记录声明属性和值之间的字符串
  },
  source: { // source 字段记录声明语句的开始、结束位置，以及当前文件的信息
    start: { offset: 45, column: 3, line: 4 },
    end: { offset: 55, column: 13, line: 4 },
    input: Input {
      css: '@import url('./app-02.css');\n\n.container {\n  color: red;\n}',
      file: '/Users/admin/temp/postcss/app.css',
      hasBOM: false,
      Symbol(fromOffsetCache): [0, 29, 30, 43, 57]
    }
  },
  Symbol('isClean'): false,  // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true, // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype 属性
  type: 'decl',      // type 记录对象类型，是个枚举值，声明语句的 type 固定是 decl
  value: "red"       // value 字段记录声明的值
}
```

##### Rule 对象

<font color=fuchsia>Rule 对象是 **描述选择器** 的</font>

- **type**：记录对象的类型
- **parent**：记录父对象的实例
- **nodes**：<font color=red>记录子对象的实例</font>
- **selector**：<font color=red>记录选择器的字符串</font>
- **raws**：<font color=red>记录选择器前的字符串、选择器和大括号之间的字符串、最后一个声明和结束大括号之间的字符串</font>
- 其余字段解释见代码中的注释

上边 `app.css` 文件中 `.container` 经过 postcss 转译后的对象是（每个字段的含义和功能已经以注释的形式进行了解释）：

```json
{
  nodes: [Declaration],  // nodes 记录包含关系，Rule 对象包含 Declaration 对象
  parent: Root,          // 根对象是 Root 对象，是当前声明对象的 parent
  raws: {                // raws 字段记录如下
    before: '\n\n',      // raws.before 字段记录选择器前的字符串
    between: ' ',        // raws.between 字段记录选择器和大括号之间的字符串
    semicolon: true,     // raws.semicolon 字段记录前置声明语句是正常分号结束
    after: '\n'          // raws.after 字段记录最后一个声明和结束大括号之间的字符串
  },
  selector:'.container', // selector 记录 selector
  source: {              // source 字段记录选择器语句的开始、结束位置，以及当前文件的信息
    start: { offset: 30, column: 1, line: 3 },
    input: Input {
      css: '@import url('./app-02.css');\n\n.container {\n  color: red;\n}',
      file: '/Users/admin/temp/postcss/app.css',
      hasBOM: false,
      Symbol(fromOffsetCache): [0, 29, 30, 43, 57]
    },
    end: { offset: 57, column: 1, line: 5 }
  },
  Symbol('isClean'): false, // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true,       // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype
  type: 'rule'              // type 记录对象类型，是个枚举值，声明语句的 type 固定是 rule
}
```

##### AtRule 对象

<font color=fuchsia>CSS 中除了选择器，还有一类语法是 `@` 开头的</font>，例如 `@import`、`@keyframes`、`@font-face`，PostCSS 把这类语法解析成 AtRule 对象。👀 注：它本身的名字也叫 `@rules`

- **type**：记录当前对象的类型
- **parent**：记录当前对象的父对象
- **name**：记录 <font color=red>`@` 紧跟着的单词</font>
- **params**：记录 name 对应的值

例如 `@import url("./app-02.css");` 将被解析成如下对象：

```json
{
  name: "import",                // name 记录 @ 紧跟着的单词
  params: "url('./app-02.css')", // params 记录 name 对应的值
  parent: Root,                  // parent 记录父对象
  raws: {                        // raws 字段记录如下
    before: '',                  // raws.before 记录 @语句前的空字符串
    between: '',                 // raws.between 记录 name 和 { 之间的空字符串
    afterName: '',               // raws.afterName 记录 name 和 @ 语句之间的空字符串
    after: '',                   // raws.after 记录大括号和上一个 rule 之间的空字符串
    semicolon: false             // raws.semicolon 上一个规则是否是分号结束
  },
  source: {                      // source 字段记录@语句的开始，以及当前文件的信息
    start: { offset: 0, column: 1, line: 1 },
    end: { offset: 27, column: 28, line: 1 },
    input: Input {
      css: '@import url('./app-02.css');\n\n.container {\n  color: red;\n}',
      file: '/Users/admin/temp/postcss/app.css',
      hasBOM: false,
      Symbol(fromOffsetCache): [0, 29, 30, 43, 57]
    }
  },
  Symbol('isClean'): false,  // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true,        // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype
  type: 'atrule'          // type 记录对象类型，是个枚举值，声明语句的 type 固定是 atrule
}
```

##### Comment 对象

<font color=fuchsia>CSS 文件中的注释被解析成 Comment 对象</font>。text 字段记录注释内容。`/* 你好 */  `被解析成：

```json
{
  parent: Root,    // parent 记录父对象
  raws: {          // raws 字段记录如下
    before: '',    // raws.before 记录注释语句前的空字符串
    left: ' ',     // raws.left 记录注释语句左侧的空字符串
    right: ' '     // raws.right 记录注释语句右侧的空字符串
  },
  source: {        // source 字段记录注释语句的开始、结束位置，以及当前文件的信息
    start: {…}, 
    input: Input, 
    end: {…}
  },
  Symbol('isClean'): false, // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true,       // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype
  text: '你好',              // text 记录注释内容
  type: 'comment'           // type 记录对象类型，是个枚举值，声明语句的 type 固定是 comment
}
```

##### 图解五类对象之间的继承关系

从上一段可以知道，<font color=LightSeaGreen>CSS 被解析成 Declaration、Rule、Root、AtRule、Comment 对象</font>。<font color=fuchsia>**这些对象有很多 公共方法，PostCSS 用了面向对象的继承思想，把公共方法和公共属性提取到了父类中**</font>。

<font color=fuchsia>**Root、Rule、AtRule** 都是可以有子节点的</font>，都有 nodes 属性，<font color=fuchsia>**他们三个继承自 Container 类**</font>，对 nodes 的操作方法都写在 Container 类中。

<font color=fuchsia>**Container、Declaration、Comment** **继承自 Node 类**</font>，所有对象都有 `Symbol('isClean')` 、`Symbol('my')`、raws、source、type 属性，都有 `toString()`、`error()` 等方法，这些属性和方法都定义在 Node 类中。

**Container、Node** 是用来提取公共属性和方法，不会生成他们的实例。

<font color=dodgerBlue>五个类之间的继承关系如下图所示：</font>

![Image](https://s2.loli.net/2022/08/12/c6po81SKtVYMnXv.png)

图中没有穷举类的方法，全部的方法 可以看直接看源码文件: https://github.com/postcss/postcss/tree/main/lib

#### 第二阶段：runPlugin

<font color=LightSeaGreen>PostCSS 本身并不处理任何具体的任务，只有当我们为其附加各种插件之后，它才具有实用性</font>。

<font color=fuchsia>PostCSS 在把 CSS string 解析成 AST 对象后，会扫描一边 AST 对象</font>，<font color=fuchsia>**每一种 AST 的对象都可以有对应的监听器**</font>。<font color=red>在遍历到某类型的对象时，如果有对象的监听器，就会执行其监听器</font>。

##### 第一类监听器

PostCSS 提供的**「以特定属性或者规则命名」**的事件监听器，如下：

> CHILDREN 代表子节点的事件监听器。

```js
// root
['Root', CHILDREN, 'RootExit']

// AtRule
['AtRule', 'AtRule-import', CHILDREN, 'AtRuleExit', 'AtRuleExit-import']

// Rule
['Rule', CHILDREN, 'RuleExit']

// Declaration
['Declaration', 'Declaration-color', 'DeclarationExit', 'DeclarationExit-color']

// Comment
['Comment', 'CommentExit']
```

PostCSS 以 <font color=fuchsia size=4>**深度优先** 的方式遍历 AST 树</font>。

- <mark style="background: lightpink">**遍历到 Root 根对象**，**第一步** 会执行所有插件注册的 Root 事件监听器，**第二步** 检查 Root 是否有子对象，如果有，则遍历子对象，执行子对象对应的事件监听器；如果没有子对象，则直接进入第三步；**第三步** 会执行所有插件注册的 RootExit 事件监听器</mark> （👀 注：这就是 DFS 的步骤）。

  <font color=red>插件注册的 Root、RootExit 事件的监听器 **只能是函数**</font>。函数的第一个参数是当前访问的 AST 的 Root 对象，第二个参数是 postcss 的 Result 对象和一些其他属性，通过 Result 对象可以获取 css string、opts 等信息。

  ```js
  {
    Root: (rootNode, helps) => {},
    RootExit: (rootNode, helps) => {}
  }
  ```

- **遍历到 Rule 对象**，则<mark style="background: lightpink">和访问 Root 根对象是一样的逻辑</mark>，先执行所有插件注册的 Rule 事件监听器，再遍历子对象，最后执行所有插件注册的 RuleExit 事件监听器。<font color=red>插件注册的 Rule、RuleExit 事件的监听器 **只能是函数**</font>。

  ```js
  {
    Rule: (ruleNode, helps) => {},
    RuleExit: (ruleNode, helps) => {}
  }
  ```

- **遍历到 AtRule 对象**。<font color=red>插件注册的 AtRule 的事件监听器 **可以是函数**，**也可以是对象**</font>。对象类型的监听器，对象属性的 key 是 AtRule 对象的 name 值，value 是函数。<mark style="background: lightpink">AtRuleExit 是一样的逻辑</mark>。<font color=fuchsia>事件的执行顺序是：`['AtRule', 'AtRule-import', CHILDREN, 'AtRuleExit', 'AtRuleExit-import']` </font>。CHILDREN 代表子节点的事件。

  ```js
   // 函数
  { 
    AtRule: (atRuleNode, helps) => {}
  }
  
  // 对象
  {
    AtRule: {
      import: (atRuleNode, helps) => {},
      keyframes: (atRuleNode, helps) => {}
    }
  }
  ```

- **遍历到 Declaration 对象**。<font color=red>插件注册的 Declaration 的事件监听器 **可以是函数，也可以是对象**</font>，对象属性的 key 是 Declaration 对象的 prop 值，value 是函数。<mark style="background: lightpink">DeclarationExitExit 是一样的逻辑</mark>。<font color=fuchsia>事件的执行顺序是：`['Declaration', 'Declaration-color', 'DeclarationExit', 'DeclarationExit-color']`</font> 。**Declaration 没有子对象，只需要执行当前对象的事件，不需要深度执行子对象的事件**。

  ```js
  // 函数
  {
    Declaration: (declarationNode, helps) => {}
  }
  
  // 对象
  {
    Declaration: {
      color: (declarationNode, helps) => {},
      border: (declarationNode, helps) => {}
    }
  }
  ```

- **遍历到 Comment 对象**。依次执行所有插件注册的 Comment 事件监听器，再执行所有插件注册的 CommentExit 事件监听器。

##### 第二类监听器

<font color=dodgerBlue>除以特定属性或者规则命名的事件监听器，**PostCSS 还有以下四个**</font>（👀 注：三个方法，一个插件名称）：

```js
{
  postcssPlugin: string,
  prepare: (result) => {},
  Once: (root, helps) => {},
  OnceExit: (root, helps) => {},
}
```

PostCSS 插件事件的整体执行是：`[prepare, Once, ...一类事件, OnceExit]`，<font color=red>**postcssPlugin 是插件名称**</font>，不是事件监听器。

- **postcssPlugin**：字符串类型，<font color=red>插件的名字，在插件执行报错，提示用户是哪个插件报错了</font>。

- **prepare**：函数类型，<font color=red>prepare 是最先执行的，在所有事件执行前执行的</font>，插件多个监听器间共享数据时使用。prepare 的入参是 Result 对象，返回值是监听器对象，通过 Result 对象可以获取 css string、opts 等信息。

  ```js
  {
    postcssPlugin: "PLUGIN NAME",
    prepare(result) {
      const variables = {};
      return {
        Declaration(node) {
          if (node.variable) {
            variables[node.prop] = node.value;
          }
        },
        OnceExit() {
          console.log(variables);
        },
      };
    },
  };
  ```

- **Once**：函数类型，<font color=red>在 prepare 后，一类事件前执行</font>，Once <font color=red>只会执行一次</font>。

  ```js
  {
     Once: (root, helps) => {}
  }
  ```

- **OnceExit**：函数类型，<font color=red>在一类事件后执行</font>，OnceExit <font color=red>只会执行一次</font>。

###### 插件有哪些？

[postcss Github - docs - PostCSS plugins](https://github.com/postcss/postcss/blob/main/docs/plugins.md) 列出了大量的 postcss plugin，就相当于 awesome postcss

> 💡 还有 [PostCSS.parts](https://www.postcss.parts/) 是一个 postcss 插件搜索工具
>
> > A searchable catalog of PostCSS plugins

> 💡 这里做一些 postcss 插件的介绍
>
> - [purgecss](https://github.com/FullHuman/purgecss) ：Remove unused CSS
>
> - [cssnano](https://github.com/cssnano/cssnano) ：A modular minifier, built on top of the PostCSS ecosystem. ( css 代码压缩工具)
>
> - [postcss-modules](https://github.com/madyankin/postcss-modules) : PostCSS plugin to use CSS Modules everywhere（给 css class 类名上加上 hash，使其具有不被同名 class 干扰）
>
> - [css-has-pseudo](https://github.com/csstools/postcss-plugins/tree/main/plugins/css-has-pseudo#readme) ：`:has()` 伪类的 postcss polyfill。下图是 `:has()` 的兼容性，可见：在 Chrome 105 和 Safari 15.4 才支持，兼容性很一般
>
>   <img src="https://s2.loli.net/2024/01/05/MF4fxCWVZ9vqr37.png" alt="image-20240105095547701" style="zoom:50%;" />

#### 第三阶段：generate

generate 的过程<font color=fuchsia>依旧是以深度优先的方式遍历 AST 对象，**针对不同的实例对象进行字符串的拼接**</font>。算法对应源码中位置是：`postcss/lib/stringifier.js` 中的 `stringify ` 方法，代码量不大，可自行查看。

摘自：[零基础理解 PostCSS 的主流程](https://mp.weixin.qq.com/s/Bkss0lzPT-TI6GyGxMyn3Q)



## npm & package.json



#### npm 命令

##### npm add

> 👀 `npm add` 命令是我在 [Vite Doc - 使用插件 # 添加一个插件](https://cn.vitejs.dev/guide/using-plugins.html#adding-a-plugin) 中的 `npm add -D @vitejs/plugin-legacy` 发现的

`npm add` 是 `npm install` 的别名。

另外，在 npm 8.x 中加入了新的特性： `npm isntall`、`npm instal` 同样是可以执行的，且效果和 `npm install` 一致（换句话说：以上命令是 `npm install` 的别名）。所以：`npm install` 一共有 `i, in, ins, inst, insta, instal, isnt, isnta, isntal, isntall` 这十个别名

摘自：[NPM这6个有趣实用的知识点，你知道几个？🤩](https://juejin.cn/post/7095903278084390948)



#### `.npmrc` 相关

##### `.npmrc` 的优势

相较使用 `npm config set registry registryUrl` 的方式，修改 npm 的源的配置，同时也修改了  `~/.npmrc` 中的配置。而使用 `.npmrc`（不仅仅是 `~/.npmrc` ，详见 [[#` .npmrc` 相关文档摘抄]] ） 是更好的选择：因为它提供了更细粒度的配置，比如 每个项目中local 的 `.npmrc` 。

会有这样一个问题：如果希望部分依赖下载自默认的某个源，而另一部分的依赖下载自另一个源，使用 `npm config set registry registryUrl` 的方式显然无法解决；这时可以在 `~/.npmrc` 中配置。

```ini
registry = https://registry.npm.taobao.org/
@juejin:registry = https://siyouyuan.org/
```

以上两行代码分别做了如下两件事：

1. `@juejin` 命名空间的项目，直接在私有源请求包
2. 其他包则从 `taobao` 源发起请求。

学习自：[NPM这6个有趣实用的知识点，你知道几个？🤩](https://juejin.cn/post/7095903278084390948)

##### ` .npmrc` 相关文档摘抄

###### Files

The four relevant files are

- per-project config file ( `/path/to/my/project/.npmrc` ) 👀 local config

  When working locally in a project, a `.npmrc` file <font color=LightSeaGreen>in the root of the project</font> (ie, a sibling of `node_modules` and `package.json`) will set config values specific to this project.

  Note that <font color=LightSeaGreen>this only applies to the root of the project</font> that you're running npm in（🌏 运行）. It has no effect when your module is published. For example, you can't publish a module that forces itself to install globally, or in a different location.

  Additionally, this file is not read in global mode, such as when running `npm install -g`.

- per-user config file ( `~/.npmrc` ) 👀 user config

  `$HOME/.npmrc` (or the `userconfig` param, if set in the environment or on the command line)

- global config file ( `$PREFIX/etc/npmrc` ) 👀 global config

  `$PREFIX/etc/npmrc` (or the `globalconfig` param, if set above): This file is an ini-file formatted list of `key = value` parameters. Environment variables can be replaced as above.

- npm built-in config file ( `/path/to/npm/npmrc` )

  This is an <font color=red>unchangeable "builtin" configuration file</font> that <font color=red>npm keeps consistent across updates</font>. Set fields in here using the `./configure` script that comes with npm. This is primarily for distribution maintainers to override default configs in a standard and consistent manner.

> 👀 感觉可以和 Git 的 local、global、system 三种作用域做一下类比

All npm config files are an <font color=red>**ini-formatted** list of `key = value` parameters</font>. Environment variables can be replaced using `${VARIABLE_NAME}` . For example:

```ini
prefix = ${HOME}/.npm-packages
```

Each of these files is loaded, and <font color=red>config options are resolved in priority order</font>（🌏 按优先顺序排列）. For example, a setting in the <font color=LightSeaGreen>userconfig file would override the setting in the globalconfig file</font>.

<font color=dodgerBlue>Array values are specified by adding "[]" after the key name</font>. For example:

```ini
key[] = "first value"
key[] = "second value"
```

###### Comments

Lines in `.npmrc` files are interpreted as comments when they begin with a `;` or `#` character. `.npmrc` files are parsed by [npm/ini](https://github.com/npm/ini), which specifies this comment syntax. For example:

```ini
# last modified: 01 Jan 2016
; Set a new registry for a scoped package
@myscope:registry=https://mycustomregistry.example.org
```

###### Auth related configuration

The settings `_auth`, `_authToken`, `username` and `_password` must all be scoped（🌏 限定范围的） to a specific registry. <font color=red>This ensures that `npm` will never send credentials to the wrong host</font>.

<font color=dodgerBlue>The full list is:</font>

- `_auth` (base64 authentication string)
- `_authToken` (authentication token)
- `username`
- `_password`
- `email`
- `certfile` (path to certificate file)
- `keyfile` (path to key file)

<font color=red>In order to scope these values, they must be prefixed by a URI fragment</font>. If the credential is meant for any request to a registry on a single host, the scope may look like `//registry.npmjs.org/:`. If it must be scoped to a specific path on the host that path may also be provided, such as `//my-custom-registry.org/unique/path:`.

```ini
; bad config
_authToken=MYTOKEN

; good config
@myorg:registry=https://somewhere-else.com/myorg
@another:registry=https://somewhere-else.com/another
//registry.npmjs.org/:_authToken=MYTOKEN
; would apply to both @myorg and @another
; //somewhere-else.com/:_authToken=MYTOKEN
; would apply only to @myorg
//somewhere-else.com/myorg/:_authToken=MYTOKEN1
; would apply only to @another
//somewhere-else.com/another/:_authToken=MYTOKEN2
```

摘自：[npm Docs - .npmrc](https://docs.npmjs.com/cli/v9/configuring-npm/npmrc)



#### 指定项目运行的系统环境

> 👀 相关内容可以参考 [npm doc - version 8 - package.json](https://docs.npmjs.com/cli/v8/configuring-npm/package-json)

##### 指定 项目运行的 Node 版本

如何指定项目运行的 Node 版本，可以在 `package.json` 中配置 `engines` 选项；如下示例：

```json
{
  "engines": {
    "node": ">=0.10.3 <15"
  }
}
```

##### 指定 项目运行的 OS 和 CPU 版本

```json
{
  "os": [
    "darwin",
    "linux"
  ],
  "cpu": [
    "x64",
    "ia32"
  ]
}
```

摘自：[npm doc - version 8 - package.json](https://docs.npmjs.com/cli/v8/configuring-npm/package-json)



##### 修改 node_modules 依赖代码

想要修改 node_modules 中依赖部分的代码（比如说：存在 bug），可以使用 [patch-package](https://github.com/ds300/patch-package) ，这个可以说是当前的 最佳实践。

> **About**
>
> Fix broken node modules instantly 🏃🏽‍♀️💨



### corepack

##### 简要介绍

As per [Node.js](https://nodejs.org/api/corepack.html) documentation, the corepack <font color=red>identifies the package manager</font> and <font color=red>installs in the background if needed without any user interaction</font>.

摘自：[How to Configure a React App with TypeScript, TailwindCSS, Yarn and Storybook](https://blog.bitsrc.io/how-to-configure-a-react-app-with-typescript-tailwindcss-yarn-and-storybook-a271df5d9884)

##### What's Corepack

Corepack <font color=red>makes sure you are using the correct version for package manager</font> when you run corresponding commands. <font color=red>Projects might have `packageManager` field in their `package.json`</font> .

Under projects with configuration as shown on the right（ 👀 现在是 below 了 ）, <font color=red>corepack will install `v7.1.5` of `pnpm` (if you don't have it already)</font> and use it to run your commands. <font color=fuchsia>This makes sure everyone working on this project have the same behavior for the dependencies and the lockfile</font>.

```json
// package.json
{
  "packageManager": "pnpm@7.1.5"
}
```

摘自：[GitHub - antfu/contribute](https://github.com/antfu/contribute)

#### Node Doc Intro

> 💡 Added in: v16.9.0, v14.19.0

##### 简介

*[Corepack](https://github.com/nodejs/corepack)* is an <font color=red>experimental tool</font> to help with managing versions of your package managers. It <font color=fuchsia>exposes **binary proxies**</font>（👀 本质上是 包管理工具的 二进制**代理** ）<font color=fuchsia>for each supported package manager</font>（ 👀 目前是 pnpm 和 yarn ） that, when called, will identify whatever package manager is configured for the current project, <font color=fuchsia>transparently install it if needed</font>, and finally <font color=fuchsia>run it without requiring explicit user interactions</font>.

<font color=dodgerBlue>This feature simplifies two core workflows:</font>

- <font color=LightSeaGreen>It eases new contributor onboarding</font>（加入）, since they won't have to follow system-specific installation processes anymore just to have the package manager you want them to.
- It allows you to <font color=LightSeaGreen>ensure that everyone in your team will **use exactly the package manager version** you intend them to</font>, without them having to manually synchronize it each time you need to make an update.

##### Workflows

###### Enabling the feature

<font color=dodgerBlue>Due to its experimental status</font>, Corepack currently needs to be explicitly enabled to have any effect. To do that, <font color=red>run `corepack enable`</font> , which <font color=red>will set up the symlinks in your environment next to the `node` binary</font> (and overwrite the existing symlinks if necessary).

From this point forward, any call to the *supported binaries*（👀 即 supported package manager ） will work without further setup. Should you experience a problem, <font color=red>run `corepack disable` to remove the proxies from your system</font> (and consider opening an issue on the [Corepack repository](https://github.com/nodejs/corepack) to let us know).

###### Configuring a package

The <font color=fuchsia>Corepack proxies will find the closest `package.json` file in your current directory hierarchy</font> to <font color=fuchsia>extract its `"packageManager"` property</font>.

If the value corresponds to a *supported package manager*, Corepack will make sure that all calls to the relevant binaries are run against the requested version, downloading it on demand if needed, and aborting if it cannot be successfully retrieved.

###### Upgrading the global versions

When running outside of an existing project (for example when running `yarn init` ) , <font color=red>Corepack will **by default** use predefined versions roughly corresponding to the latest stable releases from each tool</font>. <font color=fuchsia>Those versions can be overridden by running the `corepack prepare` command</font> along with the package manager version you wish to set:

```bash
corepack prepare yarn@x.y.z --activate
```

Alternately, a tag or range may be used:

```bash
corepack prepare pnpm@latest --activate
corepack prepare yarn@stable --activate
```

摘自：[Node Doc - Corepack](https://nodejs.org/api/corepack.html)



## Vite

前端工程都有哪些痛点呢？

首先是前端的**模块化需求**。我们知道，业界的模块标准非常多，包括 ESM、CommonJS、AMD 和 CMD 等等。前端工程一方面需要落实这些模块规范，保证模块正常加载；<font color=lightSeaGreen>另一方面需要兼容不同的模块规范，以适应不同的执行环境</font>。

其次是**兼容浏览器，编译高级语法**。由于浏览器的实现规范所限，只要高级语言/语法（TypeScript、 JSX 等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式。这都需要工具链层面的支持，而且这个需求会一直存在。

再者是**线上代码的质量**问题。和开发阶段的考虑侧重点不同，生产环境中，我们<font color=red>不仅要考虑代码的 安全性、兼容性问题，保证线上代码的正常运行，也需要考虑代码运行时的性能问题</font>。由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。

同时，开发效率也不容忽视。 我们知道，**项目的冷启动/二次启动时间**、**热更新时间** 都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的启动速度和热更新速度也是前端工程的重要需求。

那么，前端构建工具是如何解决以上问题的呢？

<img src="https://s2.loli.net/2024/02/29/96DxvlrIFdHgkCO.webp" style="zoom:45%;" />

- 模块化方面，提供模块加载方案，并兼容不同的模块规范。
- 语法转译方面，<font color=lightSeaGreen>配合 `Sass`、`TSC`、`Babel` 等前端工具链，完成高级语法的转译功能</font>，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。
- 产物质量方面，在生产环境中，配合 `Terser` 等压缩工具进行代码压缩和混淆，通过 `Tree Shaking` 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。
- 开发效率方面，构建工具本身通过各种方式来进行性能优化，包括 使用原生语言 Go/Rust、<font color=red>no-bundle</font> 等等思路，提高项目的启动性能和热更新的速度。

##### Vite 的优点

一方面，Vite 在开发阶段基于浏览器原生 ESM 的支持实现了`no-bundle` 服务，另一方面借助 Esbuild 超快的编译速度来做第三方库构建和 TS / JSX 语法编译，从而能够有效提高开发效率。

<font color=dodgerBlue>除了开发效率，在其他三个维度上， Vite 也表现不俗</font>。

- 模块化方面，Vite 基于浏览器原生 ESM 的支持实现模块加载，<font color=red>并且无论是开发环境还是生产环境，都可以将其他格式的产物（如 CommonJS ）转换为 ESM</font>。
- 语法转译方面，Vite 内置了对 TypeScript、JSX、Sass 等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。
- 产物质量方面，Vite 基于成熟的打包工具 Rollup 实现生产环境打包，同时可以配合 Terser、Babel 等工具链，可以极大程度保证构建产物的质量。



##### Vite 预构建

依赖预构建主要做了两件事情：

- 一是将其他格式(如 UMD 和 CommonJS)的产物转换为 ESM 格式，使其在浏览器通过 `<script type="module"><script>`的方式正常加载。

- 二是打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量，避免页面加载性能劣化。

Vite 将预构建相关的配置项都集中在 `optimizeDeps` 属性上



#### Vite 实现

##### Vite 架构图

![Vite 架构图](https://s2.loli.net/2024/03/04/Co6nIzVmHJBqUgR.webp)

##### esbuild 作为打包工具的缺点

- <font color=red>不支持降级到 `ES5` 的代码</font>。这意味着在低端浏览器代码会跑不起来。

- 不支持 `const enum` 等语法。这意味着单独使用这些语法在 esbuild 中会直接抛错。

  > 💡对于这里的说法感觉有点奇怪，所以问了下 GitHub Copilot：
  >
  > <img src="https://s2.loli.net/2024/03/04/ldfOVyAcg7e8XzY.png" alt="image-20240304141838375" style="zoom:50%;" />
  >
  > <img src="https://s2.loli.net/2024/03/04/cbjEtX9kMqnLFdm.png" alt="image-20240304142003366" style="zoom:50%;" />
  >
  > 根据上面的说法：esbuild 是支持 ts 的，只是不支持部分语法

- <font color=red>不提供操作打包产物的接口，像 Rollup 中灵活处理打包产物的能力</font>（如 `renderChunk` 钩子）在 esbuild 当中完全没有。

- <font color=red>不支持自定义 Code Splitting 策略</font>。传统的 Webpack 和 Rollup 都提供了自定义拆包策略的 API，而 esbuild 并未提供，从而降级了拆包优化的灵活性。



##### esbuild 为什么性能高

1. **使用 Golang 开发**，构建逻辑代码直接被编译为原生机器码，而不用像 JS 一样先代码解析为字节码，然后转换为机器码，大大节省了程序运行时间。
2. **多核并行**。内部打包算法充分利用多核 CPU 优势，所有的步骤尽可能并行，这也是得益于 Go 当中多线程共享内存的优势。
3. **从零造轮子**：<font color=red>几乎没有使用任何第三方库，所有逻辑自己编写</font>，大到 AST 解析，小到字符串的操作，保证极致的代码性能。
4. **高效的内存利用**。esbuild 中从头到尾尽可能地复用一份 AST 节点数据，而不用像 JS 打包工具中频繁地解析和传递 AST 数据（如 string -> TS -> JS -> string)，造成内存的大量浪费。




## 其他

#### unplugin-auto-import 的使用

##### 以 vite 为例的配置

```ts
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import AutoImport from 'unplugin-auto-import/vite' // 💡 除了 vite 还有 webpack 和 rollup 等等，详见文档

export default defineConfig({
  plugins: [vue(), AutoImport({
    imports: ['vue', 'vue-router'], // 需要导入哪些包中的模块
    dirs: ['./src/api'], // 需要导入的本地模块
    dts: './src/auto-import.d.ts', // 如果是 ts 开发，只有上面的配置，在开发时会发现类型声明丢失（如果是 js 不会存在这种问题！）；所以需要插件来自动生成类型定义，在启动项目之后，将会创建对应的文件，将 "imports" 和 "dirs" 中模块的类型定义写入其中。这里就是在说明生成类型定义文件的地址，可以按照自己想法定义。
  })]
})
```

按照如上配置，如下引入（以及类似的东西）将没有必要再写了

```ts
import { ref, reactive } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { foo } from './src/api'
```

另外，看了下官方 repo 的 readme [GitHub - unplugin-auto-import](https://github.com/unplugin/unplugin-auto-import) 感觉，相当易懂
