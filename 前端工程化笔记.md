# 前端工程化笔记



## pnpm

#### pnpm env \<cmd>

管理 Node.js 环境。👀 注：类似于 nvm 和 n 等包管理工具

##### 命令行

安装并使用指定版本的 Node.js。

###### 安装 LTS 版本的 Node.js

```bash
pnpm env use --global lts
pnpm env use --global argon
```

###### 安装 v16 的Node.js

```bash
pnpm env use --global 16
```

###### 安装 Node.js 的预发行版本

```bash
pnpm env use --global nightly
pnpm env use --global rc
pnpm env use --global 16.0.0-rc.0
pnpm env use --global rc/14
```

###### 安装最新版本的 Node.js

```bash
pnpm env use --global latest
```

##### 配置项

- `--global` , `-g`：此更改将全局生效。

摘自：[pnpm doc - pnpm env \<cmd>](https://pnpm.io/zh/cli/env)



## PostCSS

#### 峰华前端的《13 分钟掌握 PostCSS》笔记

PostCSS 是专门用于处理 CSS 的工具，通过一系列的插件来修改最终样式：可以让开发者使用最新的 CSS 特性（哪怕提案处于 stage 0，配置示例下面有）提高开发效率（通过使用 [PostCSS-Preset-env](https://github.com/csstools/postcss-preset-env) 。不过原库已经 archived，并入了 [postcss-plugins](https://github.com/csstools/postcss-plugins) ）；也可以转译 CSS，兼容大多数浏览器（类似于 Babel ）；PostCSS 通过插件，支持 Sass 之类 CSS 预处理工具。

使用 autoprefixer 可以查看哪些 CSS 属性、值、选择器、@rules 是需要加上浏览器前缀的，使用 `npx autoprefixer --info` 即可输出内容，输出内容略。

使用 PostCSS 命令行工具 PostCSS-Cli 可以通过命令行的方式运行 PostCSS：

```sh
npx postcss input.css -o output.css -u yourPostCssPlugin
```

通用的语法见 [PostCSS CLI - README](https://github.com/postcss/postcss-cli) 。不过这样过于麻烦，可以通过 配置文件（配置 postcss.config.js 文件） 的方法，设置 `yourPostCssPlugin` ；使得即使在不使用 webpack 之类工具的情况下，至少不需要输入 `-u yourPostCssPlugin` 。使用 npm script 甚至可以省去前面（固定）的代码

```js
// postcss.config.js
const postcssPresetEnv = require('postcss-preset-env')

module.exports = {
  plugins: [
    require('stylelint'),
    require('autoprefixer'),
    postcssPresetEnv({
      stage: 0 // 可以使用提案在 stage 0 的新特性
    }),
    require('postcss-pxtorem')
  ]
}
```

CSS 也有自己的 lint 工具  [stylelint](https://github.com/stylelint/stylelint) 以及 它基本的规则 [stylelint-config-standard](https://github.com/stylelint/stylelint-config-standard) ；使用 stylelint 创建 `.stylelintrc.json` 配置文件，并在 postcss.config.js 配置文件中注册（注册见上面）：

```json
// .stylelintrc.json
{
  "extends": "stylelint-config-standard"
}
```

在开发时需要将 px 转换为 rem，这时候可以使用插件 [postcss-pxtorem](https://github.com/cuth/postcss-pxtorem) 类似的有 [px2rem](https://github.com/songsiqi/px2rem)，不过前者 Star 更多

学习自：[13 分钟掌握 PostCSS](bilibili.com/video/BV1Pd4y1S7Mp)

相关的，在 [[Vue3 + TS 学习笔记#PostCSS 工具]] 中也有 PostCSS 的笔记

### Tecvan《零基础理解 PostCSS 的主流程》笔记

官网说：“PostCSS，一个使用 JavaScript 来处理 CSS 的框架” ( A tool for transforming CSS with JavaScript )。这句话高度概括了 PostCSS 的作用，但是太抽象了。按我理解，PostCSS 主要做了三件事：

1. **parse**：<font color=red>把 CSS 文件的字符串解析成抽象语法树 ( Abstract Syntax Tree ) 的框架</font>，<font color=fuchsia>解析过程中会检查 CSS 语法是否正确，不正确会给出错误提示</font>。
2. **runPlugin**：<font color=fuchsia>**执行插件函数**</font>。<font color=fuchsia>**PostCSS 本身不处理任何具体任务**，它提供了以特定属性或者规则命名的事件</font>。有特定功能的插件（如 autoprefixer、CSS Modules ）会注册事件监听器。PostCSS 会在这个阶段，重新扫描 AST，执行注册的监听器函数。
3. **generate**：<font color=fuchsia>插件对 AST 处理后，PostCSS 把处理过的 AST 对象转成 CSS string</font>。

![图片](https://s2.loli.net/2022/08/11/RDNvjWZ72KdySeh.png)

<font color=red>**「如果没有插件」**，那么初始传入的 CSS string 和 generate 生成的 CSS string 是一样的</font>。由此可见，<font color=fuchsia>PostCSS 本身并不处理任何具体的任务，只有当我们为其附加各种插件之后，它才具有实用性</font>。

下面分别详细分析三个阶段做的事。

#### 第一阶段：parse

<font color=dodgerBlue>CSS 规则集 ( rule-set ) 由选择器和声明块组成</font>：

![图片](https://s2.loli.net/2022/08/12/Z9Dtvd1efCRGJhP.png)

- **选择器** 指向您需要设置样式的 HTML 元素
- <font color=red>**声明块** 包含一条或多条用分号分隔的声明</font>
- 每条 **声明** 都包含一个 CSS 属性名称和一个值，以冒号分隔
- 多条 **CSS 声明** 用分号分隔，声明块用花括号括起来

##### 五类对象

<font color=fuchsia>AST 用 **五类对象** 描述 CSS 语法</font>。<font color=dodgerBlue>这里举个具体的例子，再打印出对应的 AST 结果，**对照了解 AST 五类对象和 CSS 语法的对应关系**</font>。

`app.css` 文件中写如下内容：

```css
@import url('./app-02.css');

.container {
  color: red;
}
```

##### Declaration 对象

<font color=fuchsia>Declaration 对象用来 **描述 CSS 中的每一条声明语句**</font>

- **type**：<font color=red>标记当前对象的类型</font>
- **parent**：<font color=red>记录父对象的实例</font>
- **prop**：记录声明中的属性名
- **value**：记录声明中的值
- **raws**：<font color=red>字段记录声明前的字符串、声明属性和值之间的符号的字符串</font>
- 其余字段（比如 `source` 及其子字段、`Symbol(prop)` ）解释见代码中的注释

上边 CSS 文件中的 `color: red;` 会被描述成如下对象：

```json
{
  parent: Rule,    // 外层的选择器被转译成 Rule 对象，是当前声明对象的 parent
  prop: "color",   // prop 字段记录声明的属性
  raws: {          // raws 字段记录声明前、后的字符串，声明属性和值之间的字符串，以及前边语句是否分号结束。
    before: '\n ', // raws.before 字段记录声明前的字符串
    between: ': ', // raws.between 字段记录声明属性和值之间的字符串
  },
  source: { // source 字段记录声明语句的开始、结束位置，以及当前文件的信息
    start: { offset: 45, column: 3, line: 4 },
    end: { offset: 55, column: 13, line: 4 },
    input: Input {
      css: '@import url('./app-02.css');\n\n.container {\n  color: red;\n}',
      file: '/Users/admin/temp/postcss/app.css',
      hasBOM: false,
      Symbol(fromOffsetCache): [0, 29, 30, 43, 57]
    }
  },
  Symbol('isClean'): false,  // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true, // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype 属性
  type: 'decl',      // type 记录对象类型，是个枚举值，声明语句的 type 固定是 decl
  value: "red"       // value 字段记录声明的值
}
```

##### Rule 对象

<font color=fuchsia>Rule 对象是 **描述选择器** 的</font>

- **type**：记录对象的类型
- **parent**：记录父对象的实例
- **nodes**：<font color=red>记录子对象的实例</font>
- **selector**：<font color=red>记录选择器的字符串</font>
- **raws**：<font color=red>记录选择器前的字符串、选择器和大括号之间的字符串、最后一个声明和结束大括号之间的字符串</font>
- 其余字段解释见代码中的注释

上边 `app.css` 文件中 `.container` 经过 postcss 转译后的对象是（每个字段的含义和功能已经以注释的形式进行了解释）：

```json
{
  nodes: [Declaration],  // nodes 记录包含关系，Rule 对象包含 Declaration 对象
  parent: Root,          // 根对象是 Root 对象，是当前声明对象的 parent
  raws: {                // raws 字段记录如下
    before: '\n\n',      // raws.before 字段记录选择器前的字符串
    between: ' ',        // raws.between 字段记录选择器和大括号之间的字符串
    semicolon: true,     // raws.semicolon 字段记录前置声明语句是正常分号结束
    after: '\n'          // raws.after 字段记录最后一个声明和结束大括号之间的字符串
  },
  selector:'.container', // selector 记录 selector
  source: {              // source 字段记录选择器语句的开始、结束位置，以及当前文件的信息
    start: { offset: 30, column: 1, line: 3 },
    input: Input {
      css: '@import url('./app-02.css');\n\n.container {\n  color: red;\n}',
      file: '/Users/admin/temp/postcss/app.css',
      hasBOM: false,
      Symbol(fromOffsetCache): [0, 29, 30, 43, 57]
    },
    end: { offset: 57, column: 1, line: 5 }
  },
  Symbol('isClean'): false, // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true,       // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype
  type: 'rule'              // type 记录对象类型，是个枚举值，声明语句的 type 固定是 rule
}
```

##### AtRule 对象

<font color=fuchsia>CSS 中除了选择器，还有一类语法是 `@` 开头的</font>，例如 `@import`、`@keyframes`、`@font-face`，PostCSS 把这类语法解析成 AtRule 对象。👀 注：它本身的名字也叫 `@rules`

- **type**：记录当前对象的类型
- **parent**：记录当前对象的父对象
- **name**：记录 <font color=red>`@` 紧跟着的单词</font>
- **params**：记录 name 对应的值

例如 `@import url("./app-02.css");` 将被解析成如下对象：

```json
{
  name: "import",                // name 记录 @ 紧跟着的单词
  params: "url('./app-02.css')", // params 记录 name 对应的值
  parent: Root,                  // parent 记录父对象
  raws: {                        // raws 字段记录如下
    before: '',                  // raws.before 记录 @语句前的空字符串
    between: '',                 // raws.between 记录 name 和 { 之间的空字符串
    afterName: '',               // raws.afterName 记录 name 和 @ 语句之间的空字符串
    after: '',                   // raws.after 记录大括号和上一个 rule 之间的空字符串
    semicolon: false             // raws.semicolon 上一个规则是否是分号结束
  },
  source: {                      // source 字段记录@语句的开始，以及当前文件的信息
    start: { offset: 0, column: 1, line: 1 },
    end: { offset: 27, column: 28, line: 1 },
    input: Input {
      css: '@import url('./app-02.css');\n\n.container {\n  color: red;\n}',
      file: '/Users/admin/temp/postcss/app.css',
      hasBOM: false,
      Symbol(fromOffsetCache): [0, 29, 30, 43, 57]
    }
  },
  Symbol('isClean'): false,  // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true,        // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype
  type: 'atrule'          // type 记录对象类型，是个枚举值，声明语句的 type 固定是 atrule
}
```

##### Comment 对象

<font color=fuchsia>CSS 文件中的注释被解析成 Comment 对象</font>。text 字段记录注释内容。`/* 你好 */  `被解析成：

```json
{
  parent: Root,    // parent 记录父对象
  raws: {          // raws 字段记录如下
    before: '',    // raws.before 记录注释语句前的空字符串
    left: ' ',     // raws.left 记录注释语句左侧的空字符串
    right: ' '     // raws.right 记录注释语句右侧的空字符串
  },
  source: {        // source 字段记录注释语句的开始、结束位置，以及当前文件的信息
    start: {…}, 
    input: Input, 
    end: {…}
  },
  Symbol('isClean'): false, // Symbol(isClean) 字段默认值都是 false，用于记录当前对象关联的 plugin 是否执行。plugin 会在后续解释
  Symbol('my'): true,       // Symbol(my) 字段默认值都是 true，用于记录当前对象是否是对应对象的实例，如果不是，可以根据类型把对象的属性设置为普通对象的 prototype
  text: '你好',              // text 记录注释内容
  type: 'comment'           // type 记录对象类型，是个枚举值，声明语句的 type 固定是 comment
}
```

##### 图解五类对象之间的继承关系

从上一段可以知道，<mark>CSS 被解析成 Declaration、Rule、Root、AtRule、Comment 对象</mark>。<font color=fuchsia>**这些对象有很多 公共方法，PostCSS 用了面向对象的继承思想，把公共方法和公共属性提取到了父类中**</font>。

<font color=fuchsia>**Root、Rule、AtRule** 都是可以有子节点的</font>，都有 nodes 属性，<font color=fuchsia>**他们三个继承自 Container 类**</font>，对 nodes 的操作方法都写在 Container 类中。

<font color=fuchsia>**Container、Declaration、Comment** **继承自 Node 类**</font>，所有对象都有 `Symbol('isClean')` 、`Symbol('my')`、raws、source、type 属性，都有 `toString()`、`error()` 等方法，这些属性和方法都定义在 Node 类中。

**Container、Node** 是用来提取公共属性和方法，不会生成他们的实例。

<font color=dodgerBlue>五个类之间的继承关系如下图所示：</font>

![Image](https://s2.loli.net/2022/08/12/c6po81SKtVYMnXv.png)

图中没有穷举类的方法，全部的方法 可以看直接看源码文件: https://github.com/postcss/postcss/tree/main/lib

#### 第二阶段：runPlugin

<mark>PostCSS 本身并不处理任何具体的任务，只有当我们为其附加各种插件之后，它才具有实用性</mark>。

<font color=fuchsia>PostCSS 在把 CSS string 解析成 AST 对象后，会扫描一边 AST 对象</font>，<font color=fuchsia>**每一种 AST 的对象都可以有对应的监听器**</font>。<font color=red>在遍历到某类型的对象时，如果有对象的监听器，就会执行其监听器。

##### 第一类监听器

PostCSS 提供的**「以特定属性或者规则命名」**的事件监听器，如下：

> CHILDREN 代表子节点的事件监听器。

```js
// root
['Root', CHILDREN, 'RootExit']

// AtRule
['AtRule', 'AtRule-import', CHILDREN, 'AtRuleExit', 'AtRuleExit-import']

// Rule
['Rule', CHILDREN, 'RuleExit']

// Declaration
['Declaration', 'Declaration-color', 'DeclarationExit', 'DeclarationExit-color']

// Comment
['Comment', 'CommentExit']
```

PostCSS 以 <font color=fuchsia size=4>**深度优先** 的方式遍历 AST 树</font>。

- <mark style="background: lightpink">**遍历到 Root 根对象**，**第一步** 会执行所有插件注册的 Root 事件监听器，**第二步** 检查 Root 是否有子对象，如果有，则遍历子对象，执行子对象对应的事件监听器；如果没有子对象，则直接进入第三步；**第三步** 会执行所有插件注册的 RootExit 事件监听器</mark> （👀 注：这就是 DFS 的步骤）。

  <font color=red>插件注册的 Root、RootExit 事件的监听器 **只能是函数**</font>。函数的第一个参数是当前访问的 AST 的 Root 对象，第二个参数是 postcss 的 Result 对象和一些其他属性，通过 Result 对象可以获取 css string、opts 等信息。

  ```js
  {
    Root: (rootNode, helps) => {},
    RootExit: (rootNode, helps) => {}
  }
  ```

- **遍历到 Rule 对象**，则<mark style="background: lightpink">和访问 Root 根对象是一样的逻辑</mark>，先执行所有插件注册的 Rule 事件监听器，再遍历子对象，最后执行所有插件注册的 RuleExit 事件监听器。<font color=red>插件注册的 Rule、RuleExit 事件的监听器 **只能是函数**</font>。

  ```js
  {
    Rule: (ruleNode, helps) => {},
    RuleExit: (ruleNode, helps) => {}
  }
  ```

- **遍历到 AtRule 对象**。<font color=red>插件注册的 AtRule 的事件监听器 **可以是函数**，**也可以是对象**</font>。对象类型的监听器，对象属性的 key 是 AtRule 对象的 name 值，value 是函数。<mark style="background: lightpink">AtRuleExit 是一样的逻辑</mark>。<font color=fuchsia>事件的执行顺序是：`['AtRule', 'AtRule-import', CHILDREN, 'AtRuleExit', 'AtRuleExit-import']` </font>。CHILDREN 代表子节点的事件。

  ```js
   // 函数
  { 
    AtRule: (atRuleNode, helps) => {}
  }
  
  // 对象
  {
    AtRule: {
      import: (atRuleNode, helps) => {},
      keyframes: (atRuleNode, helps) => {}
    }
  }
  ```

- **遍历到 Declaration 对象**。<font color=red>插件注册的 Declaration 的事件监听器 **可以是函数，也可以是对象**</font>，对象属性的 key 是 Declaration 对象的 prop 值，value 是函数。<mark style="background: lightpink">DeclarationExitExit 是一样的逻辑</mark>。<font color=fuchsia>事件的执行顺序是：`['Declaration', 'Declaration-color', 'DeclarationExit', 'DeclarationExit-color']`</font> 。**Declaration 没有子对象，只需要执行当前对象的事件，不需要深度执行子对象的事件**。

  ```js
  // 函数
  {
    Declaration: (declarationNode, helps) => {}
  }
  
  // 对象
  {
    Declaration: {
      color: (declarationNode, helps) => {},
      border: (declarationNode, helps) => {}
    }
  }
  ```

- **遍历到 Comment 对象**。依次执行所有插件注册的 Comment 事件监听器，再执行所有插件注册的 CommentExit 事件监听器。

##### 第二类监听器

<font color=dodgerBlue>除以特定属性或者规则命名的事件监听器，**PostCSS 还有以下四个**</font>（👀 注：三个方法，一个插件名称）：

```js
{
  postcssPlugin: string,
  prepare: (result) => {},
  Once: (root, helps) => {},
  OnceExit: (root, helps) => {},
}
```

PostCSS 插件事件的整体执行是：`[prepare, Once, ...一类事件, OnceExit]`，<font color=red>**postcssPlugin 是插件名称**</font>，不是事件监听器。

- **postcssPlugin**：字符串类型，<font color=red>插件的名字，在插件执行报错，提示用户是哪个插件报错了</font>。

- **prepare**：函数类型，<font color=red>prepare 是最先执行的，在所有事件执行前执行的</font>，插件多个监听器间共享数据时使用。prepare 的入参是 Result 对象，返回值是监听器对象，通过 Result 对象可以获取 css string、opts 等信息。

  ```js
  {
    postcssPlugin: "PLUGIN NAME",
    prepare(result) {
      const variables = {};
      return {
        Declaration(node) {
          if (node.variable) {
            variables[node.prop] = node.value;
          }
        },
        OnceExit() {
          console.log(variables);
        },
      };
    },
  };
  ```

- **Once**：函数类型，<font color=red>在 prepare 后，一类事件前执行</font>，Once <font color=red>只会执行一次</font>。

  ```js
  {
     Once: (root, helps) => {}
  }
  ```

- **OnceExit**：函数类型，<font color=red>在一类事件后执行</font>，OnceExit <font color=red>只会执行一次</font>。

**插件有哪些？**

[postcss Github - docs - PostCSS plugins](https://github.com/postcss/postcss/blob/main/docs/plugins.md) 列出了大量的 postcss plugin，就相当于 postcss awesome

#### 第三阶段：generate

generate 的过程<font color=fuchsia>依旧是以深度优先的方式遍历 AST 对象，**针对不同的实例对象进行字符串的拼接**</font>。算法对应源码中位置是：`postcss/lib/stringifier.js` 中的 `stringify ` 方法，代码量不大，可自行查看。

摘自：[零基础理解 PostCSS 的主流程](https://mp.weixin.qq.com/s/Bkss0lzPT-TI6GyGxMyn3Q)

