# 计算机网络



#### **网关**

随便打开一本HTTP的书，都会提到网关的概念。通常意识中，网关一词更多的是硬件层面的概念，但其实与CGI的网关二字之含义也是不谋而合的。称CGI为软件网关也不为过。

网关，<mark>更形象的叫法是“**协议翻译机**”</mark>。<mark>通常与网关输入输出两端通信使用的是不同的协议。即一方是HTTP协议，另一方可能是其他协议</mark>，比如企业内部的自定义协议。

摘自：[万法归宗——CGI](https://zhuanlan.zhihu.com/p/25013398)



#### 会话层

会话层，位于OSI模型的第5层，主要<font color=FF0000> 为两个会话层实体进行**会话**（Session），而进行的对话连接的管理服务</font>。

<font color=FF0000> 会话层为用户端的应用程序提供了开启、关闭和管理会话的机制，亦即半永久的对话</font>。会话的实体包含了对其他程式作会话连结的要求及回应其他程式提出的会话连结要求。在应用程序的执行环境中，会话层是这些程序用来提出远程过程调用（remote procedure calls，RPC）的地方。

会话层标准为了使会话连接建立阶段能进行功能协商，也为了便于其它国际标准参考和引用，定义了12种功能单元。各个系统可根据自身情况和需要，以核心功能服务单元为基础，选配其他功能单元组成合理的会话服务子集。

摘自：[wiki - 会话层](https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82)



#### 表示层

表示层 (Presentation) 亦称表达层，<font color=FF0000> 为不同终端的上层用户提供数据和信息正确的语法表示变换方法</font>。<mark>如文本文件的 ASCII格式 和 UTF-8格式</mark>。

**表示层的主要功能**

- 数据语法转换
- 语法表示
- 连接管理
- 数据处理
  - 数据加密和解密
  - 数据压缩和解压
  - 数据编码和解码

摘自：[wiki - 表示层](https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%B1%82)



## HTTP

> ### 《编程必备基础 大话HTTP协议》 笔记

http之所以被称为超文本传输协议，是因为他可以通过 超链接 跳转到其他网页（HTML）



**伯纳斯·李发明了：**

- URI
- HTTP (被称为HTTP 0.9) 
- HTML



三次握手的作用：确认B / S双方的接收和发送的能力



电脑（客户端）会对一些频繁使用的网址 和它所对应的IP地址，做一个映射关系放到host文件中。在访问该网址时，会优先使用host文件中的IP地址（省去了DNS解析的过程）



本地可以配置DNS服务器



http开始时是无连接的协议，即：限制每次连接（TCP连接）只处理一个请求

http 也是无状态的，所以需要 Session 和 Cookie 来完善。



**URI、URL、URN的区别**

<img src="https://i.loli.net/2021/10/10/AFr1kOjNwKhTYPE.png" alt="image-20211010111346719" style="zoom:33%;" />

- URI：一个紧凑的字符串用来标识抽象或物理资源。一个 URI 可以进一步被分为定位符、名字或者两者都是

  > URI 可以分为URL、URN 或 <font color=FF0000> 同时具备locators和names特性的一个东西</font>
  >
  > URN 作用就好像一个人的名字 (<font color=FF0000> names</font>)，URL就像一个人的地址 (<font color=FF0000>locators</font>)
  >
  > 换句话说：URN确定了东西的身份，URL提供了找到它的方式
  >
  > 摘自：维基百科

  - URL （Uniform Resource Locator) 是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制（如其网络“位置”）

    - URL是 URI的一种，不是所有的URI 都是 URL

    - URI 和 URL最大的差别是“访问机制”

  - URN (Uniform Resource Name) 是唯一标识的一部分，是身份信息

  

**HTTP报文头**

HTTP报文头可以分为四类：

- <font color=FF0000>**通用**</font>报文头
- 请求报文头
- 响应报文头
- <font color=FF0000> **实体**</font>报文头

HTTP/1.1中一共规范了47中报文头字段，详见后面的：http/1.1 首部字段一览



**ACCEPT**

作用：浏览器端可以接受的媒体类型。
 **Accept: text/html**：代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档，如果服务器无法返回text/html类型的数据服务应该返回一个406错误 (Non Acceptable)

**Accept:\*/\***：代表浏览器可以处理所有类型

Accept / Accept-Language 如果想要给显示的媒体类型增加优先级,则使用q=来额外表示权重值)；权重值q 的范围是0～1 (可精确到小数点后3位) ，且1为最大值。不指定权重q值时，默认权重为q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。



**Referer**

当浏览器向web服务器发送请求的时候，一般会带上Referer，<font color=FF0000> **告诉服务器我是从哪个页面链接过来的**，服务器籍此可以获得一些信息用于处理</font>



**User-Agent**

作用：告诉HTTP服务器，客户端使用的<font color=FF0000> 操作系统</font>和浏览器的名称和版本

<mark>很多情况下我们会通过User-Agnet 来判断浏览器类型，从而进行不同的兼容设计</mark>



**GET和POST的区别**

- GET传输的数据是放在URL 中的（?foo=bar），POST传输的数据作为HTTP的请求体
- GET请求有大小限制，根据不同浏览器实现不同而不同；而POST请求没有大小限制



**HTTP状态码种类**

| 分类 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 1XX  | 表示消息。这一类型的状态码,代表请求已被接受,需要继续处理。这类响应是临时响应,只包含状态行和某些可选的响应头信息,并以空行结束。 |
| 2XX  | 表示成功。这一类型的状态码,代表请求已成功被服务器接收、理解、并接受。 |
| 3XX  | 表示重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常,这些状态码用来重定向,后续的请求地址(重定向目标)在本次响应的Location域中指明。 |
| 4XX  | 表示请求错误。这类的状态码代表了客户端看起来可能发生了错误,妨碍了服务器的处理。除非响应的是一个HEAD请求,否则服务器就应该返回一个解释当前错误状况的实体,以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。 |
| 5XX  | 表示服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生,也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求,否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。 |

**常用状态码**

| 状态码 | 状态码英文名称        | 描述                                                         |
| ------ | --------------------- | ------------------------------------------------------------ |
| 200    | OK                    | 请求已成功,请求所希望的响应头或数据体将随此响应返回          |
| 202    | Accepted              | 已接受,已经接受请求,但未处理完成                             |
| 206    | Partial Content       | 部分内容,服务器成功处理了部分GET请求                         |
| 301    | Moved Permanently     | 永久移动,请求的资源已被永久的移动到新URI,返回信息会包括新的URI，浏览器会自动定向到新URI,今后任何新的请求都应使用新的URI代替 |
| 302    | Found                 | 临时移动，与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 400    | Bad Request           | 客户端请求的语法错误,服务器无法理解                          |
| 401    | Unauthorized          | 请求要求用户的身份认证                                       |
| 403    | Forbidden             | 服务器理解请求客户端的请求，是拒绝执行此请求                 |
| 404    | Not Found             | 服务器无法根据客户端的请求找到资源（网页）                   |
| 500    | Internal Server Error | 服务器内部错误,无法完成请求                                  |
| 502    | Bad Gateway           | 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   |



**Cookie 和 Session**

- Cookie实际上是一小段的文本信息。客户端请求服务器,如果服务器需要记录该用户状态,就向客户端浏览器颁发一个Cookie。

  客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时,浏览器把请求的网址连同该Cookie-同提交给服务器。服务器检查该Cookie,以此来辨认用户状态

  <img src="https://i.loli.net/2021/10/12/IednPrwAG6YMN8j.png" alt="image-20211012001151317" style="zoom:33%;" />

- Session是另一种记录客户状态的机制,保存在服务器上。客户端浏览器访问服务器的时候,服务器把客户端信息以某种形式记录在服务器上

  客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了

  <img src="https://i.loli.net/2021/10/12/APO7htHesMZSngc.png" alt="image-20211012000949789" style="zoom: 33%;" />fu z

  **浏览器用户可以清除Cookie，其他保存Session ID的方式：**

  - Cookie（已知）
  - URL重写，附加在URL后面
  - 隐藏表单

  **Session 的有效期：**

  - Session超时失效
  - 程序调用HttpSession.invalidate()
  - 服务器异常中止

  **Cookie 与 Session 不同点：**

  - 存放位置不同，Cookie放在UA，Session放在服务器
  - 安全性（隐私策略）不同，Cookie安全性没有Session安全性高
  - 有效期不同，Cookie可以（看服务器设置）在UA中保存很久；而服务器会定时清理超时的Session ID，避免出现过大的压力
  - 对服务器压力不同，Cookie存在UA中，对服务器没有压力



**常见编码规范**

- ASCII码
- GBK
- ISO-8859-1：不包含中文
- Unicode



**URL的编码和解码**

“%编码”规范

对URL中属于ASCI字符集的非保留字不做编码;对URL中的保留字需要取其ASCI内码，然后加上"%"前缀将该字符进行编码；对于URL中的非ASCI字符需要取其Unicode内码，然后加上"%"前缀将该字符进行编码。



**常见的认证方式**

- **BASIC认证（基本认证）：**不加密（明文），不安全。
- **DIGEST认证（摘要认证）：**加密，发送nonce：一个随机的字符串。
- **SSL客户端认证：**SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。<font color=FF0000> 凭借客户端证书认证（比如网银，除了输入用户名和密码，还要下载他们的证书）</font>，服务器可确认访问是否来自已登录的客户端。
- **FormBase认证（基于表单的认证）：**基于表单的认证方法并不是在HTTP协议中定义的。<mark>使用由Web应用程序各自实现基于表单的认证方式</mark>。通过Cookie和Session的方式来保持用户的状态。



**HTTP的长连接和短连接**

HTTP协议是基于 请求/响应 模式的，因此只要服务端给了响应，本次HTTP请求就结束了。

HTTP的长连接和短连接<font color=FF0000 size=4> **本质上是TCP长连接和短连接**</font>。

HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接,结束就中断。

HTTP/1.1起，默认使用长连接，用以保持连接特性。

**短连接：**建立连接一数据传输一关闭连接..建立连接一数据传输一关闭连接

**长连接：**建立连接-数据传输..(保持连接) .数据传输-关闭连接



**代理的作用**

- 抓包
- 翻墙
- 匿名访问
- 过滤器：避免用户访问一些不被允许的内容，比如“儿童模式”



**网关**

网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。网关扮演的是“协议转换器"的角色。

示例如下：

<img src="https://i.loli.net/2021/10/12/jLOSshqo6gtHzdl.png" alt="image-20211012140353072" style="zoom: 33%;" />

Web网关在一侧使用HTTP协议,在另一侧使用另一种协议。<客户端协议>/<服务器端协议>

(HTTP/)服务器端A:通过HTTP协议与客户端对话，通过其他协议与服务器通信。

(/HTTP)客户端网关:通过其他协议与客户端对话，通过HTTP协议与服务器通信。

**常见的网关类型**

- (HTTP/*) 服务器端Web 网关
- (HTTP/HTTPS) 服务器端安全网关
- (HTTPS/HTTP) 服务器安全加速器网关
- 资源网关



**HTTP缓存**

可使用头

- **Cache-Control：**请求响应头，缓存控制字段。可选值如下：
  - no-store：所有内容都不缓存。
  - no-cache：缓存,但是浏览器使用缓存前,都会请求服务器判断缓存资源是否是最新。
  - max-age=x(单位秒)：请求缓存后的x秒不再发起请求。（http1.1 属性）
  - s-maxage=x(单位秒)：<font color=FF0000> 代理服务器请求源站缓存后的x秒不再发起请求，只对代理服务器缓存有效</font>。
  - public：客户端和代理服务器(CDN)都可缓存
  - private：只有客户端可以缓存，即：代理服务器将无法缓存。

- **Expires：**响应头，代表资源过期时间，由服务器返回提供，是http1.0 的属性在与max-age共存的情况下，优先级要低。

- **Last-Modified：**<mark style="background:fuchsia">响应头</mark>，资源最新修改时间，由服务器告诉浏览器。
- **if-Modified-Since：**<mark style="background:aqua">请求头</mark>，资源最新修改时间，由浏览器告诉服务器，<mark>和Last-Modified是一对**（请求头和相应头）**，它俩会进行对比</mark>。
- **Etag：**<mark style="background:fuchsia">响应头</mark>，资源标识，由服务器告诉浏览器。
- **if-None-Match：**<mark style="background:aqua">请求头</mark>，缓存资源标识，由浏览器告诉服务器（其实就是上次服务器给的Etag），<mark>和Etag是一对**（请求头和相应头）**，它俩会进行对比</mark>。

**头的使用场景**

- **场景一：**让服务器与浏览器约定一个文件过期时间，则使用 Expires

- **场景二：**让服务器与浏览器在约定文件过期时间的基础上，再加一个文件最新修改时间的对比 -- Last-Modified 与 if-Modified-Since。如果文件过期了（expires时间到了），浏览器会发送 if-Modified-Since（即上次服务器返回的 Last-Modified），服务器会将请求头中的最新修改时间和服务器上的最新修改时间，做一下对比。如果不等，则服务器会重新发送文件、Expires、Last-Modified；如果相等，则会返回状态码 304 (Not Modified)

  - **解决的问题：**如果Expires时间到了，可以服务器的文件依旧没有改，这时可以通过这两个来避免服务器再次传输，而继续使用缓存

- **场景三：**让服务器与浏览器在过期时间Expires + Last-Modified 的基础上，<font color=FF0000> 增加一个文件内容唯一对比标记</font> -- Etag与 lf-None-Match。Expires不稳定，再加入一个max-age来加以代替

  - **解决的问题：**由于 Last-Modified 使用秒来判定是否改变，在高并发的情况下，如果Last-Modified 相等，<font color=FF0000> 并不能保证文件没有被修改过</font>；所以需要 ETag

    

**浏览器无法<font color=FF0000>主动</font>感知服务器文件变化**

解决方案：

- **md5 / hash 缓存：**通过不缓存html，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。
- **CDN 缓存：**CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器,通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。



**浏览器操作对HTTP缓存的影响**

| 用户操作                  | Expires / Cache-Control         | Last-Modified / Tag             |
| ------------------------- | ------------------------------- | ------------------------------- |
| 地址栏回车                | 有效                            | 有效                            |
| 页面链接跳转              | 有效                            | 有效                            |
| 新开窗口                  | 有效                            | 有效                            |
| 前进、后退                | 有效                            | 有效                            |
| F5刷新                    | <font color=FF0000> 无效</font> | 有效                            |
| Ctrl + F5刷新（强制请求） | <font color=FF0000> 无效</font> | <font color=FF0000> 无效</font> |

其中<font color=FF0000> “无效”</font>表示，忽略掉这些http头，强行进行请求。



**内容协商机制**

内容协商机制：指客户端和服务器端就响应的**资源内容**进行交涉，然后**提供给客户端最为适合的资源**。内容协商以响应资源的语言、字符集、编码方式等作为判断的基准。

**内容协商方式**

- **客户端驱动：**客户端发起请求，<font color=FF0000> 服务器发送可选项列表</font>，<font color=FF0000> 客户端作出选择后在发送第二次请求</font>。
  - 优点：容易实现，尊重用户的意愿
  - 缺点：增加时延，要发送两次请求
- <mark style="background:aqua">**服务器驱动：**</mark>服务器检查客户端的请求<font color=FF0000> 头部集</font>并决定提供哪个版本的页面。<font color=FF0000> **使用最为广泛**</font>
  - 优点：快速
  - 缺点：在头部集都不匹配的时候，服务器需要进行猜测
- **透明协商：**某个中间设备（通常是缓存代理）代表客户端进行协商。
  - http没有提供规范，但这可能是<font color=FF0000> 未来的趋势</font>



**<mark style="background:aqua">服务器驱动</mark>内容协商 - 请求首部集**

- **Accept：**告知服务器发送何种媒体类型；对应的<mark>响应头</mark>是 Content-Type
- **Accept-Language：**告知服务器发送何种语言；对应的<mark响应头是 Content-Language
- **Accept-Charset：**告知服务器发送何种字符集；对应的响应头是 Content-Type（注意，这里有两个Content-Type）
- **Accept-Encoding：**告知服务器采用何种编码；对应的响应头是 Content-Encoding



**服务器驱动内容协商 - 近似匹配（使用权重q）**

```http
Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0
```



**断点续传和多线程下载**

断点续传和多线程下载：HTTP是通过在Header里两个参数实现的，<font color=FF0000> **客户端发请求** </font>时对应的是 <font color=FF0000> **Range**</font>，<font color=0000FF> **服务器端响应**</font>时对应的是 <font color=0000FF> **Content-Range**</font>。

- **Range**
  用于请求头中，指定一个字节的和最后一字节的位置（<font color=FF0000> 名义上是左开右闭，但是http为了下载更加完善，选择了两边都是闭区间</font>），一般格式：

  ```http
  Range:(unit=first byte pos)-[last byte pos]
  ```

  示例：

  ```http
  Range: bytes=0-499
  Range: bytes=500-999
  Range: bytes=-500
  Range: bytes=500-
  Range: bytes=500-600,601-999
  ```

- **Content-Range**
  用于响应头中,在发出带Range 请求后，服务器会在Content-Range头部返回当前接受的范围和文件总大小。**一般格式：**

  ```http
  Content-Range: bytes (unit first byte pos)- [last byte pos]/[entity length]
  ```

  而在响应完成后，返回的响应头内容也不同：

  - HTTP/1.1 200 Ok （不使用断点续传方式）
  - HTTP/1.1 206 Partial Content （使用断点续传方式）

**多线程下载的原理**是<font color=FF0000> **主动的分片**</font>（<font color=FF0000> **断点续传是被动的分片**</font>），比如第一个线程的 Range 是0-1024，第二个Range是 1025-2048；以此类推。



**HTTPS协议概述**

- HTTPS可以被认为是 HTTP + TLS

- TLS 是传输层加密协议，<font color=FF0000> 前身是SSL协议</font>（TLS 和 SSL协议建立在TCP 和 HTTP协议之间）

  TLS实际上是TCP之上建立了一个加密通道

  **TLS协议有五个部分：**

  - 应用数据层协议
  - 握手协议
  - 报警协议
  - 加密消息确认协议
  - 心跳协议

  TLS 协议版本：TLS1.0、TLS1.1、TLS1.2、SSL3.0

  - SSL3.0 由于 poodle攻击，导致不稳定
  - TLS1.0 也存在部分安全漏洞，如RC4、BEAST攻击方式
  - TLS1.1 TLS1.2 暂时没有发现什么漏洞
  - TLS1.3 也已推出



**HTTPS功能介绍**

HTTPS主要解决了中间人攻击，防止网站被劫持。

- **内容加密**

  - 非对称密钥交换
  - 对称内容加密

- **身份认证**

  - 数字证书

  CA厂商和浏览器厂商 / OS厂商是有合作的

  - firefox 自己维护了一个可信任的 CA列表
  - Chrome / IE 使用的是OS的可信任的 CA列表

- **数据完整性**



**HTTPS使用成本**

- 证书费用以及更新维护
- HTTPS 会降低用户访问速度
- 消耗CPU资源，需要增加大量机器



**HTTPS对性能的影响**

- 协议交互所增加的网络 RTT（Round-trip-delay）

  https 连接过程：

  <img src="https://i.loli.net/2021/10/13/mfeiAw96gRWUNbl.png" alt="image-20211013105919282" style="zoom: 33%;" />

  **OCSP：**Online Certificate Status Protocol（在线证书状态协议）

- **计算耗时**
  - 浏览器计算耗时
  - 服务端计算耗时



**HTTP协议的瓶颈**

- **一个TCP连接上只能发送一个HTTP请求** 

  浏览器对<font color=FF0000> 同域名请求</font>的最大并发数也有限制，不同浏览器不一样，Chrome是6个（具体可以参考：https://cloud.tencent.com/developer/article/1683127）

- 请求只能从客户端开始。客户端不可以接受除响应以外的指令

- 请求/ 响应头部不经过压缩就发送

- 每次互相发送相同的头部造成的浪费较多

- 非强制压缩发送



**轮询**

- **Ajax轮询：**浏览器 <font color=FF0000> 定时</font>询问服务器
- **Long poll（长轮询）**：使用的阻塞模型，客户端发送消息之后，<font color=FF0000> 等待</font>服务器返回消息，服务器有消息了，才会返回给客户端

这两个询问方式都是 非常消耗资源的，同时也是有可能出现异常情况的，比如服务器会报 503。

**补充：**这两种轮询方式的缺点

- ajax轮询 需要服务器有很快的处理速度和资源。（速度）
- long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）

这时候就需要WebSocket



**WebSocket**

WS之所以被称为“基于HTTP”，只是为了兼容HTTP；HTTP 和 WS 是两个不同的协议。同时，WS借用HTTP来完成一部分握手。

WS是一个<font color=FF0000> 持 久化</font>的协议

**websocket的握手**

**客户端的请求报文**

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw=
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example. com
```

- **Upgrade: websocket Connection: Upgrade** 告知服务器切换协议
- **Sec-WebSocket-Key：**是一个Base64字符串，是浏览器随机生成的；用于验证服务器是否是真的Websocket助理
- **Sec_WebSocket-Protocol：**是一个用户定义的字符串，用来<font color=FF0000> 区分同一个URL</font>下，<font color=FF0000> 不同的服务所需要的协议</font>
- **Sec-WebSocket-Version：**是<font color=FF0000> 告诉服务器所使用的Websocket Draft（协议版本）</font>。在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦

**服务器的响应报文**

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

- **Upgrade: websocket Connection: Upgrade** 这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~并且，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。

- **Sec-WebSocket-Accept：**这个则是<font color=FF0000>经过服务器确认，并且加密过后的 Sec-WebSocket-Key</font>。服务器：好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。

  <font color=FF0000>**补充：**</font>摘自：[WebSocket协议：5分钟从入门到精通 - 极乐君的文章 - 知乎](https://zhuanlan.zhihu.com/p/32739737)

  Sec-WebSocket-Accept 是根据客户端请求首部的 Sec-WebSocket-Key 计算出来，计算公式为：

  1. 将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。
  2. 通过SHA1计算出摘要，并转成base64字符串。

- **Sec-WebSocket-Protocol：**则是表示最终使用的协议

<font color=FF0000>至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了</font>。

**上面说的：Ajax轮询和long poll轮询的缺点，那么WS是如何解决的呢？**

其实<font color=FF0000>我们所用的程序是要**经过两层代理**的，即**HTTP协议在Nginx等服务器的解析下**，然后再传送给相应的**Handler（PHP等）**来处理</font>。
<mark>简单地说，我们有一个非常快速的接**线员（Nginx）**，他负责把问题转交给相应的**客服（Handler）**</mark>。
本身**接线员基本上速度是足够的**，但是每次都卡在**客服（Handler）**了，老有**客服**处理速度太慢。，导致客服不够。
Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持**久连接**，有信息的时候客服想办法通知接线员，然后**接线员**在统一转交给客户。
这样就可以解决客服处理速度过慢的问题了。

同时，在传统的方式（HTTP）上，要不断的建立，关闭HTTP协议，<font color=FF0000>由于HTTP是非状态性的，每次都要 **重新传输identity info（鉴别信息）**，来告诉服务端你是谁</font>。
虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的**处理时间**，而且还会在网路传输中消耗**过多的流量/时间。**
<font color=FF0000>但是Websocket只需要**一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中**，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息</font>。
<font color=FF0000>同时由**客户主动询问**，转换为**服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。）**，没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的**客服（Handler）**了</font>

以上关于WS的内容摘自：[WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎](https://www.zhihu.com/question/20215561/answer/40316953)

WS只需要一次HTTP握手，整个通讯过程是建立在一次连接状态中；避免了http的非状态性，服务端会一直知道客户端的状态，知道客户端关闭。

<img src="https://i.loli.net/2021/10/13/Lq8AtdZisN4hfCQ.png" alt="image-20211013161045991" style="zoom:33%;" />

**WS的特点：**

- 真正的全双工方式
- 减少通信量（不需要再发送 http header）
- 多路复用

<font size=4>**更多补充：**</font>

WebSocket 是<font color=FF0000>**HTML5开始提供**</font>的一种浏览器与服务器进行全双工通讯的网络技术。

**优点：**

说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。

- 支持双向通信，实时性更强。
- 更好的二进制支持。
- 较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。
- 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）

**数据帧格式**

客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。

WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。

- 发送端：将消息切割成多个帧，并发送给服务端；
- 接收端：接收消息帧，并将关联的帧重新组装成完整的消息；

**下面给出了WebSocket数据帧的统一格式**。熟悉TCP/IP协议的同学对这样的图应该不陌生。

1. 从左到右，单位是比特。比如 `FIN`、`RSV1 `各占据1比特，`opcode `占据4比特。
2. 内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）

```java
 0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
```

// TODO

摘自：[WebSocket协议：5分钟从入门到精通 - 极乐君的文章 - 知乎](https://zhuanlan.zhihu.com/p/32739737)



**SPDY**

SPDY 结构

<img src="https://i.loli.net/2021/10/13/iwEHRJYBCDAP3tG.png" alt="image-20211013161807183" style="zoom: 33%;" />

SPDY修复了HTTP的缺陷，**HTTP的缺陷如下：**

- **单路连接 请求低效：**一个 TCP 连接只能对应一个 HTTP请求
- HTTP 只允许由客户端主动发起请求
- **HTTP 头部冗余：**重复发送HTTP Header

**于是SPDY 的改进：**

- **多路复用 请求优化**
  - 在一个 TCP连接上，可以有多个（无限个）并发的 HTTP请求，共用一个TCP 会话。
  - 同时避免反复创建新连接，造成的延时，将TCP 的效率发挥到最高
  - 另外，可以对多路复用设置优先级，可以让关键的资源优先被传输、处理
- **支持服务器推送技术：**
  - 服务器可以主动向客户端传输数据（类似于webpack 中的 prefetch）
- SPDY 压缩了 HTTP头
- 强制使用了 SSL传输协议



**HTTP2.0**

HTTP2.0 结构

<img src="https://i.loli.net/2021/10/13/ewHrRB5Xlb74W8x.png" alt="image-20211013163856744" style="zoom: 45%;" />

**HTTP2.0 性能增强的核心：<font color=FF0000> 二进制分帧</font>**

二进制分帧即：下图中的 Binary Framing

![150826074396731](https://i.loli.net/2021/10/13/7bHdhiMVUCqgI6B.jpg)

在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码 ，其中<font color=FF0000> **HTTP1.x 的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面**</font>。

然后，<font color=FF0000> HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流</font>。 相应地，<font color=FF0000> 每个数据流以消息的形式发送，而消息由一或多个帧组成，**这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装**</font>。

**首部表**

HTTP2.0在客户端和服务端使用了<font color=FF0000> **首部表**</font>，来<font color=FF0000> 跟踪和存储之前发送的键值对</font>，对于相同的数据，不再通过每次请求的响应发送。通信期间，几乎不会改变通用的键值对，只需要发送一次

<img src="https://i.loli.net/2021/10/13/pP3jdThnIoHNvte.png" alt="image-20211013165658554" style="zoom: 33%;" />

**HTTP2.0 多路复用**

<img src="https://i.loli.net/2021/10/13/XCsenvkHfhGMr6A.png" alt="image-20211013172052922" style="zoom: 33%;" />

**单连接多资源的优势：**

- 可以<font color=FF0000> 减少服务链接压力</font>，内存占用少了，连接吞吐量大了
- 由于TCP连接减少而使<font color=FF0000> 网络拥塞状况得以改观</font>
- 慢启动时间减少，<font color=FF0000> 拥塞和丢包恢复速度更快</font>

**HTTP2.0 并行双向字节流的请求和响应（乱序发送数据）**

![150826074396732](https://i.loli.net/2021/10/13/YXhpuxcQ75aI9Tv.jpg)

在HTTP2.0上，客户端和服务器可以把HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。注意，同一链接上有多个不同方向的数据流在传输。客户端可以一边乱序发送stream，也可以一边接收者服务器的响应，而服务器那端同理。

把 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP/2.0 最 重要的一项增强。这个机制会在整个 Web 技术栈中引发一系列连锁反应，从而带来巨大的性能提升，因为：

- 可以并行交错地发送请求，请求之间互不影响;
- 可以并行交错地发送响应，响应之间互不干扰;
- 只使用一个连接即可并行发送多个请求和响应;
- 消除不必要的延迟，从而减少页面加载的时间;

由于乱序发送，是否会因为数据是相关的（有先后顺序的），而造成应该先发送到的数据迟迟无法送到？这时就有了 HTTP/2.0 的 <font color=FF0000> “请求优先级”</font> 的概念：

- 高优先级的流都应该优先发送

- 优先级不是绝对的

- 不同优先级混合也是必须的



**webDAV追加方法**

| 方法      | 用途           |
| --------- | -------------- |
| PROPFIND  | 获取属性       |
| PROPPATCH | 修改属性       |
| MKCOL     | 创建集合       |
| COPY      | 复制资源及属性 |
| MOVE      | 移动资源       |
| LOCK      | 资源加锁       |
| UNLOCK    | 资源解锁       |

**webDAV新增状态码**

| 状态码                  | 含义                                             |
| ----------------------- | ------------------------------------------------ |
| 102 Processing          | 可正常处理请求，但目前是处理中状态               |
| 207 Multi-Status        | 存在多种状态                                     |
| 422 UnprocessibleEntity | 格式正确,内容有误                                |
| 423 Locked              | 资源已被加锁                                     |
| 424 FailedDependency    | 处理与某请求关联的请求失败，因此不再维持依赖关系 |
| 507 InsufficientStorage | 保存空间不足                                     |

 

**QUIC & HTTP3.0**

HTTP2.0 / SPDY / QUIC 对比图

<img src="https://i.loli.net/2021/10/14/Pmu6O7DqH3yjpUB.png" alt="image-20211014095020442" style="zoom: 40%;" />

**HTTP2.0的问题**

- **队头阻塞：**由底层制成的TCP 协议造成的，使用多路复用，一旦连接中出现了丢包的情况，会导致HTTP2.0 的表现不如 HTTP1.x ，因为在丢包的情况下，整个TCP 都需要等待重传，后面的所有数据都被阻塞住了。而对于HTTP1.x 而言，是开启多个 TCP 连接的，出现丢包，只会影响其中一个连接，仍可以正常传输数据
- **建立连接的握手延迟大：**
  - http1.x、https 和 http2.0 都使用了TCP 进行传输
  - https 和 http2.0 还需要通过TLS协议进行安全传输（TLS完全握手 需要至少两个RTT 才能建立；即使简化握手，也需要一个RTT）
  - TCP 三次握手还有延迟

**QUIC 的特性**

- 0 RTT 建立连接
- 没有队头阻塞的多路复用（更适合移动端）
- 前向纠错：每个数据包除了本身的数据之外，还包含了部分其他包的内容，少量的丢包，可以通过其他包的冗余数据，直接组装，而无需重传（相较冗余数据，数据重传代价更大）



**WASC将Web应用安全威胁分为六大类**

1. **Authentication (验证)：**用来确认某用户、服务或是应用身份的攻击手段

2. **Authorization (授权)：**用来决定是否某用户、服务或是应用具有执行请求动作必要权限的攻击手段
3. **Client-Side Attacks (客户侧攻击)：**用来扰乱或是探测Web 站点用户的攻击手段
4. **Command Execution (命令执行)：**在Web站点上执行远程命令的攻击手段
5. **Information Disclosure (信息暴露)：**用来获取Web站点具体系统信息的攻击手段
6. **Logical Attacks (逻辑性攻击)：**用来扰乱或是探测Web应用逻辑流程的攻击手段



**OWASP最重要的项目是：web应用的十大安全隐患**

- **A1:2017-注入：**将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生注入SQL注入、NoSQL注入、OS注入和LDAP注入缺陷。
-  **A2:2017-失效：**通过错误使用应用程序的身份认证和会话管理，攻击者能够破译密码、密钥或会话令牌。
- **A3:2017-敏感：**许多Web程序和API都无法正确护敏数据，攻击者可能通过 窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃等犯罪行为
- **A4:2017-XML外部实体(XXE) ：**许多较早的或配置错误的XML处理器评估的XML文件中的外部实体引用。攻击者可利用外部实体窃取内部文件、执行远程代码
- **A5:2017-失效的访问控制：**未对通过身份验证的用户实施恰当的访问控制。
- **A6:2017-安全配置错误：**安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云错误等造成。
- **A7:2017-跨站脚本(XSS) ：**XSS让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。
- **A8:2017-不完全的反序列化：**不安全的反序列化会导致远程代码执行。
- **A9:2017-使用含有已知漏洞的组件：**组件如库、框架和其他软件模块拥有和应用程序相同的权限
- **A10:2017-不足的日志记录和监控：**不足的日志记录和监控，以及相应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性、篡改、提取或销毁数据



**验证机制**

- 验证机制是web应用程序中最简单的一种<font color=FF0000> 安全机制</font>

  - 一般来说,应用程序<font color=FF0000> 必须核实</font>用户提交的用户名和密码是否正确。正确则允许登录，否则禁止登录

- 验证机制是应用程序防御恶意攻击的<font color=FF0000> 核心机制</font>

  - 它处在<font color=FF0000> 安全防御</font>的最前沿，如果被用户轻易突破，通常应用程序的全部功能、数据都会被其控制。

  - <font color=FF0000> 缺乏安全有效的验证机制</font>，其他核心安全机制都无法实施（会话管理和访问控制）

**典型的身份验证模式讨论**

<img src="https://i.loli.net/2021/10/14/S7qCpuAoZKrWDcy.png" alt="image-20211014140949126" style="zoom: 33%;" />

**验证技术**

- 基于HTML表单的验证
- 多元机制，如组合型密码
- 客户端 SSL 证书

**双因子认证**
双因子认证的核心是综合 what you know（个人密码）和 what you have（手机）来达到双重认证效果。目前很多电商、银行都采用了该认证方式。



**会话管理漏洞的防御**

- **令牌传输安全**
  - <font color=FF0000> 令牌只能通过HTTPS传送</font>。
  - 如果使用HTTP cookie传送令牌（大多数情况下），<font color=FF0000> 应将这些cookie标记为secure</font>，以防止用户浏览器通过HTTP传送它们。
- 增加软硬会话过期
  - **软会话过期：**它指的是<font color=FF0000> 用户在一定的时间内与应用系统没有交互，则会话过期</font>，也就是我们常说的<font color=FF0000> Session失效</font>。
  - **硬会话过期：**它指的是用户登录到系统中经过一定的时间后,不管用户做什么,该会话都会过期。
- 提供完善的注销功能
  - 用户可以手动地使当前会话过期，这就是我们在几乎所有网站上都看到的 logout按钮。
  - TIPS：要保证注销不存在会话终止漏洞。



**SQL注入威胁**

**SQL注入危害：**

- 探知数据库的具体结构，为进一步攻击做准备
- 泄露数据，尤其是机密信息、账户信息等
- 取得更高权限，来修改表数据甚至是内部结构

**防治手段：**

<font color=FF0000> 参数化查询</font>是对 SQL注入根本性的<font color=FF0000> 防御策略</font>，也叫做预处理语句，在建立一个包含用户输入的SQL语句时分为两步：

1. 指定查询结构,用户输入预留占位符
2. 指定占位符的内容



**XSS攻击原理**

- 跨站脚本攻击 (Cross Site Scripting)，XSS 是一种经常出现在web应用中的计算机安全漏洞。
- 它允许恶意web用户将代码植入到提供给其它用户使用的页面中，其他用户在观看网页时，恶意脚本就会执行（比如垃圾邮件）。

这类攻击通常通过注入HTML 或 js 等脚本发动攻击。

攻击成功后，攻击者可以得到私密网页内容和cookie等。

最近几年XSS攻击已经成为最流行的攻击方式。

**XSS攻击危害**

- 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号
- 控制数据,包括读取、篡改、添加、删除企业敏感数据的能力
- 盗窃企业重要的具有商业价值的资料
- 非法转账
- 强制发送网站挂马
- 控制受害者机器向其它网站发起攻击

**XSS 分类**

针对XSS的攻击方式不同，我们可以把XSS分为如下三大类
- **反射式XSS**

  - 也称为非永久性XSS，是目前最流行的XSS攻击。
  - 它出现在服务器直接使用客户端提交的数据，如url的数据、html表单中提交数据等，并且没有对数据进行无害化处理。
  - 如果提交的数据中含有HTML控制字符而没有被正确处理，那么一个简单的XSS攻击就会发生。
  - 典型的反射式攻击可通过一个邮件或中间网站，诱饵是一个看起来可信任的站点的链接，其中包含XSS攻击脚本。
  - 如果信任的网站没有正确处理这个脚本，用户点击后就会导致浏览器执行含有恶意攻击的脚本。

- **存储式XSS**

  - 也成为永久性XSS，危害更大。
  - 攻击将攻击脚本上传到Web服务器上,使得所有访问该页面的用户都面临信息泄漏的可能,其中也包括了Web服务器的管理员。
  - 存储式XSS多发生在最终显示给其他用户的位置包含：
    - 个人信息字段，如姓名、地址、电子邮件、电话等
    - 文档、上传文件及其他数据的名称
    - 提交给管理员的反馈或问题
    - 向其他应用程序用户传送的消息、注释、问题等
    - 在用户之间共享的上传文件内容
  - 典型的存储式XSS攻击过程
    - 有一个Web站点，该站点允许用户发布信息/浏览已发布的信息。
    - 攻击者注意到这个站点具有存储式的XSS漏洞。
    - 于是攻击者发布一个热点信息，利用该漏洞获取用户信息，吸引其它用户纷纷阅读。
    - 任何其他人浏览该信息，其会话cookies或者其它信息将被攻击者盗走。

- **基于DOM的XSS**

  - 反射式 XSS攻击和存储式 XSS攻击都是通过服务器端提取用户提交的数据。
  - 并且以不安全的方式将其返回给用户。
  - 基于 DOM的攻击仅仅通过 JavaScript 的方式执行。

  也就是说这种攻击常发生在应用程序每次返回相同的静态html，而通过客户端JavaScript动态生成信息，并不会跟服务端交互获取的时候。

**XSS的攻击载荷**（最有可能被攻击的地方，即弱点）

- **会话令牌**
  XSS攻击最普遍的方式。截取一名受害者的会话令牌,劫持他的会话,进而作为受害者的身份来使用应用程序,执行任意操作并占有该用户的账户。

- **虚拟置换**
  这种攻击需要在一个Web应用程序页面注入恶意数据，从而向应用程序的用户传送误导性信息。
  包括简单的向站点注入html，或者使用脚本注入精心设计的内容。
  攻击者实际上没有修改保存在服务器上的内容，而是利用程序处理并显示用户提交的输入方面的缺陷实现置换。

- **注入木马**
  这种攻击造成的后果远比虚拟置换严重，它在易受攻击的应用程序中注入实际运行的功能，旨在欺骗终端用户执行某种有害操作（如输入敏感数据）。随后将它们传送给攻击者。

  在一个明显的攻击中，攻击者注入的功能向用户显示一个木马登录表单，要求他们向攻击者控制的服务器提交他们自己的证书。
  如果由技巧熟练的攻击者实施，这种攻击还允许用户无缝登录到真正的应用程序中，以便他们不会发觉访问过程中的任何反常情况。然后，攻击者就可以自由使用受害者的证书实现自己的目的。

  这种类型的有效载荷非常适宜于用在钓鱼攻击中,向用户传送一个经过专门设计、连接可信应用程序的URL,并要求他们正常登录以访问这个URL。

**XSS 防御措施**

1. **输入验证**
   如果应用程序在某个位置收到的用户提交的数据将来有可能被复制到它的响应中，应用程序应根据这种情形对
   这些数据执行尽可能严格的确认。
   需要确认的数据的潜在特性包括以下几点：

   - 数据不是太长
   - 数据仅包含某组合法字符
   - 数据与一个特殊的正规表达式相匹配
   - 根据应用程序希望在每个字段中收到的数据类型，应尽可能限制性地对姓名、电子邮件地址、账号等应用不同的确认规则

2. **输出编码**

   - 如果应用程序将某位用户或第三方提交的数据复制到它的响应中,那么应用程序应对这些数据进行HTML编码,以净化可能的恶意字符。

   - HTML编码 指用对应的HTML实体替代字面量字符。这样做可确保浏览器安全处理可能为恶意的字符，把它们当作HTML文档的内容而非结构处理。比如说：

     ```
     " -> &quot;
     ' -> &#x27;
     < -> &lt;
     > -> &gt;
     / -> x2F;
     ```

应用程序之所以结合使用输入确认与输出净化，原因在于这种方法能够提供两层防御：如果其中一层被攻破，另一层还能提供一些保护。

许多执行输入与输出确认的过滤都容易被攻破。

结合这两种技巧,应用程序就能够获得额外的保护,即使攻击者发现其中一种过滤存在缺陷,另一种过滤仍然能够阻止他实施攻击。

在这两种防御中,输出确认最为重要,必不可少。实施严格的输入确认应被视为一种次要故障恢复。



**CSRF攻击原理**

CSRF (Cross-site Request Forgery)，**跨站请求伪造**，也被 称为"one click attack"或者“session riding”，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。
尽管听起来像跨站脚本 (XSS) ，但它与XSS 非常不同，并且击方式几乎相左。

XSS 利用站点内的信任用户（受害者） ，而CSRF通过伪装来自受信任用户的请求来利用受信任的网站。
通过社会工程学的手段（如通过电子邮件发送一个链接）来蛊惑受害者进行一些敏感性的操作，如修改密码、修改E-mail、转账等，而受害者还不知道他已经中。

CSRF的破坏力依赖于受害者在信息系统中的权限（如果是管理员的话，危害相当大）。

**CSRF攻击过程深度剖析**

1. Web浏览器对于Cookie和HTTP身份验证信息之类的会话信息的处理方式：

   - 目前,浏览器会自动地发送标识用户对话的信息,而无须用户干预。
   - 换句话说,当浏览器发送这些身份信息的时候,用户根本感觉不到。

   **举例：**假设站点A上有一个Web应用程序，并且受害者正好已经在该站点上通过了身份认证，这时，相应消息中就会有Cookie来记录这个信息。这个Cookie 的作用：

   - 主要是被站点作为用户会话的标志，即如果站点收到了带有受害者的Cookie的请求，那么它就会把这个请求看作是已登录的受害者发来的。
   - 一般情况下,浏览器收到站点设置的Cookie之后，每当向该站点发送请求的时候，浏览器都会“自动地”连同该Cookie一起发出。

2. 应用程序赖以管理会话的信息对浏览器的透明性问题：

   - 为了提高Web 的便利性，来管理会话的信息，如Cookie或者基于HTTP的身份验证（如HTTP基本认证、非基于表单的认证）等敏感信息，都是由浏览器来存放的。并在每当向需要身份验证的应用程序发送请求时自动捎带上。
   - 也就是说，浏览器可以访问会话管理信息，如果Web应用程序完全依赖于这类信息来识别一个用户会话，就为跨站请求伪造创造了条件。

**CSRF攻击预防**

- 增加一些确认操作：确认是否继续

- 重新认证：

  - 在做一些重要敏感操作时候，要求用户<font color=FF0000> 重新输入密码</font>进行<font color=FF0000> 二次验证</font>，只有正确了才进行操作。

    这种做法显然更安全，但对于用户看起来不是特别友好 -- 毕竟是增加了一步操作。

- <font color=FF0000> **使用Token**</font>（终极解决方法）：

  - 在用户刚登录的时候，产生一个新的不可预知的CSRF Token，并且把此Token存放在用户的session中。
  - 在任何一个需要保护的表单中,增加一个隐藏的字段来存放这个Token。
  - 对于需要保护的URL，增加一个参数来存放此Token。
  - 提交此请求的时候，在服务器端检查提交的Token与用户session中的Token是否一致，如果一致，继续处理请求,否则返回一个错误信息给用户。
  - 在用户退出或者session过期的时候,用户信息(包括 CSRF Token)从session中移除并且销毁session.



> ### HTTP协议原理+实践 Web开发工程师必学



**Cookie是用来保持会话信息的**



**浏览器输入URL后HTTP请求返回的完整过程**

<img src="https://i.loli.net/2021/10/15/Cw2WjVgkNFYZA3z.png" alt="image-20211015101139725" style="zoom: 50%;" />

- **Redirect：**判断是否需要Redirect，以及要Redirect到哪里。比如301 Moved Parmently的情况

- **App Cache：**查看在App Cache中是否有请求资源的缓存，如果没有就要去服务器请求资源 



**TCP/IP五层结构**

- **物理层：**主要作用是定义物理设备如何传输数据

- **数据链路层：**在通信的实体间建立数据链路连接

- **网络层：**为数据在结点之间传输创建逻辑链路
- **传输层：**向用户提供可靠的端到端 (End-to- End) 服务（比如数据过大，需要分包分片），传输层向高层屏蔽了下层数据通信的细节
- **应用层：**为应用软件提供了很多服务，构建于TCP协议之上，屏蔽网络传输相关细节



**HTTP/0.9**

- 只有一个命令：GET

- 没有HEADER等描述数据的信息

- 服务器发送完毕，就关闭 TCP 连接

**HTTP/1.0**

- 增加了很多命令：POST、HEADER、...
- 增加status code 和 header
- 多字符集支持、多部分发送、权限、缓存等

**HTTP/1.1**

- 持久连接，（短连接有三次握手相当耗费性能，还带来延迟的缺点）
- 添加pipeline，
- 添加 host头部（可以在同一台服务器上运行多个项目，提高使用效率）和其他一些命令

**HTTP2**

- 所有数据都以二进制传输，所有的数据都是通过帧来传输
- 同一个连接里面发送多个请求不再需要按照顺序来（可以并行，即多路复用）
- 头信息压缩以及<font color=FF0000> 推送</font>（服务端主动发送资源）等提高效率的功能



**TCP **

三次握手时序图

<img src="https://i.loli.net/2021/10/15/E2IfhWYPc3iaJoB.png" alt="image-20211015111106127" style="zoom:33%;" />





**HTTP方法**是用来定义队资源的操作



**可以使用curl以发送和接收http请求**

- ```sh
  curl baidu.com
  ```

  返回：

  ```html
  <html>
  <meta http-equiv="refresh" content="0;url=http://www.baidu.com/">
  </html>
  ```

  这里是访问 baidu.com，会默认跳转到 www.baidu.com

- ```sh
  curl www.baidu.com
  ```

  返回：html格式的文本

  ```html
  <!DOCTYPE html>
  <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc> <div id=wrapper> <div id=head> <div class=head_wrapper> <div class=s_form> <div class=s_form_wrapper> <div id=lg> <img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129> </div> <form id=form name=f action=//www.baidu.com/s class=fm> <input type=hidden name=bdorz_come value=1> <input type=hidden name=ie value=utf-8> <input type=hidden name=f value=8> <input type=hidden name=rsv_bp value=1> <input type=hidden name=rsv_idx value=1> <input type=hidden name=tn value=baidu><span class="bg s_ipt_wr"><input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus></span><span class="bg s_btn_wr"><input type=submit id=su value=百度一下 class="bg s_btn"></span> </form> </div> </div> <div id=u1> <a href=http://news.baidu.com name=tj_trnews class=mnav>新闻</a> <a href=http://www.hao123.com name=tj_trhao123 class=mnav>hao123</a> <a href=http://map.baidu.com name=tj_trmap class=mnav>地图</a> <a href=http://v.baidu.com name=tj_trvideo class=mnav>视频</a> <a href=http://tieba.baidu.com name=tj_trtieba class=mnav>贴吧</a> <noscript> <a href=http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb>登录</a> </noscript> <script>document.write('<a href="http://www.baidu.com/bdorz/login.gif?login&tpl=mn&u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&")+ "bdorz_come=1")+ '" name="tj_login" class="lb">登录</a>');</script> <a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;">更多产品</a> </div> </div> </div> <div id=ftCon> <div id=ftConw> <p id=lh> <a href=http://home.baidu.com>关于百度</a> <a href=http://ir.baidu.com>About Baidu</a> </p> <p id=cp>&copy;2017&nbsp;Baidu&nbsp;<a href=http://www.baidu.com/duty/>使用百度前必读</a>&nbsp; <a href=http://jianyi.baidu.com/ class=cp-feedback>意见反馈</a>&nbsp;京ICP证030173号&nbsp; <img src=//www.baidu.com/img/gs.gif> </p> </div> </div> </div> </body> </html>
  ```

- ```sh
  curl -v www.baidu.com
  ```

  返回：除了html文本外，还包含http的相应和请求报文

  ```http
  *   Trying 180.101.49.12...
  * TCP_NODELAY set
  * Connected to www.baidu.com (180.101.49.12) port 80 (#0)
  > GET / HTTP/1.1
  > Host: www.baidu.com
  > User-Agent: curl/7.64.1
  > Accept: */*
  >
  < HTTP/1.1 200 OK
  < Accept-Ranges: bytes
  < Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
  < Connection: keep-alive
  < Content-Length: 2381
  < Content-Type: text/html
  < Date: Fri, 15 Oct 2021 05:38:50 GMT
  < Etag: "588604c8-94d"
  < Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT
  < Pragma: no-cache
  < Server: bfe/1.0.8.18
  < Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
  <
  <!DOCTYPE html>
  <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc> <div id=wrapper> <div id=head> <div class=head_wrapper> <div class=s_form> <div class=s_form_wrapper> <div id=lg> <img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129> </div> <form id=form name=f action=//www.baidu.com/s class=fm> <input type=hidden name=bdorz_come value=1> <input type=hidden name=ie value=utf-8> <input type=hidden name=f value=8> <input type=hidden name=rsv_bp value=1> <input type=hidden name=rsv_idx value=1> <input type=hidden name=tn value=baidu><span class="bg s_ipt_wr"><input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus></span><span class="bg s_btn_wr"><input type=submit id=su value=百度一下 class="bg s_btn"></span> </form> </div> </div> <div id=u1> <a href=http://news.baidu.com name=tj_trnews class=mnav>新闻</a> <a href=http://www.hao123.com name=tj_trhao123 class=mnav>hao123</a> <a href=http://map.baidu.com name=tj_trmap class=mnav>地图</a> <a href=http://v.baidu.com name=tj_trvideo class=mnav>视频</a> <a href=http://tieba.baidu.com name=tj_trtieba class=mnav>贴吧</a> <noscript> <a href=http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb>登录</a> </noscript> <script>document.write('<a href="http://www.baidu.com/bdorz/login.gif?login&tpl=mn&u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&")+ "bdorz_come=1")+ '" name="tj_login" class="lb">登录</a>');</script> <a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;">更多产品</a> </div> </div> </div> <div id=ftCon> <div id=ftConw> <p id=lh> <a href=http://home.baidu.com>关于百度</a> <a href=http://ir.baidu.com>About Baidu</a> </p> <p id=cp>&copy;2017&nbsp;Baidu&nbsp;<a href=http://www.baidu.com/duty/>使用百度前必读</a>&nbsp; <a href=http://jianyi.baidu.com/ class=cp-feedback>意见反馈</a>&nbsp;京ICP证030173号&nbsp; <img src=//www.baidu.com/img/gs.gif> </p> </div> </div> </div> </body> </html>
  * Connection #0 to host www.baidu.com left intact
  * Closing connection 0
  ```



**JSONP实现原理**

浏览器允许link、img、script等带src的标签，是允许其跨域的，不在乎服务器是否设置跨域的头（Access-Control-Allow-Origin 的设置）



**CORS相关**

**跨域请求分为两种：**

- 简单请求
- 非简单请求

**一个 简单的请求 是指满足以下两个条件的请求：**

1. **简单的方法：**GET，POST 或 HEAD
2. **简单的 header**，仅允许自定义下列 header：
   - Accept，
   - Accept-Language，
   - Content-Language，
   - Content-Type 的值为 application/x-www-form-urlencoded，multipart/form-data 或 text/plain。

<font color=FF0000> **补充：**</font>还需要满足如下两点（不过用的很少）：

- XMLHttpRequestUpload对象均没有注册任何事件监听器；

  XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。

- 请求中没有使用 ReadableStream对象

任何其他请求都被认为是“非简单请求”。例如，具有 PUT 方法或 API-Key HTTP-header 的请求就不是简单请求。

<font color=FF0000> **当尝试发送一个非简单请求时，浏览器会发送一个特殊的“预检（preflight）”请求到服务器 —— 询问服务器，你接受此类跨源请求吗？**</font>并且，除非服务器明确通过 header 进行确认，否则非简单请求不会被发送。

预检请求使用 OPTIONS 方法。

如果想要给简单请求做扩展（添加其他可以使用的Method、Header等），可以使用 Access-Control-Request-Method、Access-Control-Request-Headers、Access-Control-Max-Age（在设定的时间内，不需要再做预检请求了，直接通过）、Access-Control-Allow-Origin、Access-Control-Allow-Credentials属性。

以上内容，同时也参考了 [JS 现代教程 - Fetch：跨域请求](https://zh.javascript.info/fetch-crossorigin#jian-dan-de-qing-qiu) 中的内容，原课程中的内容并不全面

另外，也可以参考：摘自：[MDN - 跨源资源共享 (CORS)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)



**Cache-Control**

特性：

- 可缓存性
  - public：http数据传输过程中经过的设备都可以缓存（包括代理服务器）
  - private：只有发起请求的浏览器才能缓存，<font color=FF0000> **代理服务器将无法缓存**</font>
  - no-store：任何一个节点都不能缓存
- 到期：
  - max-age=\<seconds>：缓存多少秒后失效
  - s-age=\<seconds>：只有在代理服务器中才会生效
  - max-stale=\<seconds>：即使缓存过期了，浏览器还可以使用该过期的缓存
- 重新验证：
  - must-revalidate：在设置了max-age中，如果该内容已经过期了，必须去原服务端发送请求，重新获取这份数据，再来验证这个内容是否真的过期了，而不能直接使用本地的缓存
  - proxy-revalidate：与must-revalidate 一样，不过，只能用在代理服务器上
- 其他：
  - no-cache：可以在本地进行缓存，本地也可以使用缓存，但是要等待服务器验证之后才能使用。就是要经过服务器端的验证。
  - no-transform：告诉代理服务器，不允许改动资源（比如格式转换、压缩）

<font color=FF0000> **注意：这些头都是限制性的、声明性质的，没有任何强制的约束力**</font>

由于Cache的存在，如果max-age 没有到期，将不会重新发送http请求，但是也有不好的地方，就是如果服务器资源改变了，浏览器资源无法第一时间更新，这时候就要用 文件名+文件hash作为文件名来防止资源改变



**数据协商**

在客户端给服务端发送请求时，客户端会声明：这个请求，希望拿到的数据格式和数据相关的限制。服务端会根据该请求里面的内容，来决定返回什么样的数据。

**分类中包含请求和返回两部分：**

- **请求** Accept
  - Accept：想要的数据类型
  - Accept-Encoding：数据的编码方式，限制服务端端数据压缩
  - Accept-Language：语言
  - User-Agent：返回什么样的页面（比如PC端的页面，还是移动端的页面；或者要不要兼容该浏览器）
- **返回** Content
  - Content-Type：
  - Content-Encoding
  - Content-Language



**301 Moved Permanently** 

服务器使用  301 Moved Permanently 需要谨慎，因为会涉及到http 缓存的问题。一旦使用了 301 Moved Permanently，这个资源改了回去，变成200 OK，如果用户一直不清缓存；那使用还是会调用 301 Moved Permanently 相关的缓存，而不是重新建立请求，获取服务器上的数据。



**CSP**

CSP的作用：

- 限制资源获取
- 报告资源获取越权

属性：

- default-src 限制全局

- 指定资源类型
  - connect-src：请求发向的目标，进行限制
  - img-src：图片可以从那几个网址进行加载
  - manifest-src：
  - media-src
  - font-src
  - frame-src
  - script-src：脚本可以从那几个网址进行加载
  - style-src：样式可以从那几个网址进行加载



**Nginx**

Mac 下 homebrew 安装的 Nginx安装的路径：/usr/local/etc/nginx

基本代理的配置，示例如下：

```nginx
# nginx.conf 配置文件下：

server {
	listen 80;
	server_name foo.com
	
	location / {
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host # 可加可不加，这个只是在设置别名
	}
}
```

此时，http://127.0.0.1:8888 将会被 foo.com 代理，访问 foo.com 就是在访问 http://127.0.0.1:8888。另外，这里server 可以配置多个。

**Nginx代理缓存**

```nginx
# nginx.conf 配置文件下：

# cache 是nginx所在文件夹下的文件夹
# levels 表示是否要创建二级文件夹
# keys_zone设置缓存的名字，可以在server中配置不同的缓存；10m是放在内存中的缓存大小
proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m

server {
	listen 80;
	server_name foo.com;
	
	location / {
	  # 配置上面定义的缓存
		proxy_cache my_cache;
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host
	}
}
```

代理缓存是在代理那一层设置的，每一个新的请求都会经过代理；所以只要代理缓存已经缓存过一次了，在浏览器这边，只要第一个用户请求，其他的用户都可以直接从代理缓存拿到数据。



**HTTP & HTTPS**

HTTP是明文传输的，数据都是未加密的，不安全；而HTTPS是数据加密的

HTTPS握手过程：

<img src="https://i.loli.net/2021/10/18/AIGCoBna8hqyb6k.png" alt="image-20211018234514531" style="zoom:33%;" />



**在Nginx中配置HTTPS**

使用openssl生成公钥和私钥，并设置保存路径（可以放在nginx文件夹下）；之后配置 nginx.conf

```nginx
# nginx.conf 配置文件下：

proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m

server {
	# https默认端口443
	listen 443;
	server_name foo.com;
	
	# 开启ssl
	ssl on;
	# 指定对应的证书，如果生成的公钥私钥，放在nginx文件夹下的cert文件夹下
	ssl_certificate_key cert/bar-privkey.pem;
	ssl_certificaqte cert/bar.pem;
	
	location / {
		proxy_cache my_cache;
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host
	}
}
```

这时https配置就已经生效，如果还想要设置，在http协议下，自动转换成https协议：

```nginx
# nginx.conf 配置文件下：

proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m

# 配置将http自动转换为https
server {
	listen 80 default_server;
	listen [::]:80 default_server;
	server_name foo.com;
	return 302 https://$server_name$request_uri;
}

server {
	listen 443;
	server_name foo.com;
	
	ssl on;
	ssl_certificate_key cert/bar-privkey.pem;
	ssl_certificaqte cert/bar.pem;
	
	location / {
		proxy_cache my_cache;
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host
	}
}
```



**HTTP2.0**

优势：

- 信道复用：只需要一个TCP 连接
- 分帧传输：发送数据不需要连续的顺序
- Server Push



**Nginx配置HTTP2**

在Nginx服务器（作为代理服务器）上配置HTTP2 要比直接在自己的服务器上配置HTTP2 要简便很多，因为很多逻辑都需要修改。即：规避了开发中需要考虑的问题，直接从代理服务器层面解决（适配器模式）

```nginx
# nginx.conf 配置文件下：

proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m

server {
	listen 80 default_server;
	listen [::]:80 default_server;
	server_name foo.com;
	return 302 https://$server_name$request_uri;
}

server {
  # 添加http2
	listen 443 http2;
	server_name foo.com;
  # 当nginx检测到link响应首部时，会主动往客户端推送资源
  http2_push_preload on;
	
	ssl on;
	ssl_certificate_key cert/bar-privkey.pem;
	ssl_certificaqte cert/bar.pem;
	
	location / {
		proxy_cache my_cache;
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host
	}
}
```



---

#### HTTP概述

HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。

**客户端：user-agent**
<font color=FF0000>user-agent 就是任何能够为用户发起行为的工具</font>。这个角色通常都是由浏览器来扮演。一些例外情况，比如是工程师使用的程序，以及Web开发人员调试应用程序（比如Postman）。

浏览器<font color=FF0000>**总是**</font>作为发起一个请求的实体，他永远不是服务器（虽然近几年已经出现一些机制能够模拟由服务器发起的请求消息了）。

**Web服务端**
在上述通信过程的另一端，是由Web Server来服务并提供客户端所请求的文档。<font color=FF0000>**Server只是虚拟意义上代表一个机器**</font>：它<mark>可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件</mark>，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 ...）发起请求来获取部分或全部资源。

<font color=FF0000>**Server 不一定是一台机器，但一个机器上可以装载的众多Servers**</font>。在HTTP/1.1 和Host头部中，它们甚至可以共享同一个IP地址。

**代理（Proxies）**
在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。<font color=FF0000>由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是透明的</font>，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为代理（Proxies）。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）。<font color=FF0000>**代理主要有如下几种作用**</font>：

- 缓存（可以是公开的也可以是私有的，像浏览器的缓存）
- 过滤（像反病毒扫描，家长控制...）
- 负载均衡（让多个服务器服务不同的请求）
- 认证（对不同资源进行权限管理）
- 日志记录（允许存储历史信息）

**HTTP 的基本性质**

- **HTTP 是简单的：**

  虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读（即：HTTP/1.1及之前，HTTP报文是语义可读的，HTTP/2 就不可读了）。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。

- **HTTP 是可扩展的：**

  在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。

- **HTTP 是无状态，有会话的：**

  HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。

**HTTP 能控制什么**

多年以来，HTTP良好的扩展性使得越来越多的Web功能归其控制。缓存和认证很早就可以由HTTP来控制了。另一方面，对同源同域的限制到2010年才有所改变。

**以下是可以被HTTP控制的常见特性：**

- **缓存 ：**文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。
- **开放同源限制：**<mark>为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息</mark>。<font color=FF0000>这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）</font>。
- **认证：**一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用Authenticate相似的头部即可，或用HTTP Cookies来设置指定的会话。
- **代理和隧道：**<font color=FF0000>通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址</font>。因此 <font color=FF0000>HTTP 请求就要通过代理越过这个网络屏障</font>。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。
- **会话：**使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。

**HTTP 报文**
<font color=FF0000>HTTP/1.1以及更早的HTTP协议报文都是语义可读的</font>。<font color=FF0000 size=4>**在HTTP/2中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文头部的压缩和复用**</font>。<font color=FF0000>即使只有原始HTTP报文的一部分以HTTP/2发送出来，每条报文的语义依旧不变，<font size=4>**客户端会重组原始HTTP/1.1请求**</font>。因此用HTTP/1.1格式来理解HTTP/2报文仍旧有效</font>。

**基于HTTP的APIs**

- 基于HTTP的最常用API是XMLHttpRequest API，可用于在user agent和服务器之间交换数据。 现代Fetch API提供相同的功能，具有更强大和灵活的功能集。

- <font color=FF0000>另一种API，即服务器发送的事件，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件</font>。 <font color=FF0000>使用EventSource接口**（Server Sent Events 相关）**，客户端打开连接并建立事件句柄</font>。 客户端浏览器自动将到达HTTP流的消息转换为适当的Event对象，并将它们传递给专门处理这类type事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给 （EventSource 接口的）onmessage 事件处理程序处理。

摘自：[MDN - HTTP概述](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview)



#### POST 方法

HTTP POST 方法 <font color=FF0000> **发送数据给服务器**</font>。<font color=FF0000> 请求主体的类型由 Content-Type 首部指定</font>。

<mark>PUT 和 POST方法的区别是</mark><font color=FF0000> ，**PUT方法是幂等的**：连续调用一次或者多次的效果相同（无副作用）</font>。<font color=FF0000> **连续调用同一个POST可能会带来额外的影响**，比如多次提交订单</font>。

<font color=FF0000> 一个 POST 请求通常是通过 HTML 表单发送， 并返回服务器的修改结果</font>。<mark>在这种情况下，content type 是通过在 \<form> 元素中设置正确的 enctype 属性，或是在 \<input> 和 \<button> 元素中设置 formenctype 属性</mark>来选择的：

- **application/x-www-form-urlencoded：**<font color=FF0000> 数据被编码成以 '&' 分隔的键-值对，同时以 '=' 分隔键和值</font>。非字母或数字的字符会被 percent-encoding（百分比编码）：这也就是为什么这种类型不支持二进制数据（应使用 multipart/form-data 代替）。
- **multipart/form-data**
- **text/plain**

当 POST 请求是通过**除 HTML 表单之外的方式发送**时，<font color=FF0000> 例如使用 XMLHttpRequest，那么请求主体可以是任何类型</font>。按HTTP 1.1规范中描述，POST为了以统一的方法来涵盖以下功能：

- 注释已有的资源
- 在公告板，新闻组，邮件列表或类似的文章组中发布消息;
- 通过注册新增用户;
- 向数据处理程序提供一批数据，例如提交一个表单;
- 通过追加操作，扩展数据库数据.

| 属性                 | 值                                        |
| :------------------- | ----------------------------------------- |
| 请求是否有主体       | 是                                        |
| 成功的响应是否有主体 | 是                                        |
| 安全                 | 否                                        |
| 幂等                 | 否                                        |
| 可缓存               | Only if freshness information is included |
| HTML 表单是否支持    | 是                                        |

**语法**

```http
POST /index.html
```

**示例**
使用<font color=FF0000 size=4> **默认的 application/x-www-form-urlencoded**</font> 做为 content type 的简单表单:

```http
POST / HTTP/1.1
Host: foo.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

say=Hi&to=Mom
```

使用 multipart/form-data 作为 content type 的表单:

```http
POST /test.html HTTP/1.1
Host: example.org
Content-Type: multipart/form-data;boundary="boundary"

--boundary
Content-Disposition: form-data; name="field1"

value1
--boundary
Content-Disposition: form-data; name="field2"; filename="example.txt"

value2
```

摘自：[MDN - POST](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST)



#### PUT 方法

HTTP PUT 请求方法使用请求中的负载创建或者替换目标资源。

PUT 与 POST 方法的区别在于，PUT方法是幂等的：调用一次与连续调用多次是等价的（即没有副作用），而连续调用多次POST方法可能会有副作用，比如将一个订单重复提交多次。

| 属性                                              | 值                                |
| :------------------------------------------------ | --------------------------------- |
| 请求是否有主体                                    | 可以有                            |
| 成功的返回是否有主体                              | 否                                |
| <font color=FF0000> **安全**</font>               | <font color=FF0000>**否** </font> |
| 幂等                                              | 是                                |
| 可缓存                                            | 否                                |
| <font color=FF0000> 可以在HTML forms中使用</font> | <font color=FF0000> **否**</font> |

**语法**

```http
PUT /new.html HTTP/1.1
```

**示例**

- **请求**

  ```http
  PUT /new.html HTTP/1.1
  Host: example.com
  Content-type: text/html
  Content-length: 16
  
  <p>New File</p>
  ```

- **应答**

  - 如果<font color=FF0000> 目标资源**不存在**</font>，<font color=FF0000> 并且PUT方法成功创建了一份</font>，<mark>那么源头服务器**必须返回201 (Created)** 来通知客户端资源已创建</mark>。

    ```http
    HTTP/1.1 201 Created
    Content-Location: /new.html
    ```

  - 如果<font color=FF0000> 目标资源**已经存在**</font>，<font color=FF0000> 并且依照请求中封装的表现形式成功进行了更新</font>，那么，<mark>源头服务器**必须返回200 (OK) 或者204 (No Content)** 来表示请求的成功完成</mark>。

    ```http
    HTTP/1.1 204 No Content
    Content-Location: /existing.html
    ```

摘自：[MDN - PUT](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PUT)



#### DELETE 方法

**HTTP DELETE** 请求方法<font color=FF0000> 用于删除指定的资源</font>。

| 属性                                              | 值                                |
| :------------------------------------------------ | --------------------------------- |
| 请求是否有主体                                    | 可以有                            |
| 成功的返回是否有主体                              | 可以有                            |
| <font color=FF0000> **安全**</font>               | <font color=FF0000>**否** </font> |
| <font color=FF0000> **幂等**</font>               | <font color=FF0000>**是**</font>  |
| 可缓存                                            | 否                                |
| <font color=FF0000> 可以在HTML forms中使用</font> | <font color=FF0000> **否**</font> |

**语法**

```http
DELETE /file.html HTTP/1.1
```

**示例**

- **请求**

  ```http
  DELETE /file.html HTTP/1.1
  ```

- **响应**

  <font color=FF0000> 如果 DELETE方法成功执行，那么可能会有以下几种状态码</font>：

  - 状态码  202 (Accepted) 表示请求的操作可能会成功执行，但是尚未开始执行。

  - 状态码 204 (No Content) 表示操作已执行，但是无进一步的相关信息。

  - <font color=FF0000> 状态码  200 (OK) 表示操作已执行，并且响应中提供了相关状态的描述信息</font>。

    ```http
    HTTP/1.1 200 OK
    Date: Wed, 21 Oct 2015 07:28:00 GMT
    
    <html>
      <body>
        <h1>File deleted.</h1>
      </body>
    </html>
    ```

摘自：[MDN - DELETE](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE)



#### OPTIONS方法

HTTP 的 OPTIONS 方法 <font color=FF0000> **用于获取目的资源所支持的通信选项** </font>。<mark>客户端可以对特定的 URL 使用 OPTIONS 方法</mark>，也可以对整站（通过将 URL 设置为“*”）使用该方法。

**语法**

```http
OPTIONS /index.html HTTP/1.1
OPTIONS * HTTP/1.1
```

| 属性                 | 值   |
| :------------------- | ---- |
| 请求是否有正文       | 否   |
| 成功的响应是否有正文 | 是   |
| 安全                 | 是   |
| 幂等                 | 是   |
| 可缓存               | 否   |
| HTML 表单 是否支持   | 否   |

**语法**

```http
OPTIONS /index.html HTTP/1.1
OPTIONS * HTTP/1.1
```

**示例：**

- **检测服务器所支持的请求方法**

  可以使用 OPTIONS 方法对服务器发起请求，以检测服务器支持哪些 HTTP 方法：

  ```sh
  curl -X OPTIONS http://example.org -i
  ```

  <font color=FF0000> 响应报文包含一个 <font size=4>**Allow 首部字段**</font>，该字段的值表明了服务器支持的所有 HTTP 方法</font>：

  ```http
  HTTP/1.1 200 OK
  Allow: OPTIONS, GET, HEAD, POST
  Cache-Control: max-age=604800
  Date: Thu, 13 Oct 2016 11:45:00 GMT
  Expires: Thu, 20 Oct 2016 11:45:00 GMT
  Server: EOS (lax004/2813)
  x-ec-custom-error: 1
  Content-Length: 0
  ```

- **CORS 中的预检请求**
  在 CORS 中，可以使用 OPTIONS 方法发起一个<font color=FF0000> **预检请求**</font>，以<font color=FF0000> 检测实际请求是否可以被服务器所接受</font>。预检请求报文中的 <font color=FF0000 size=4> **Access-Control-Request-Method**</font> 首部字段<font color=FF0000> **告知服务器**</font>实际请求所使用的 HTTP 方法；<font color=FF0000 size=4> **Access-Control-Request-Headers**</font> 首部字段<font color=FF0000> **告知服务器**</font>实际请求所携带的自定义首部字段。<font color=FF0000> 服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求</font>。

  ```http
  OPTIONS /resources/post-here/ HTTP/1.1
  Host: bar.other
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
  Accept-Language: en-us,en;q=0.5
  Accept-Encoding: gzip,deflate
  Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
  Connection: keep-alive
  Origin: http://foo.example
  Access-Control-Request-Method: POST
  Access-Control-Request-Headers: X-PINGOTHER, Content-Type
  ```

- <mark>服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中</mark>。

  ```http
  HTTP/1.1 200 OK
  Date: Mon, 01 Dec 2008 01:15:39 GMT
  Server: Apache/2.0.61 (Unix)
  Access-Control-Allow-Origin: http://foo.example
  Access-Control-Allow-Methods: POST, GET, OPTIONS
  Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
  Access-Control-Max-Age: 86400
  Vary: Accept-Encoding, Origin
  Content-Encoding: gzip
  Content-Length: 0
  Keep-Alive: timeout=2, max=100
  Connection: Keep-Alive
  Content-Type: text/plain
  ```

摘自：[MDN - OPTIONS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS)



#### HEAD方法

HTTP HEAD 方法 <font color=FF0000> **请求资源的头部信息**</font>，并且<font color=FF0000> 这些头部与 HTTP GET 方法请求时返回的一致</font>。<mark>该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源</mark>；也可以判断，一个链接是否可以访问，以及最近是否有更新

<font color=FF0000> HEAD 方法的响应不应包含响应正文</font>。即使包含了正文也必须忽略掉。虽然描述正文信息的 entity headers，例如 Content-Length 可能会包含在响应中，但它们并不是用来描述 HEAD 响应本身的，而是用来描述同样情况下的 GET 请求应该返回的响应。

如果 HEAD 请求的结果显示在上一次 GET 请求后缓存的资源已经过期了，即使没有发出GET请求，缓存也会失效

| 属性                 | 值   |
| :------------------- | ---- |
| 请求是否有正文       | 否   |
| 成功的响应是否有正文 | 否   |
| 安全                 | 是   |
| 幂等                 | 是   |
| 可缓存               | 是   |
| HTML 表单 是否支持   | 否   |

**语法**

```http
HEAD /index.html
```

摘自：[MDN - HEAD](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD)



#### CONNECT

在 HTTP 协议中，CONNECT 方法<font color=FF0000> 可以开启一个客户端与所请求资源之间的双向沟通的通道</font>。它<font color=FF0000> 可以用来创建隧道（tunnel）</font>。

例如，CONNECT 可以用来访问采用了 SSL 协议的站点。客户端要求代理服务器将 TCP 连接作为通往目的主机隧道。之后该服务器会代替客户端与目的主机建立连接。连接建立好之后，代理服务器会面向客户端发送或接收 TCP 消息流。

<font color=FF0000> CONNECT 是一个应用范围为点到点的方法</font>。

| 属性                 | 值   |
| :------------------- | ---- |
| 请求是否有正文       | 否   |
| 成功的响应是否有正文 | 是   |
| 安全                 | 否   |
| 幂等                 | 否   |
| 可缓存               | 否   |
| HTML 表单 是否支持   | 否   |

**语法**

```http
CONNECT www.example.com:443 HTTP/1.1
```

**示例**

一些代理服务器在创建隧道时会要求进行身份验证。参见  Proxy-Authorization 首部。

```http
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

摘自：[MDN - CONNECT](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/CONNECT)

**补充：**CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。

摘自：图解HTTP - P40



#### TRACE

HTTP TRACE 方法 实现<font color=FF0000> 沿通向目标资源的路径的**消息环回**（loop-back）**测试**</font> ，提供了一种实用的 debug 机制。

<mark>请求的最终接收者应当原样反射（reflect）它接收到的消息</mark>，<font color=FF0000> 除了以下字段部分，作为一个 **Content-Type** 为 message/http 的200（OK）响应的消息的主体（body）返回给客户端</font>。

<font color=FF0000> 最终接收者是指初始（origin）服务器</font>，<font size=4>**或者**</font> <font color=FF0000> 第一个接收到 Max-Forwards 值为 0的请求的服务器</font>（这里可以借鉴 TTL）。

| 属性                                     | 值   |
| :--------------------------------------- | ---- |
| 有主体（body）的请求（request）          | 否   |
| 包含主体（body）的成功的响应（response） | 否   |
| 安全                                     | 否   |
| 幂等                                     | 是   |
| 可缓存                                   | 否   |
| 允许用于 HTML 表单（form）               | 否   |

**语法**

```http
TRACE /index.html
```

摘自：[MDN - TRACE](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/TRACE)



#### Date

Date 是一个<font color=FF0000> 通用首部</font>，其中<font color=FF0000> **包含了报文创建的日期和时间**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 头类型       | 通用头 |
| 禁用首部名称 | 是     |

语法

```http
Date: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
```

指令

- **\<day-name>：**"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", 或 "Sun" 之一 （<font color=FF0000> 区分大小写</font>）。
- **\<day>：**<font color=FF0000> 2位数字</font>表示天数，例如， "04" 或 "23"。
- **\<month>：**"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" 之一（<font color=FF0000> 区分大小写</font>）。
- **\<year>：**<font color=FF0000> 4位数字</font>表示年份，例如， "1990" 或 "2016"。
- **\<hour>：**<font color=FF0000> 2位数字</font>表示小时数，例如， "09" 或 "23"。
- **\<minute>：**<font color=FF0000> 2位数字</font>表示分钟数，例如， "04" 或 "59"。
- **\<second>：**<font color=FF0000> 2位数字</font>表示秒数，例如， "04" 或 "59"。
- **GMT：**格林尼治标准时间。 <font color=FF0000>**在HTTP协议中，时间都是用格林尼治标准时间来表示的，而不是本地时间**</font>。

示例

```http
Date: Wed, 21 Oct 2015 07:28:00 GMT
```

摘自：[MDN - Date](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date)



#### Allow

Allow 首部字段<font color=FF0000> 用于枚举资源所支持的 HTTP 方法的集合</font>。

若服务器<font color=FF0000> 返回状态码 405 Method Not Allowed</font>，则<font color=FF0000> 该首部字段亦需要同时返回给客户端</font>。<mark>如果 Allow  首部字段的值为空，说明资源不接受使用任何 HTTP 方法的请求。这是可能的，比如服务器需要临时禁止对资源的任何访问</mark>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 实体头 |
| 禁用首部名称 | 否     |

**语法**

```http
Allow: <http-methods>
```

**声明**

- \<http-methods>：HTTP 请求方法的集合。

**示例**

```http
Allow: GET, POST, HEAD
```

摘自：[MDN - Allow](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Allow)



#### Connection

<font color=FF0000> Connection 头（header） **决定当前的事务完成后，是否会关闭网络连接**</font>。<mark>如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成</mark>。

> **注意：** <font color=FF0000> **特定于连接的标头字段（例如Connection）**不得与 HTTP/2 一起使用</font>。

除去标准的逐段传输（hop-by-hop）头（Keep-Alive、Transfer-Encoding、TE、Connection、Trailer、Upgrade、Proxy-Authorization 和 Proxy-Authenticate），任何逐段传输头都需要在 Connection 头中列出，这样才能让第一个代理知道必须处理它们且不转发这些头。标准的逐段传输头也可以列出（常见的例子是 Keep-Alive，但这不是必须的）。

| 属性         | 值     |
| ------------ | ------ |
| 头类型       | 通用头 |
| 禁用首部名称 | 是     |

语法

```http
Connection: keep-alive
Connection: close
```

指令

- close：表明客户端或服务器想要关闭该网络连接，这是<font color=FF0000> HTTP/1.0请求的默认值</font>

- 以逗号分隔的HTTP头 [通常仅有 keep-alive]：

  表明客户端想要保持该网络连接打开，<font color=FF0000> HTTP/1.1的请求默认使用一个持久连接</font>。这个请求头列表由头部名组成，这些头将被第一个非透明的代理或者代理间的缓存所移除：这些头定义了发出者和第一个实体之间的连接，而不是和目的地节点间的连接。

摘自：[MDN - Connection](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection)



#### Accept



#### Location

Location 首部<font color=FF0000> 指定的是**需要将页面重新定向至的地址**</font>。<font color=FF0000> 一般在响应码为3xx的响应中才会有意义</font>。

发送新请求，获取Location指向的新页面所采用的方法与初始请求使用的方法以及重定向的类型相关：

- <font color=FF0000>**303 (See Also)** </font>始终引致请求使用 GET 方法，而，而 <font color=FF0000> **307 (Temporary Redirect)** </font>和 <font color=FF0000> **308 (Permanent Redirect)** </font>则不转变初始请求中的所使用的方法；
- <font color=FF0000> **301 (Permanent Redirect)**</font> 和 <font color=FF0000> **302 (Found)**</font> 在大多数情况下不会转变初始请求中的方法，不过一些比较早的用户代理可能会引发方法的变更（所以你基本上不知道这一点）。

状态码为上述之一的所有响应都会带有一个Location首部。

<font color=FF0000> **除了重定向响应之外， 状态码为 201 (Created) 的消息也会带有Location首部**。它指向的是新创建的资源的地址</font>。

Location 与 Content-Location是不同的，前者（Location ）指定的是一个重定向请求的目的地址（或者新创建的文件的URL），而后者（ Content-Location） 指向的是经过内容协商后的资源的直接地址，不需要进行进一步的内容协商。Location 对应的是响应，而Content-Location对应的是要返回的实体。

| 属性         | 值       |
| ------------ | -------- |
| 报文类型     | 响应首部 |
| 禁用首部名称 | 否       |

**语法**

```http
Location: <url>
```

指令

- **\<url>：**相对地址（相对于要访问的URL）或绝对地址。

示例

```http
Location: /index.html
```

摘自：[MDN - Location](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location)



#### Via

Via 是一个<font color=FF0000> **通用首部**</font>，是<font color=FF0000> 由代理服务器添加</font>的，<font color=FF0000> 适用于正向和反向代理</font>，<font color=FF0000> 在请求和响应首部中均可出现</font>。这个消息首部<font color=FF0000> 可以用来追踪消息转发情况，**防止循环请求**</font>，以及<font color=FF0000> 识别在请求或响应传递链中消息发送者对于协议的支持能力</font>。

| 属性         | 值       |
| ------------ | -------- |
| 报文类型     | 通用首部 |
| 禁用首部名称 | 是       |

语法

```http
Via: [ <protocol-name> "/" ] <protocol-version> <host> [ ":" <port> ]
Via: [ <protocol-name> "/" ] <protocol-version> <pseudonym>
```

指令

- **\<protocol-name>：**<font color=FF0000> 可选</font>。所使用的协议名称，如 "HTTP"。（如下示例，http之类的协议名称可以省略）
- **\<protocol-version>：**所使用的协议版本号， 例如 "1.1"。
- **\<host> & \<port>：**公共代理的URL及端口号。
- **\<pseudonym>：**内部代理的名称或别名。

示例

```http
Via: 1.1 vegur
Via: HTTP/1.1 GWA
Via: 1.0 fred, 1.1 p.example.net
```

摘自：[MDN - Via](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via)



#### TE

TE 请求型头部<font color=FF0000> 用来指定**用户代理希望使用的<font size=4>传输编码类型</font>**</font>。(<mark>可以将其非正式称为 Accept-Transfer-Encoding</mark>， 这个名称显得更直观一些)。

可以参考  Transfer-Encoding 来获取更多关于传输编码的细节信息。**值得注意的是， <font color=FF0000> 支持 HTTP/1.1 协议的接收方一定可以处理 chunked 传输编码请求</font>，所以没有必要一定在  TE 首部指定“chunked”关键字**。然而，如果客户端将要接收编码在chunked包体里面的"trailer"信息的时候，主动指定该头部将会非常有用。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 请求头 |
| 禁用首部名称 | 是     |

语法

```http
TE: compress
TE: deflate
TE: gzip
TE: trailers
// 多个指令, 使用 quality value 语法来表示优先级:
TE: trailers, deflate;q=0.5
```

指令

- **compress：**这个名称代表采用了 <mark> Lempel-Ziv-Welch (LZW) 压缩算法的传输编码格式</mark>。
- **deflate：**这个名称代表采用了 <font color=FF0000> zlib 结构的传输编码格式</font>。
- **gzip：**这个名称代表采用了  <font color=FF0000> Lempel-Ziv coding (LZ77) 压缩算法，以及32位CRC校验的传输编码格式</font>。
- **trailers：**表示<font color=FF0000> 客户端期望在采用分块传输编码的响应中接收挂载字段</font>。
- **q：**当多种形式的传输编码格式都可以接受的时候，这个采用了质量价值语法的参数可以用来对不同的编码形式按照**优先级**进行排序。

摘自：[MDN - TE](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/TE)



#### Vary

Vary 是一个HTTP<font color=FF0000> 响应头部</font>信息，它<font color=FF0000> 决定了对于未来的一个请求头，**应该用一个缓存的回复 (response)  还是向源服务器请求一个新的回复**</font>。它<font color=FF0000> 被服务器用来表明在 content negotiation algorithm（**内容协商算法**）中**选择一个资源代表的时候应该使用哪些头部信息**</font>（headers）。

<mark><font color=FF0000> 在响应状态码为 304 Not Modified  的响应中，也要设置 Vary 首部</font>，而且要与相应的 200 OK 响应设置得一模一样</mark>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

语法

```http
Vary: *
Vary: <header-name>, <header-name>, ...
```

说明

- **\*：**<font color=FF0000> 所有的请求都被视为唯一并且非缓存的</font>，使用Cache-Control: no-store,来实现则更适用，这样用于说明不存储该对象更加清晰。
- **\<header-name>：**<font color=FF0000> 逗号分隔的一系列http头部名称，用于确定缓存是否可用</font>。

**例子**
动态服务
哪种情况下使用 Vary：对于User-Agent 头部信息，例如你提供给移动端的内容是不同的，可用防止你客户端误使用了用于桌面端的缓存。 并可帮助Google和其他搜索引擎来发现你的移动端版本的页面，同时告知他们不需要Cloaking。

```http
Vary: User-Agent
```

摘自：[MDN - Vary](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary)

<font size=4>**补充：**</font>vary 的作用是，在发送请求时，只有<font color=FF0000> 指定的HTTP头的值相同的情况下</font>，才会去使用缓存。



#### DNT

请求首部 **DNT** (**D**o **N**ot **T**rack) 表明了用户对于网站追踪的偏好。它允许用户指定自己是否更注重个人隐私还是定制化内容。

| 属性         | 值     |
| ------------ | ------ |
| 头类型       | 请求头 |
| 禁用首部名称 | 是     |

**语法：**

```http
DNT: 0
DNT: 1
```

**指令**

- 0：表示<font color=FF0000> 用户愿意目标站点追踪用户个人信息</font>。
- 1：表示<font color=FF0000> 用户**不愿意**目标站点追踪用户个人信息</font>。

用户对 DNT 的设置还可以使用 Navigator.doNotTrack 属性进行读取：

```js
navigator.doNotTrack; // "0" or "1"
```

摘自：[MDN - DNT](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT)



#### Range

The Range 是一个 <font color=FF0000> **请求首部**</font>，<font color=FF0000> 告知服务器返回文件的哪一部分</font>。<mark>在一个  Range 首部中，**可以一次性请求多个部分**，服务器会以 multipart 文件的形式将其返回</mark>。<mark style="background: aqua">如果服务器返回的是范围响应，需要使用 206 Partial Content 状态码</mark>。<mark style="background-color: fuchsia">假如所请求的范围不合法，那么服务器会返回  416 Range Not Satisfiable 状态码，表示客户端错误</mark>。服务器允许忽略  Range  首部，从而返回整个文件，状态码用 200

| 属性         | 值     |
| ------------ | ------ |
| 头类型       | 请求头 |
| 禁用首部名称 | 否     |

**示例：**

<img src="https://i.loli.net/2021/10/02/xpgK7J46UuqTXSL.png" alt="image-20211002165634152" style="zoom: 33%;" />

**语法**

```http
Range: <unit>=<range-start>-
Range: <unit>=<range-start>-<range-end>
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>, <range-start>-<range-end>
```

**指令**

- **\<unit>：**范围所采用的单位，通常是字节（bytes）。
- **\<range-start>：**一个整数，表示在特定单位下，范围的起始值。
- **\<range-end>：**一个整数，表示在特定单位下，范围的结束值。这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。

摘自：[MDN - Range](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range)



#### Access-Control-Request-Method

请求头  Access-Control-Request-Method <font color=FF0000> 出现于 preflight request （预检请求）中</font>，用于<font color=FF0000> 通知服务器在真正的请求中会采用哪种  HTTP 方法</font>。因为预检请求所使用的方法总是 OPTIONS ，与实际请求所使用的方法不一样，所以这个请求头是必要的。

| 属性         | 值     |
| ------------ | ------ |
| http头种类   | 请求头 |
| 禁用首部名称 | 是     |

语法

```http
Access-Control-Request-Method: <method>
```

指令

- \<method>：一种 HTTP请求方法 , 例如 GET、POST 或 DELETE。

摘自：[MDN - Access-Control-Request-Method](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method)

#### Access-Control-Request-Headers

请求头  Access-Control-Request-Headers <font color=FF0000> 出现于 preflight request （预检请求）中，用于通知服务器在真正的请求中会采用哪些请求头</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报头类型     | 请求头 |
| 禁用首部名称 | 是     |

语法

```http
Access-Control-Request-Headers: <header-name>, <header-name>, ...
```

指令

- \<header-name>：在实际请求中将要包含的一系列 HTTP 头，以逗号分隔。

示例

```http
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
```

摘自：[MDN - Access-Control-Request-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers)

#### Access-Control-Allow-Methods

响应首部 Access-Control-Allow-Methods 在<font color=FF0000> 对 preflight request（预检请求）的应答中**明确了客户端所要访问的资源允许使用的方法或方法列表**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**

```http
Access-Control-Allow-Methods: <method>, <method>, ...
```

**指令**

- **\<method>：**用逗号隔开的允许使用的 HTTP request methods 列表。

例子

```http
Access-Control-Allow-Methods: POST, GET, OPTIONS
```

摘自：[MDN - Access-Control-Allow-Methods](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods)

#### Access-Control-Allow-Headers

响应首部 Access-Control-Allow-Headers <font color=FF0000> 用于 preflight request （预检请求）中，列出了将会在正式请求的 Access-Control-Request-Headers 字段中出现的首部信息</font>。

<font color=FF0000> 简单首部</font>，如 simple headers、Accept、Accept-Language、Content-Language、Content-Type （只限于解析后的值为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain 三种MIME类型（不包括参数）），<font color=FF0000> 它们始终是被支持的，不需要在这个首部特意列出</font>。

<font color=FF0000> 如果请求中含有 Access-Control-Request-Headers 字段，那么这个首部是必要的</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**

```http
Access-Control-Allow-Headers: <header-name>[, <header-name>]*
Access-Control-Allow-Headers: *
```

**指令**

- **\<header-name>：**<font color=FF0000> 可支持的请求首部名字。请求头会列出所有支持的首部列表，用逗号隔开</font>。

  注意以下这些特定的首部是一直允许的：Accept, Accept-Language, Content-Language, Content-Type （但只在其值属于 MIME 类型 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种时）。这些被称作简单首部，你无需特意声明它们。

* **\* (wildcard)：**对于没有凭据的请求（没有HTTP cookie或HTTP认证信息的请求），值“ *”仅作为特殊的通配符值。 在具有凭据的请求中，它被视为没有特殊语义的文字标头名称“ *”。 请注意，Authorization标头不能使用通配符，并且始终需要明确列出。

摘自：[MDN - Access-Control-Allow-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers)

#### Access-Control-Max-Age

The Access-Control-Max-Age 这个响应头<font color=FF0000> 表示 preflight request（预检请求）的**返回结果**（即 Access-Control-Allow-Methods 和Access-Control-Allow-Headers 提供的信息） <font size=4>**可以被缓存多久**</font></font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**指令**

- **\<delta-seconds>：**返回结果可以被缓存的最长时间（秒）。
  - 在 Firefox 中，上限是24小时（即 86400 秒）。
  - 在 Chromium v76 之前， 上限是 10 分钟（即 600 秒)。
  - 从 Chromium v76 开始，上限是 2 小时（即 7200 秒)。
  - Chromium 同时规定了一个默认值 5 秒。
  - 如果值为 -1，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。

**示例**
将预检请求的结果缓存10分钟：

```http
Access-Control-Max-Age: 600 
```

摘自：[MDN - Access-Control-Max-Age](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age)

#### Access-Control-Allow-Origin

Access-Control-Allow-Origin 响应头<font color=FF0000> 指定了**该响应的资源是否被允许与给定的origin共享**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**

```http
Access-Control-Allow-Origin: *
Access-Control-Allow-Origin: <origin>
```

**指令**

- **\*：**对于不需具备凭证（credentials）的请求，服务器会以“*”作为通配符，从而<font color=FF0000> 允许所有域都具有访问资源的权限</font>。
- **\<origin>：**指定一个可以访问资源的URI。

如果服务器未使用“*”，而是指定了一个域，那么为了向客户端表明服务器的返回会根据Origin请求头而有所不同，必须在Vary响应头中包含Origin。

```http
Access-Control-Allow-Origin: https://developer.mozilla.org
Vary: Origin
```

摘自：[MDN - Access-Control-Allow-Origin](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)

#### Access-Control-Allow-Credentials

Access-Control-Allow-Credentials 响应头<font color=FF0000> 表示是否可以将对请求的响应暴露给页面</font>。<font color=FF0000> 返回true则可以，其他值均不可以</font>。

<font color=FF0000 size=4> **Credentials可以是 cookies, authorization headers 或 TLS client certificates**</font>。

当<font color=FF0000> 作为对预检请求的响应的一部分时，这能表示是否真正的请求可以使用credentials</font>。注意简单的 GET 请求没有预检，所以若一个对资源的请求带了credentials，如果这个响应头没有随资源返回，响应就会被浏览器忽视，不会返回到web内容。

<font color=FF0000 size=4> **Access-Control-Allow-Credentials 头 工作中与 XMLHttpRequest.withCredentials 或 Fetch API中的Request() 构造器中的credentials 选项结合使用**</font>。Credentials <font color=FF0000> **必须在前后端都被配置**</font>（即 the Access-Control-Allow-Credentials header 和 XHR 或Fetch request中都要配置）才能使带 credentials 的 CORS 请求成功。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**

```http
Access-Control-Allow-Credentials: true
```

**指令**

- **true：**这个头的唯一有效值（区分大小写）。如果不需要credentials，相比将其设为false，请直接忽视这个头。

<font size=4>**例子**</font>

**允许credentials：**

```http
Access-Control-Allow-Credentials: true
```

**使用带credentials的 XHR ：**

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

**使用带credentials的 Fetch ：**

```js
fetch(url, {
  credentials: 'include'
})
```

摘自：[MDN - Access-Control-Allow-Credentials](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials)

#### Access-Control-Expose-Headers

响应首部 Access-Control-Expose-Headers 列出了哪些首部可以作为响应的一部分暴露给外部。

默认情况下，只有七种 simple response headers （简单响应首部）可以暴露给外部：

- Cache-Control
- Content-Language
- Content-Length
- Content-Type
- Expires
- Last-Modified
- Pragma

如果想要让客户端可以访问到其他的首部信息，可以将它们在 Access-Control-Expose-Headers 里面列出来。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

语法

```http
Access-Control-Expose-Headers: <header-name>, <header-name>, ...
```

指令

- \<header-name>：包含0个或多个除“简单响应首部”之外的首部名称列表，可以暴露给外部，供页面资源使用。

示例

- 想要暴露一个非简单响应首部，可以这样指定：

  ```http
  Access-Control-Expose-Headers: Content-Length
  ```

- 想要额外暴露自定义的首部，例如 X-Kuma-Revision，可以指定多个，用逗号隔开：

  ```http
  Access-Control-Expose-Headers: Content-Length, X-Kuma-Revision
  ```

摘自：[MDN - Access-Control-Expose-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers)



#### Proxy-Authorization

Proxy-Authorization 是一个<font color=FF0000> **请求首部**</font>，<font color=FF0000> 其中包含了**用户代理提供给<font size=4>代理服务器</font>**的**用于身份验证的凭证**</font>。<font color=FF0000> 这个首部通常是在服务器返回了 407 Proxy Authentication Required 响应状态码及 **Proxy-Authenticate 首部 <font size=4>后</font> 发送**的</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 请求头 |
| 禁用首部名称 | 否     |

语法

```http
Proxy-Authorization: <type> <credentials>
```

指令

- **\<type>：**<font color=FF0000> 身份验证类型</font>。一个常见的类型是 "基本验证"（basic authentication）。IANA 机构维护了[ 一系列的身份验证机制](https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml)。除了基本验证 之外，还有：digest认证、SSL客户端认证、基于表单认证

- **\<credentials>：**凭证的构成方式如下：

  - <mark>将用户名和密码用冒号拼接（aladdin:opensesame）</mark>。
  - 将拼接生成的字符串使用 base64 编码方式进行编码（YWxhZGRpbjpvcGVuc2VzYW1l）。

  <font color=FF0000> **注意：**</font> Base64 编码方式不是用来加密或者获取摘要的！这种方法的安全性相当于将凭证使用明文发送（base64 是一种可逆编码方式）。在使用基本身份验证方式的时候推荐与 HTTPS 搭配使用。

示例

```http
Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

摘自：[MDN - Proxy-Authorization](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authorization)

#### Proxy-Authenticate

The HTTP Proxy-Authenticate 是一个<font color=FF0000> **响应首部**</font>，<font color=FF0000>指定了**获取 代理服务器 上的资源访问权限而采用的身份验证方式**</font>。<font color=FF0000> 代理服务器对请求进行验证，以便它进一步传递请求</font>。

<font color=FF0000> Proxy-Authenticate 首部需要与 407 Proxy Authentication Required 响应一起发送</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

语法

```http
Proxy-Authenticate: <type> realm=<realm>
```

指令

- **\<type>：**身份验证类型。一个常见的类型是 "基本验证"。IANA 机构维护了 一系列的身份验证机制（详情见上面的Proxy-Authorization）。
- **realm=\<realm>：**<font color=FF0000> 对于被保护区域（即安全域）的描述</font>。<mark>如果没有指定安全域，客户端通常用一个格式化的主机名来代替</mark>。

示例

```http
Proxy-Authenticate: Basic
Proxy-Authenticate: Basic realm="Access to the internal site"
```

摘自：[MDN - Proxy-Authenticate](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authenticate)

#### WWW-Authenticate

HTTP WWW-Authenticate 响应头<font color=FF0000> 定义了使用何种验证方式（Basic、digest ...）去获取对资源的连接</font>。

WWW-Authenticate header<font color=FF0000> **通常会和一个 401 Unauthorized 的响应一同被发送**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

语法

```http
WWW-Authenticate: <type> realm=<realm>
```

指令

- **\<type>：**Authentication type，一个通用类型 "Basic"。 IANA 维护了一个 list of Authentication schemes。
- **realm=\<realm>：**一个保护区域的描述。如果未指定realm，客户端通常显示一个格式化的主机名来替代。
- **charset=\<charset>：**<font color=FF0000> 当提交用户名和密码时，告知客户端服务器首选的**编码方案**</font>。唯一的允许值是不区分大小写的字符串"UTF-8"。这与realm字符串的编码无关。

**示例**
通常的, 一个服务器响应包含一个像如下WWW-Authenticate的头信息：

```http
WWW-Authenticate: Basic
WWW-Authenticate: Basic realm="Access to the staging site"
```

摘自：[MDN - WWW-Authenticate](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/WWW-Authenticate)



#### Content-Type

Content-Type 实体头部<font color=FF0000>用于指示资源的MIME类型 media type </font>。

在响应中，Content-Type标头<font color=FF0000>告诉客户端实际返回的内容的内容类型</font>。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。

| 属性         | 值       |
| ------------ | -------- |
| 报文类型     | 实体报头 |
| 禁用首部名称 | 不是     |
| 简易响应头   | 是       |

- **句法：**

  ```http
  Content-Type: text/html; charset=utf-8
  Content-Type: multipart/form-data; boundary=something
  ```

- **指令：**

  - **media-type：**<font color=FF0000>资源或数据的 MIME type</font> 。如：上面的 text/html
  - **charset：**<font color=FF0000>字符编码标准</font>。如：上面的 charset=utf-8
  - **boundary：**<font color=FF0000>对于多部分实体，boundary 是必需的</font>，其包括来自一组字符的1到70个字符，已知通过电子邮件网关是非常健壮的，而不是以空白结尾。它用于封装消息的多个部分的边界。

摘自：[MDN - Content-Type](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)

#### X-Content-Type-Options

X-Content-Type-Options HTTP 消息头<font color=FF0000> 相当于一个提示标志</font>，<font color=FF0000> 被服务器用来**提示客户端一定要遵循在 Content-Type 首部中对  MIME 类型 的设定，而不能对其进行修改** </font>。<font color=FF0000> **这就禁用了客户端的 MIME 类型嗅探行为**，换句话说，**也就是意味着网站管理员确定自己的设置没有问题** </font>。

该消息头最初是由微软在 IE 8 浏览器中引入的，<mark> 提供给网站管理员用作禁用内容嗅探的手段，内容嗅探技术可能会把不可执行的 MIME 类型转变为可执行的 MIME 类型</mark>。<font color=FF0000> 在此之后，其他浏览器也相继引入了这个消息头，尽管它们的 MIME 嗅探算法没有那么有侵略性</font>。

安全测试人员通常期望站点设置了该消息头。

注意: <font color=FF0000> nosniff 只应用于 "script" 和 "style" 两种类型</font>。事实证明，将其应用于图片类型的文件会导致与现有的站点冲突。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**

```http
X-Content-Type-Options: nosniff
```

**指令**

- **nosniff：**<font color=FF0000> 下面两种情况的请求将被阻止 </font>
  - 请求类型是"style" 但是 MIME 类型不是 "text/css"，
  - 请求类型是"script" 但是 MIME 类型不是  JavaScript MIME 类型

摘自：[MDN - X-Content-Type-Options](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options)



#### Accept-Ranges

服务器使用 HTTP 响应头 Accept-Ranges <font color=FF0000> **标识自身支持范围请求**(partial requests)</font>。字段的<font color=FF0000> 具体值**用于定义范围请求的单位** </font>。

当<font color=FF0000> 浏览器发现 Accept-Ranges 头时，**可以尝试继续中断了的下载**，而不是重新开始</font>。

| 类型               | 值     |
| :----------------- | ------ |
| 头部类型           | 响应头 |
| 禁止修改的 HTTP 头 | 否     |

**语法**

```http
Accept-Ranges: bytes
Accept-Ranges: none
```

**指令**

- **none：**<font color=FF0000> 不支持任何范围请求单位</font>，<mark>由于其等同于没有返回此头部，因此很少使用</mark>。不过一些浏览器，比如IE9，会依据该头部去禁用或者移除下载管理器的暂停按钮。
- **bytes：**<font color=FF0000> 范围请求的单位是 bytes （字节）</font>。

摘自：[MDN - Accept-Ranges](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Ranges)



#### Content-Length

Content-Length 是一个实体消息首部，<font color=FF0000>用来**指明发送给接收方的消息主体的大小**</font>，即<font color=FF0000>用十进制数字表示的八位元组的数目（**即字节bit的数目**）</font>。

| 属性         | 值       |
| ------------ | -------- |
| 报文类型     | 实体报头 |
| 禁用首部名称 | 是       |

**语法：**

```http
Content-Length: <length>
```

摘自：[MDN - Content-Length](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length)



#### HTTP cookies

HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）<font color=FF0000>是 <font size=4>**服务器发送到用户浏览器**</font>并保存在本地的一小块数据</font>，<font color=FF0000>它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</font>。<mark style=background-color:hotpink>通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态</mark>。<font color=FF0000>Cookie 使 <font size=4>**基于无状态的HTTP协议**</font> 记录稳定的状态信息成为了可能</font>。

**Cookie 主要用于以下三个方面：**

- <font color=FF0000>会话状态管理</font>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- <font color=FF0000>个性化设置</font>（如用户自定义设置、主题等）
- <font color=FF0000>浏览器行为跟踪</font>（如跟踪分析用户行为等）

**创建Cookie**

<font color=FF0000>当服务器收到 HTTP 请求时，**服务器可以在响应头里面添加一个 Set-Cookie 选项**</font>。<font color=FF0000>浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过  Cookie 请求头部将 Cookie 信息发送给服务器</font>。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

**Set-Cookie响应头部和Cookie请求头部**

<font color=FF0000 size=4>**服务器使用 Set-Cookie 响应头部向用户代理（一般是浏览器）发送 Cookie信息**</font>。一个简单的 Cookie 可能像这样：

```http
Set-Cookie: <cookie名>=<cookie值>
```

<font color=FF0000>服务器通过该头部告知客户端保存 Cookie 信息</font>。

```http
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[页面内容]
```

<font color=FF0000>**现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 Cookie 请求头部再发送给服务器**</font>。

```http
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

**定义 Cookie 的生命周期**

Cookie 的生命周期可以通过<font color=FF0000>**两种方式定义**</font>：

- **会话期 Cookie 是最简单的 Cookie：**<font color=FF0000>浏览器关闭之后它会被自动删除</font>，<font color=FF0000>也就是说它仅在会话期内有效</font>。<font color=FF0000>会话期Cookie**不需要指定过期时间（Expires）或者有效期（Max-Age）**</font>。<mark>需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长</mark>。
- **持久性 Cookie** 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。

例如：

```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

<mark>如果您的站点对用户进行身份验证，则每当用户进行身份验证时</mark>，<font color=FF0000>它都应重新生成并重新发送会话 Cookie，甚至是已经存在的会话 Cookie</font>。<mark>此技术有助于防止会话固定攻击（session fixation attacks），在该攻击中第三方可以重用用户的会话</mark>。

**限制访问 Cookie**

<font color=FF0000>有两种方法可以确保 Cookie 被安全发送</font>，并且不会被意外的参与者或脚本访问：<font color=FF0000>**Secure 属性和HttpOnly 属性**</font>。

- <font color=FF0000>**标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端**</font>，因此可以预防 man-in-the-middle 攻击者的攻击。<font color=FF0000>但**即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输**</font>，<mark style=background-color:hotpink>因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它</mark>。

- <font color=FF0000>JavaScript Document.cookie API 无法访问带有 HttpOnly 属性的cookie</font>；<font color=FF0000>此类 Cookie 仅作用于服务器</font>。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性。此预防措施有助于缓解跨站点脚本（XSS）攻击。

**Cookie 的作用域**

<font color=FF0000>Domain 和 Path 标识定义了Cookie的作用域：**即允许 Cookie 应该发送给哪些URL**</font>。

- **Domain 属性：**<font color=FF0000>**Domain 指定了哪些主机可以接受 Cookie**</font>。<font color=FF0000>如果不指定，默认为 origin，不包含子域名</font>。<font color=FF0000>如果指定了Domain，则一般包含子域名</font>。<mark style=background-color:hotpink>因此，指定 Domain 比省略它的限制要少</mark>。但是，当子域需要共享有关用户的信息时，这可能会有所帮助。 

  例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如developer.mozilla.org）。

- **Path 属性：**<font color=FF0000>**Path 标识指定了主机下的<font size=4>哪些路径</font>可以接受 Cookie**</font>（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。
  <mark style=background-color:hotpink>例如，设置 Path=/docs，则以下地址都会匹配：</mark>

  ```
  /docs
  /docs/Web/
  /docs/Web/HTTP
  ```

**SameSite attribute**

SameSite Cookie 允许服务器要求<font color=FF0000>某个 cookie 在**跨站请求**时不会被发送</font>，（其中Site由可注册域定义），<mark style=background-color:hotpink>从而可以阻止跨站请求伪造攻击（CSRF）</mark>。

SameSite cookies 是相对较新的一个字段，所有主流浏览器都已经得到支持。

下面是例子：

```http
Set-Cookie: key=value; SameSite=Strict
```

**SameSite 可以有下面三种值：**

- **None：**<font color=FF0000>浏览器会在同站请求、跨站请求下继续发送 cookies</font>，不区分大小写。
- **Strict：**<font color=FF0000>浏览器将只在**访问相同站点**时发送 cookie</font>。（在原有 Cookies 的限制条件上的加强）
- **Lax：**<font color=FF0000>与 Strict 类似</font>，<font color=FF0000>但**用户从外部站点导航至URL时（例如通过链接）除外**</font>。 <font color=FF0000>**在新版本浏览器中，为默认选项**</font>，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到URL时才会发送。如 link 链接

**Cookie prefixes**

<font color=FF0000>cookie 机制的使得服务器无法确认 cookie 是在安全来源上设置的，甚至无法确定 cookie 最初是在哪里设置的</font>。

子域上的易受攻击的应用程序可以使用 Domain 属性设置 cookie，从而可以访问所有其他子域上的该 cookie。会话固定攻击中可能会滥用此机制。有关主要缓解方法，请参阅会话劫持（ session fixation）。

**但是，作为深度防御措施，可以使用 cookie 前缀来断言有关 cookie 的特定事实**。有两个前缀可用：

- **\_\_Host-：**如果 cookie 名称具有此前缀，则仅当它也用 Secure 属性标记，是从安全来源发送的，不包括 Domain 属性，并将 Path 属性设置为 / 时，它才在 Set-Cookie 标头中接受。这样，这些 cookie 可以被视为 "domain-locked”。
- **\_\_Secure-：**如果 cookie 名称具有此前缀，则仅当它也用 Secure 属性标记，是从安全来源发送的，它才在 Set-Cookie 标头中接受。该前缀限制要弱于 \__Host- 前缀。
  带有这些前缀点 Cookie， 如果不符合其限制的会被浏览器拒绝。请注意，这确保了如果子域要创建带有前缀的 cookie，那么它将要么局限于该子域，要么被完全忽略。由于应用服务器仅在确定用户是否已通过身份验证或 CSRF 令牌正确时才检查特定的 cookie 名称，因此，这有效地充当了针对会话劫持的防御措施。

**安全**

信息被存在 Cookie 中时，需要明白 cookie 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 JSON Web Tokens 之类的替代身份验证/机密机制。

<font color=FF0000>**当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息**</font>。

**缓解涉及Cookie的攻击的方法：**

- <font color=FF0000>使用 HttpOnly 属性</font>可防止通过 JavaScript 访问 cookie 值。
- <font color=FF0000>用于敏感信息（例如指示身份验证）的 Cookie 的生存期应较短</font>，<font color=FF0000>并且 SameSite 属性设置为Strict 或 Lax</font>。在支持 SameSite 的浏览器中，这样做的作用是确保不与跨域请求一起发送身份验证 cookie，因此，这种请求实际上不会向应用服务器进行身份验证。

摘自：[MDN - HTTP cookies](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)

#### Set-Cookie

<font color=FF0000>响应首部 Set-Cookie **被用来由服务器端向客户端发送 cookie**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 是     |

**语法：**

```http
Set-Cookie: <cookie-name>=<cookie-value>
Set-Cookie: <cookie-name>=<cookie-value>; Expires=<date>
Set-Cookie: <cookie-name>=<cookie-value>; Max-Age=<non-zero-digit>
Set-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>
Set-Cookie: <cookie-name>=<cookie-value>; Path=<path-value>
Set-Cookie: <cookie-name>=<cookie-value>; Secure
Set-Cookie: <cookie-name>=<cookie-value>; HttpOnly

Set-Cookie: <cookie-name>=<cookie-value>; SameSite=Strict
Set-Cookie: <cookie-name>=<cookie-value>; SameSite=Lax

// Multiple directives are also possible, for example:
Set-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>; Secure; HttpOnly
```

**指令**

- **\<cookie-name>=\<cookie-value>：**<font color=FF0000>一个 cookie 开始于一个名称/值对</font>：
  - **\<cookie-name>：** <mark style=background-color:hotpink>可以是除了控制字符 (CTLs)、空格 (spaces) 或制表符 (tab)之外的任何 US-ASCII 字符</mark>。同时不能包含以下分隔字符： ( ) < > @ , ; : \ " /  [ ] ? = { }.
  - **\<cookie-value>：** <mark style=background-color:hotpink>是可选的</mark>，<font color=FF0000>如果存在的话，那么需要包含在双引号里面</font>。支持除了控制字符（CTLs）、空格（whitespace）、双引号（double quotes）、逗号（comma）、分号（semicolon）以及反斜线（backslash）之外的任意 US-ASCII 字符。关于编码：许多应用会对 cookie 值按照URL编码（URL encoding）规则进行编码，但是按照 RFC 规范，这不是必须的。不过满足规范中对于 \<cookie-value> 所允许使用的字符的要求是有用的。
  - **\_\_Secure- 前缀：**<font color=FF0000>以 \_\_Secure- 为前缀的 cookie（其中连接符是前缀的一部分），必须与 secure 属性一同设置</font>，同时必须应用于安全页面（即使用 HTTPS 访问的页面）。
  - **\_\_Host- 前缀：**<font color=FF0000>以 __Host- 为前缀的 cookie，必须与 secure 属性一同设置</font>，必须应用于安全页面（即使用 HTTPS 访问的页面），<font color=FF0000>必须不能设置 domain 属性 （也就不会发送给子域），同时 path 属性的值必须为“/”</font>。
- **Expires=\<date>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>cookie 的最长有效时间</font>，<font color=FF0000>形式为符合 HTTP-date 规范的时间戳</font>。参考 Date 可以获取详细信息。如果没有设置这个属性，那么表示这是一个会话期 cookie 。一个会话结束于客户端被关闭时，这意味着会话期 cookie 在彼时会被移除。然而，很多Web浏览器支持会话恢复功能，这个功能可以使浏览器保留所有的tab标签，然后在重新打开浏览器的时候将其还原。与此同时，cookie 也会恢复，就跟从来没有关闭浏览器一样。

- **Max-Age=\<non-zero-digit>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>在 cookie 失效之前需要经过的秒数</font>。<font color=FF0000>**秒数为 0 或 -1 将会使 cookie 直接过期**</font>。一些老的浏览器（ie6、ie7 和 ie8）不支持这个属性。对于其他浏览器来说，<font color=FF0000>假如二者 （指 Expires 和Max-Age） 均存在，那么 **Max-Age 优先级更高**</font>。
- **Domain=\<domain-value>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>指定 cookie 可以送达的主机名</font>。<font color=FF0000>假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）</font>。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。
- **Path=\<path-value>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部</font>。字符  %x2F ("/") 可以解释为文件目录分隔符，此目录的下级目录也满足匹配的条件（例如，如果 path=/docs，那么 "/docs", "/docs/Web/" 或者 "/docs/Web/HTTP" 都满足匹配的条件）。
- **Secure：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>一个带有安全属性的 cookie 只有在请求使用SSL和HTTPS协议的时候才会被发送到服务器</font>。然而，<mark style=background-color:hotpink>保密或敏感信息永远不要在 HTTP cookie 中存储或传输，因为整个机制从本质上来说都是不安全的</mark>，比如前述协议并不意味着所有的信息都是经过加密的。
  注意：非安全站点（http:）已经不能再在 cookie 中设置 secure 指令了（在Chrome 52+ and Firefox 52+ 中新引入的限制）。

- **HttpOnly：**<mark style=background-color:hotpink>可选</mark>，设置了 <font color=FF0000>HttpOnly 属性的 cookie 不能使用 JavaScript 经由  Document.cookie 属性、XMLHttpRequest 和  Request APIs 进行访问，以防范跨站脚本攻击</font>。
- **SameSite=Strict / Lax：** <mark style=background-color:hotpink>可选</mark>，🧪 <font color=FF0000>允许服务器设定一则 cookie **不随着跨域请求一起发送**</font>，这样可以在一定程度上防范跨站请求伪造攻击（CSRF）。

摘自：[MDN - Set-Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)

#### Cookie

Cookie <font color=FF0000>是一个请求首部</font>，<font color=FF0000>**其中含有先前由服务器通过 Set-Cookie  首部投放并存储到客户端的 HTTP cookies**</font>。
这个首部<font color=FF0000>可能会被完全移除</font>，<mark>例如在浏览器的隐私设置里面设置为禁用cookie</mark>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 请求头 |
| 禁用首部名称 | 是     |

**语法**

```http
Cookie: <cookie-list>
Cookie: name=value
Cookie: name=value; name2=value2; name3=value3
```

**\<cookie-list>：**一系列的名称/值对，形式为 \<cookie-name>=\<cookie-value>。<font color=FF0000>名称/值对之间用分号和空格 ('; ')隔开</font>。

**示例**

```http
Cookie: PHPSESSID=298zf09hf012fh2; csrftoken=u32t4o3tb3gg43; _gat=1;
```

摘自：[MDN - Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie)



#### X-Frame-Options

The X-Frame-Options HTTP <font color=FF0000>响应头</font>是<font color=FF0000>用来给浏览器 指示允许一个页面 **可否在 \<frame>, \<iframe>, \<embed> 或者 \<object> 中展现的标记**</font>。<mark style=background-color:hotpink>站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免 Click Jacking 攻击</mark>。

仅当访问文档的用户使用支持 X-Frame-Options 的浏览器时才提供附加的安全性。<mark> Content-Security-Policy HTTP 头中的 frame-ancestors 指令会替代这个非标准的 header。CSP 的 frame-ancestors 会在 Gecko 4.0 中支持，但是并不会被所有浏览器支持。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用</mark>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**
**X-Frame-Options 有三个可能的值：**

- **deny：**<font color=FF0000>表示该页面不允许在 frame 中展示</font>，<mark style=background-color:hotpink>即便是在相同域名的页面中嵌套也不允许</mark>。

  如果设置为 deny，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载

- **sameorigin：**<font color=FF0000>表示该页面可以在相同域名页面的 frame 中展示</font>。

  如果设置为sameorigin，那么页面就可以在同域名页面的 frame 中嵌套

- **allow-from uri：**<font color=FF0000>表示该页面可以在指定来源的 frame 中展示</font>。

<font size=4>**注意：**</font><font color=FF0000> **在 meta 标签中设置 X-Frame-Options 是无效的！**</font>例如 \<meta http-equiv="X-Frame-Options" content="deny"> 没有任何效果。不要这样用！只有在服务器中配置http才有效。

**不同的服务器配置**详见 原文

摘自：[MDN - X-Frame-Options](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options)



#### X-XSS-Protection

HTTP X-XSS-Protection 响应头<font color=FF0000> 是 Internet Explorer，Chrome 和 Safari 的一个特性</font>，<font color=FF0000> **当检测到跨站脚本攻击 （XSS）时，浏览器将停止加载页面** </font>。<mark>若网站设置了良好的 Content-Security-Policy 来禁用内联 JavaScript ('unsafe-inline')，现代浏览器不太需要这些保护</mark>， 但其仍然可以为尚不支持 CSP 的旧版浏览器的用户提供保护。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法：**

- **X-XSS-Protection: 0**

  设置为 **0**：<font color=FF0000> 禁止XSS过滤</font>。

- **X-XSS-Protection: 1**

  设置为 **1**：<font color=FF0000> 启用XSS过滤</font>（通常<font color=FF0000> 浏览器是默认的</font>）。 <font color=FF0000> 如果检测到跨站脚本攻击，浏览器将**清除页面**</font>（删除不安全的部分）。

- **X-XSS-Protection: 1; mode=block**

  设置为 **1;mode=block**： <font color=FF0000> 启用XSS过滤</font>。 如果<font color=FF0000> 检测到攻击，浏览器将**不会清除页面**，**而是阻止页面加载**</font>。

- **X-XSS-Protection: 1; report=\<reporting-uri>** 只适用于 chromium

  设置为 **report=\<reporting-uri>**：<font color=FF0000> 启用XSS过滤</font>。 如果<font color=FF0000> 检测到跨站脚本攻击，浏览器将**清除页面**并使用CSP report-uri 指令的功能发送违规报告</font>。

摘自：[MDN - X-XSS-Protection](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-XSS-Protection)



#### 一些细节

**x-requested-with 请求头 区分ajax请求还是普通请求**





#### Content-Disposition

在常规的 HTTP 应答中，<font color=FF0000>Content-Disposition 响应头指示回复的内容该以何种形式展示</font>，<font color=FF0000>是以**内联的形式**（即网页或者页面的一部分），还是以**附件的形式**下载并保存到本地</font>。

<mark style=background-color:hotpink>在 multipart/form-data 类型的应答消息体中，Content-Disposition 消息头可以被用在 multipart 消息体的子部分中，用来给出其对应字段的相关信息</mark>。各个子部分由在Content-Type 中定义的分隔符分隔。用在消息体自身则无实际意义。

Content-Disposition 消息头最初是在 MIME 标准中定义的，HTTP 表单及 POST 请求只用到了其所有参数的一个子集。只有 form-data 以及可选的 name 和 filename 三个参数可以应用在HTTP场景中。

| 属性         | 值                                                           |
| ------------ | ------------------------------------------------------------ |
| 报文类型     | 请求头：for the main body<br> 通用头：for a subpart of a multipart body |
| 禁用首部名称 | 否                                                           |

**语法**

- **作为消息主体中的消息头**

  在 HTTP 场景中，第一个参数或者是 inline（默认值，表示回复中的消息体会以页面的一部分或者整个页面的形式展示），或者是 attachment（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将 filename 的值预填为下载后的文件名，假如它存在的话）。

  ```http
  Content-Disposition: inline
  Content-Disposition: attachment
  Content-Disposition: attachment; filename="filename.jpg"
  ```

- **作为multipart body中的消息头**

  在 HTTP 场景中。第一个参数总是固定不变的 form-data；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号('=')连接，参数值用双引号括起来。参数之间用分号(';')分隔。

  ```http
  Content-Disposition: form-data
  Content-Disposition: form-data; name="fieldName"
  Content-Disposition: form-data; name="fieldName"; filename="filename.jpg"
  ```

**指令**

- **name：**<font color=FF0000>后面是一个表单字段名的字符串</font>，每一个字段名会对应一个子部分。在同一个字段名对应多个文件的情况下（例如，带有 multiple 属性的 \<input type=file> 元素），则多个子部分共用同一个字段名。如果 name 参数的值为 '\_charset\_' ，意味着这个子部分表示的不是一个 HTML 字段，而是在未明确指定字符集信息的情况下各部分使用的默认字符集。
- **filename：**后面是要传送的文件的初始名称的字符串。这个参数总是可选的，而且不能盲目使用：路径信息必须舍掉，同时要进行一定的转换以符合服务器文件系统规则。这个参数主要用来提供展示性信息。当与 Content-Disposition: attachment 一同使用的时候，它被用作"保存为"对话框中呈现给用户的默认文件名。
- filename\*："filename" 和 "filename\*" 两个参数的唯一区别在于，"filename\*" 采用了  RFC 5987 中规定的编码方式。当 "filename" 和 "filename\*" 同时出现的时候，应该优先采用 "filename\*"，假如二者都支持的话。



#### http/1.1 首部字段一览

- **通用首部字段：**

  | 首部字段名        | 说明                       |
  | ----------------- | -------------------------- |
  | Cache-Control     | 控制缓存的行为             |
  | Connection        | 逐跳首部、连接的管理       |
  | Date              | 创建报文的日期时间         |
  | Pragma            | 报文指令                   |
  | Trailer           | 报文末端的首部一览         |
  | Transfer-Encoding | 指定报文主体的传输编码方式 |
  | Upgrade           | 升级为其他协议             |
  | Via               | 代理服务器的相关信息       |
  | Warning           | 错误通知                   |

- **请求首部字段：**

  | 首部字段名          | 说明                                          |
  | ------------------- | --------------------------------------------- |
  | Accept              | 用户代理可处理的媒体类型                      |
  | Accept-Charset      | 优先的字符集                                  |
  | Accept-Encoding     | 优先的内容编码                                |
  | Accept-Language     | 优先的语言（自然语言）                        |
  | Authorization Web   | 认证信息                                      |
  | Expect              | 期待服务器的特定行为                          |
  | From                | 用户的电子邮箱地址                            |
  | Host                | 请求资源所在服务器                            |
  | If-Match            | 比较实体标记（ETag）                          |
  | If-Modified-Since   | 比较资源的更新时间                            |
  | If-None-Match       | 比较实体标记（与 If-Match 相反）              |
  | If-Range            | 资源未更新时发送实体 Byte 的范围请求          |
  | If-Unmodified-Since | 比较资源的更新时间（与If-Modified-Since相反） |
  | Max-Forwards        | 最大传输逐跳数                                |
  | Proxy-Authorization | 代理服务器要求客户端的认证信息                |
  | Range               | 实体的字节范围请求                            |
  | Referer             | 对请求中 URI 的原始获取方                     |
  | TE                  | 传输编码的优先级                              |
  | User-Agent          | HTTP 客户端程序的信息                         |

-  **响应首部字段**

  | 首部字段名         | 说明                         |
  | ------------------ | ---------------------------- |
  | Accept-Ranges      | 是否接受字节范围请求         |
  | Age                | 推算资源创建经过时间         |
  | ETag               | 资源的匹配信息               |
  | Location           | 令客户端重定向至指定URI      |
  | Proxy-Authenticate | 代理服务器对客户端的认证信息 |
  | Retry-After        | 对再次发起请求的时机要求     |
  | Server             | HTTP服务器的安装信息         |
  | Vary               | 代理服务器缓存的管理信息     |
  | WWW-Authenticate   | 服务器对客户端的认证信息     |

- **实体首部字段**

  | 首部字段名       | 说明                         |
  | ---------------- | ---------------------------- |
  | Allow            | 资源可支持的HTTP方法         |
  | Content-Encoding | 实体主体适用的编码方式       |
  | Content-Language | 实体主体的自然语言           |
  | Content-Length   | 实体主体的大小（单位：字节） |
  | Content-Location | 替代对应资源的URI            |
  | Content-MD5      | 实体主体的报文摘要           |
  | Content-Range    | 实体主体的位置范围           |
  | Content-Type     | 实体主体的媒体类型           |
  | Expires          | 实体主体过期的日期时间       |
  | Last-Modified    | 资源的最后修改日期时间       |

摘自：《图解HTTP》 P82

 

#### Data URLs

Data URLs，即<font color=FF0000>前缀为 data: 协议的URL</font>，其<font color=FF0000>允许内容创建者向文档中嵌入小文件</font>。

**语法：**

```http
data:[<mediatype>][;base64],<data>
```

<font color=FF0000>Data URLs **由四个部分组成**</font>：

- 前缀(data:)
- <font color=FF0000>指示数据类型的MIME类型</font>
- <font color=FF0000>如果非文本则为可选的base64标记</font>
- <font color=FF0000>**数据本身**</font>

mediatype 是个 MIME 类型的字符串，例如 "image/jpeg" 表示 JPEG 图像文件。<font color=FF0000>如果被省略，则默认值为 text/plain;charset=US-ASCII</font>

<font color=FF0000>如果数据是文本类型，你可以直接将文本嵌入</font> (根据文档类型，使用合适的实体字符或转义字符)。<font color=FF0000>如果是二进制数据，你可以将数据进行base64编码之后再进行嵌入</font>。

**一些示例：**

- ```http
  data:,Hello%2C%20World!
  ```

  简单的 text/plain 类型数据

- ```http
  data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D
  ```

  上一条示例的 base64 编码版本

- ```http
  data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E
  ```

  一个HTML文档源代码 \<h1>Hello, World\</h1>

- ```http
  data:text/html,<script>alert('hi');</script>
  ```

  一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。

摘自：[MDN - Data URLs](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs)



#### SPDY

SPDY（发音如英语：speedy），<font color=FF0000> 一种开放的网路传输协定</font>，<mark>由Google开发</mark>，<font color=FF0000> 用来传送网页内容</font>。<font color=FF0000> **基于传输控制协议（TCP）的应用层协议** </font>。<font color=FF0000> SPDY也就是HTTP/2的前身</font>。Google最早是在Chromium中提出的SPDY协议。被用于Google Chrome浏览器中来访问Google的SSL加密服务。SPDY并不是首字母缩略字，而仅仅是"speedy"的缩写。SPDY现为Google的商标。<font color=FF0000> HTTP/2的关键功能主要来自SPDY技术，换言之，SPDY的成果被采纳而最终演变为HTTP/2</font>。

<mark>SPDY并不是一个标准协议，但SPDY的开发组推动SPDY成为正式标准，而成为了互联网草案</mark>。后来SPDY未能单独成为正式标准，不过SPDY开发组的成员全程参与了HTTP/2的制定过程。Google Chrome、Mozilla Firefox、Safari、Opera、Internet Explorer等主要浏览器均已经或曾经支持SPDY协议。<font color=FF0000> SPDY协议类似于HTTP，但旨在缩短网页的加载时间和提高安全性。SPDY协议<font size=4>**通过压缩、多路复用和优先级来缩短加载时间**</font></font>。HTTP/2协议完成之后，Google认为SPDY可以功成身退了，于是最终Google Chrome淘汰对SPDY的支援，全面改为采用HTTP/2。

<font size=4>**设计**</font>
<font color=FF0000> 设计SPDY的**目的在于降低网页的加载时间**。通过**优先级**和**多路复用**，SPDY使得<font size=4>**只需要建立一个TCP连接**</font>即可传送网页内容及图片等资源</font>。<font color=FF0000> SPDY中**广泛应用了TLS加密**</font>，<font color=FF0000> **传输内容也均以gzip或DEFLATE格式压缩** </font>（与HTTP不同，<font color=FF0000> **HTTP的头部并不会被压缩** </font>）。另外，除了像HTTP的网页服务器被动的等待浏览器发起请求外，<font color=FF0000> SPDY的网页服务器 **还可以主动推送内容**</font>。

<font size=4>**与HTTP的关系**</font>
SPDY并不用于取代HTTP，它<font color=FF0000> 只是修改了HTTP的请求与应答在网络上传输的方式</font>；这意味着<font color=FF0000> 只需增加一个SPDY传输层，现有的所有服务端应用均不用做任何修改</font>。

当使用SPDY的方式传输，HTTP请求会被处理、标记简化和压缩。比如，每一个SPDY端点会持续跟踪每一个在之前的请求中已经发送的HTTP报文头部，从而避免重复发送还未改变的头部。而还未发送的报文的数据部分将在被压缩后被发送。

**Chrome 移除 SPDY**
2015年9月，Google 宣布了计划，移除对SPDY的支持，改支援HTTP/2。此更动在Chrome 51中生效。

摘自：[wiki - SPDY](https://zh.wikipedia.org/wiki/SPDY)



#### HTTP/2

http/2 主要基于SPDY协定。HTTP/2标准于2015年5月以RFC 7540正式发表



#### WebSocket协议相关：





## （网络）安全相关

#### 攻击方法

- XSS（跨站脚本攻击）
- CSRF（跨站请求伪造）
- Session Fixation Attack（会话固定攻击）
- Click Jacking（点击劫持攻击）
- Timing Attack（时序攻击）
- Challenge Collapsar Attack（CC攻击）
- Man-in-the-middle attack（MITM， 中间人攻击）
- Side Channel Attack（SCA，边信道攻击）
- Cross-Site Tracing（XST，跨站式追踪攻击）
- SQL Injection（SQL 注入攻击）
- OS Command Injection（OS 命令注入攻击）
- HTTP Header Injection（HTTP 首部注入攻击）
- Mail Header Injection （邮件首部注入攻击）
- Directory Traversal（目录遍历攻击）<font color=FF0000 size=4>**/**</font> Path Traversal（路径遍历攻击）

- 缓冲区溢出攻击



#### **对于 web 应用的攻击模式有两种：**

- **主动攻击：**具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击
- **被动攻击：**具有代表性的攻击是跨站脚本攻击 (XSS) 和跨站点请求伪造 (CSRF)；除此之外，还有 HTTP 首部注入攻击



#### Content Security Policy

<mark>跨域脚本攻击 XSS 是最常见、危害最大的网页安全漏洞</mark>。<mark>为了防止它们，要采取很多编程措施，非常麻烦</mark>。<font color=FF0000> 很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？这就是"网页安全政策"</font>（<font color=FF0000> Content Security Policy</font>，缩写 <font color=FF0000> CSP</font>）的来历。本文详细介绍如何使用 CSP 防止 XSS 攻击。

<font size=4>**简介**</font>

<font color=FF0000> CSP 的实质就是**白名单制度**，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单</font>。<font color=FF0000> **它的实现和执行全部由浏览器完成，开发者只需提供配置**</font>。<mark>CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机</mark>。

**两种方法可以启用 CSP：**

- 一种是<font color=FF0000> 通过 HTTP 头信息的Content-Security-Policy的字段</font>（首选）。

  ```http
  Content-Security-Policy: script-src 'self'; object-src 'none';
  style-src cdn.example.org third-party.org; child-src https:
  ```

- 另一种是<font color=FF0000> 通过网页的 \<meta> 标签</font>。

  ```html
  <meta http-equiv="Content-Security-Policy" 
        content="script-src 'self'; 
                 object-src 'none'; 
                 style-src cdn.example.org third-party.org; 
                 child-src https:">
  ```
  
  **上面代码中，CSP 做了如下配置：**
  
   - **脚本（script-src）：**只信任当前域名（self）
   - **\<object>标签（object-src）：**不信任任何URL，即不加载任何资源（none）
   - **样式表（style-src）：**只信任cdn.example.org和third-party.org
   - **框架（frame）(child-src)：**必须使用HTTPS协议加载
   - **其他资源：**没有限制
  
  启用后，不符合 CSP 的外部资源就会被阻止加载。

<font size=4>**限制选项**</font>

CSP 提供了很多限制选项，涉及安全的各个方面。

**资源加载限制**

以下选项限制各类资源的加载。

- **script-src：**外部脚本
- **style-src：**样式表
- **img-src：**图像
- **media-src：**媒体文件（音频和视频）
- **font-src：**字体文件
- **object-src：**插件（比如 Flash）
- **child-src：**框架
- **frame-ancestors：**嵌入的外部资源（比如 \<frame>、\<iframe>、\<embed> 和 \<applet>）
- **connect-src：**HTTP 连接（通过 XHR、WebSockets、EventSource等）
- **worker-src：**worker脚本
- **manifest-src：**manifest 文件

**default-src**

default-src：<font color=FF0000> 用来设置上面各个选项的默认值</font>。

```http
Content-Security-Policy: default-src 'self'
```

上面代码<font color=FF0000> 限制所有的外部资源，都只能从当前域名加载</font>。

如果<font color=FF0000> 同时设置某个单项限制（比如font-src）和 default-src，前者会覆盖后者</font>，即字体文件会采用font-src的值，其他资源依然采用default-src的值。

**URL 限制**

有时，网页会跟其他 URL 发生联系，这时也可以加以限制。

- **frame-ancestors：**限制嵌入框架的网页
- **base-uri：**限制<base#href>
- **form-action：**限制<form#action>

**其他限制**

其他一些安全相关的功能，也放在了 CSP 里面。

- **block-all-mixed-content：**HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）
- **upgrade-insecure-requests：**自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议
- **plugin-types：**限制可以使用的插件格式
- **sandbox：**浏览器行为的限制，比如不能有弹出窗口等。

**report-uri**

有时，我们<mark>不仅希望防止 XSS</mark>，<font color=FF0000> 还希望记录此类行为</font>。<font color=FF0000> **report-uri** 就用来告诉浏览器，应该把注入行为报告给哪个网址</font>。

```http
Content-Security-Policy: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;
```

上面代码指定，将注入行为报告给/my_amazing_csp_report_parser这个 URL。

浏览器会使用POST方法，发送一个JSON对象，下面是一个例子。

```json
{
  "csp-report": {
    "document-uri": "http://example.org/page.html",
    "referrer": "http://evil.example.com/",
    "blocked-uri": "http://evil.example.com/evil.js",
    "violated-directive": "script-src 'self' https://apis.google.com",
    "original-policy": "script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser"
  }
}
```

<font size=4>**Content-Security-Policy-Report-Only**</font>

<mark>除了Content-Security-Policy</mark>，<font color=FF0000> 还有一个Content-Security-Policy-Report-Only字段</font>，表示不执行限制选项，只是记录违反限制的行为。

它必须与report-uri选项配合使用。

```http
Content-Security-Policy-Report-Only: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;
```

<font size=4>**选项值**</font>

每个限制选项可以设置以下几种值，这些值就构成了白名单。

- **主机名：**example.org，https://example.com:443
- **路径名：**example.org/resources/js/
- **通配符：**\*.example.org，\*://\*.example.com:\*（表示任意协议、任意子域名、任意端口）
- **协议名：**https:、data:
- **关键字'self'：**当前域名，需要加引号
- **关键字'none'：**禁止加载任何外部资源，需要加引号

**多个值也可以并列，用空格分隔。**

```http
Content-Security-Policy: script-src 'self' https://apis.google.com
```

如果同一个限制选项使用多次，只有第一次会生效。

```
// 错误的写法
script-src https://host1.com; script-src https://host2.com

// 正确的写法
script-src https://host1.com https://host2.com
```

如果不设置某个限制选项，就是默认允许任何值。

<font size=4>**script-src 的特殊值**</font>

<font color=FF0000> 除了常规值，script-src还可以设置一些特殊值</font>。注意，<font color=FF0000> 下面这些值都必须放在 **单引号** 里面</font>。

- **'unsafe-inline'：**允许执行页面内嵌的&lt;script>标签和事件监听函数

- **'unsafe-eval'：**允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。

- **'nonce值'：**每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行

  nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。

  ```http
  Content-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'
  ```

  页面内嵌脚本，必须有这个token才能执行。

  ```html
  <script nonce=EDNnf03nceIOfn39fn3e9h3sdfa>
    // some code
  </script>
  ```

- **'hash值'：**列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。

  hash值的例子如下，服务器给出一个允许执行的代码的hash值。

  ```http
  Content-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='
  ```

  下面的代码就会允许执行，因为hash值相符。

  ```html
  <script>alert('Hello, world.');</script>
  ```

  注意，计算hash值的时候，\<script>标签不算在内。

除了script-src选项，nonce值 和 hash值还可以用在style-src选项，控制页面内嵌的样式表。

<font size=4>**注意点**</font>

- <font color=FF0000> **script-src 和 object-src是必设的，除非设置了default-src**</font>。<mark>因为攻击者只要能注入脚本，其他限制都可以规避</mark>。而<mark>object-src必设是因为 Flash 里面可以执行外部脚本</mark>。

- script-src 不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data:URL。

   下面是两个恶意攻击的例子：

  ```html
  <img src="x" onerror="evil()">
  <script src="data:text/javascript,evil()"></script>
  ```

- 必须特别注意 JSONP 的回调函数。

  ```html
  <script src="/path/jsonp?callback=alert(document.domain)//"></script>
  ```

  上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。

摘自：[阮一峰 - Content Security Policy 入门教程](http://www.ruanyifeng.com/blog/2016/09/csp.html)

<font size=4>**补充**</font>

**CSP分类：**

- Content-Security-Policy：配置好并启用后，不符合 CSP 的外部资源就会被阻止加载。
- Content-Security-Policy-Report-Only：表示不执行限制选项，只是记录违反限制的行为。它必须与report-uri选项配合使用。

**CSP的使用：**

- 在HTTP Header上使用<font color=FF0000> （首选）</font>

- 在HTML上使用

**Meta 标签与 HTTP 头只是行式不同而作用是一致的，<font color=FF0000> 如果 HTTP 头与 Meta 定义同时存在，则优先采用 HTTP 中的定义。</font>**
如果用户浏览器已经为当前文档执行了一个 CSP 的策略，则会跳过 Meta 的定义。如果 META 标签缺少 content 属性也同样会跳过。

摘自：[前端安全配置之Content-Security-Policy(csp)](https://blog.csdn.net/wulex/article/details/105405837)



#### 彩虹表

彩虹表是一个<font color=FF0000> 用于加密散列函数逆运算的**预先计算好的表**</font>，常<font color=FF0000> 用于破解加密过的密码散列</font>。 彩虹表常常用于破解长度固定且包含的字符范围固定的密码（如信用卡、数字等）。这<font color=FF0000> 是以空间换时间的典型实践</font>，比暴力破解（Brute-force attack）使用的时间更少，空间更多；但与储存密码空间中的每一个密码及其对应的哈希值（Hash）实现的查找表相比，其花费的时间更多，空间更少。<font color=FF0000> 使用加盐的密钥派生函数可以使这种攻击难以实现</font>。

摘自：[wiki - 彩虹表](https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%99%B9%E8%A1%A8)
