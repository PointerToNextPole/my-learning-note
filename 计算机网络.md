# 计算机网络



#### **网关**

随便打开一本HTTP的书，都会提到网关的概念。通常意识中，网关一词更多的是硬件层面的概念，但其实与CGI的网关二字之含义也是不谋而合的。称CGI为软件网关也不为过。

网关，<mark>更形象的叫法是“**协议翻译机**”</mark>。<mark>通常与网关输入输出两端通信使用的是不同的协议。即一方是HTTP协议，另一方可能是其他协议</mark>，比如企业内部的自定义协议。

摘自：[万法归宗——CGI](https://zhuanlan.zhihu.com/p/25013398)


#### 会话层

会话层，位于OSI模型的第5层，主要<font color=FF0000> 为两个会话层实体进行**会话**（Session），而进行的对话连接的管理服务</font>。

<font color=FF0000> 会话层为用户端的应用程序提供了开启、关闭和管理会话的机制，亦即半永久的对话</font>。会话的实体包含了对其他程式作会话连结的要求及回应其他程式提出的会话连结要求。在应用程序的执行环境中，会话层是这些程序用来提出远程过程调用（remote procedure calls，RPC）的地方。

会话层标准为了使会话连接建立阶段能进行功能协商，也为了便于其它国际标准参考和引用，定义了12种功能单元。各个系统可根据自身情况和需要，以核心功能服务单元为基础，选配其他功能单元组成合理的会话服务子集。

摘自：[wiki - 会话层](https://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%B1%82)



#### 表示层

表示层 (Presentation) 亦称表达层，<font color=FF0000> 为不同终端的上层用户提供数据和信息正确的语法表示变换方法</font>。<mark>如文本文件的 ASCII格式 和 UTF-8格式</mark>。

**表示层的主要功能**

- 数据语法转换
- 语法表示
- 连接管理
- 数据处理
  - 数据加密和解密
  - 数据压缩和解压
  - 数据编码和解码

摘自：[wiki - 表示层](https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%A4%BA%E5%B1%82)



## HTTP

> ### 《编程必备基础 大话HTTP协议》 笔记

http之所以被称为超文本传输协议，是因为他可以通过 超链接 跳转到其他网页（HTML）



##### 伯纳斯·李发明了：

- URI
- HTTP（被称为 HTTP/0.9 ）
- HTML



三次握手的作用：确认 B / S 双方的接收和发送的能力



电脑（客户端）会对一些频繁使用的网址 和它所对应的IP地址，做一个映射关系放到host文件中。在访问该网址时，会优先使用host文件中的IP地址（省去了DNS解析的过程）



本地可以配置DNS服务器



http开始时是无连接的协议，即：限制每次连接（TCP连接）只处理一个请求

http 也是无状态的，所以需要 Session 和 Cookie 来完善。



##### URI、URL、URN的区别

<img src="https://i.loli.net/2021/10/10/AFr1kOjNwKhTYPE.png" alt="image-20211010111346719" style="zoom:33%;" />

- URI：一个紧凑的字符串用来标识抽象或物理资源。一个 URI 可以进一步被分为定位符、名字或者两者都是

  > URI 可以分为URL、URN 或 <font color=FF0000> 同时具备locators和names特性的一个东西</font>
  >
  > URN 作用就好像一个人的名字 (<font color=FF0000> names</font>)，URL就像一个人的地址 (<font color=FF0000>locators</font>)
  >
  > 换句话说：URN确定了东西的身份，URL提供了找到它的方式
  >
  > 摘自：维基百科

  - URL （Uniform Resource Locator) 是URI的子集，除了确定一个资源，还提供一种定位该资源的主要访问机制（如其网络“位置”）

    - URL是 URI的一种，不是所有的URI 都是 URL

    - URI 和 URL最大的差别是“访问机制”

  - URN (Uniform Resource Name) 是唯一标识的一部分，是身份信息

  

##### HTTP报文头

HTTP报文头可以分为四类：

- <font color=FF0000>**通用**</font>报文头
- 请求报文头
- 响应报文头
- <font color=FF0000> **实体**</font>报文头

HTTP/1.1中一共规范了47中报文头字段，详见后面的：http/1.1 首部字段一览



##### ACCEPT

作用：浏览器端可以接受的媒体类型。
 **Accept: text/html**：代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档，如果服务器无法返回text/html类型的数据服务应该返回一个406错误 (Non Acceptable)

**Accept:\*/\***：代表浏览器可以处理所有类型

Accept / Accept-Language 如果想要给显示的媒体类型增加优先级,则使用q=来额外表示权重值)；权重值q 的范围是0～1 (可精确到小数点后3位) ，且1为最大值。不指定权重q值时，默认权重为q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。



**Referer**

当浏览器向web服务器发送请求的时候，一般会带上Referer，<font color=FF0000> **告诉服务器我是从哪个页面链接过来的**，服务器籍此可以获得一些信息用于处理</font>



**User-Agent**

作用：告诉HTTP服务器，客户端使用的<font color=FF0000> 操作系统</font>和浏览器的名称和版本

<mark>很多情况下我们会通过User-Agnet 来判断浏览器类型，从而进行不同的兼容设计</mark>



##### GET和POST的区别

- GET传输的数据是放在URL 中的（?foo=bar），POST传输的数据作为HTTP的请求体
- GET请求有大小限制，根据不同浏览器实现不同而不同；而POST请求没有大小限制



##### HTTP状态码种类

| 分类 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 1XX  | 表示消息。这一类型的状态码,代表请求已被接受,需要继续处理。这类响应是临时响应,只包含状态行和某些可选的响应头信息,并以空行结束。 |
| 2XX  | 表示成功。这一类型的状态码,代表请求已成功被服务器接收、理解、并接受。 |
| 3XX  | 表示重定向。这类状态码代表需要客户端采取进一步的操作才能完成请求。通常,这些状态码用来重定向,后续的请求地址(重定向目标)在本次响应的Location域中指明。 |
| 4XX  | 表示请求错误。这类的状态码代表了客户端看起来可能发生了错误,妨碍了服务器的处理。除非响应的是一个HEAD请求,否则服务器就应该返回一个解释当前错误状况的实体,以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。 |
| 5XX  | 表示服务器错误。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生,也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求,否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。 |

##### 常用状态码

| 状态码 | 状态码英文名称        | 描述                                                         |
| ------ | --------------------- | ------------------------------------------------------------ |
| 200    | OK                    | 请求已成功,请求所希望的响应头或数据体将随此响应返回          |
| 202    | Accepted              | 已接受,已经接受请求,但未处理完成                             |
| 206    | Partial Content       | 部分内容,服务器成功处理了部分GET请求                         |
| 301    | Moved Permanently     | 永久移动,请求的资源已被永久的移动到新URI,返回信息会包括新的URI，浏览器会自动定向到新URI,今后任何新的请求都应使用新的URI代替 |
| 302    | Found                 | 临时移动，与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 400    | Bad Request           | 客户端请求的语法错误,服务器无法理解                          |
| 401    | Unauthorized          | 请求要求用户的身份认证                                       |
| 403    | Forbidden             | 服务器理解请求客户端的请求，是拒绝执行此请求                 |
| 404    | Not Found             | 服务器无法根据客户端的请求找到资源（网页）                   |
| 500    | Internal Server Error | 服务器内部错误,无法完成请求                                  |
| 502    | Bad Gateway           | 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求   |



##### Cookie 和 Session

- Cookie实际上是一小段的文本信息。客户端请求服务器,如果服务器需要记录该用户状态,就向客户端浏览器颁发一个Cookie。

  客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时,浏览器把请求的网址连同该Cookie-同提交给服务器。服务器检查该Cookie,以此来辨认用户状态

  <img src="https://i.loli.net/2021/10/12/IednPrwAG6YMN8j.png" alt="image-20211012001151317" style="zoom:33%;" />

- Session是另一种记录客户状态的机制,保存在服务器上。客户端浏览器访问服务器的时候,服务器把客户端信息以某种形式记录在服务器上

  客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了

  <img src="https://i.loli.net/2021/10/12/APO7htHesMZSngc.png" alt="image-20211012000949789" style="zoom: 33%;" />fu z

  **浏览器用户可以清除Cookie，其他保存Session ID的方式：**

  - Cookie（已知）
  - URL重写，附加在URL后面
  - 隐藏表单

  **Session 的有效期：**

  - Session超时失效
  - 程序调用HttpSession.invalidate()
  - 服务器异常中止

  **Cookie 与 Session 不同点：**

  - 存放位置不同，Cookie放在UA，Session放在服务器
  - 安全性（隐私策略）不同，Cookie安全性没有Session安全性高
  - 有效期不同，Cookie可以（看服务器设置）在UA中保存很久；而服务器会定时清理超时的Session ID，避免出现过大的压力
  - 对服务器压力不同，Cookie存在UA中，对服务器没有压力



##### 常见编码规范

- ASCII码
- GBK
- ISO-8859-1：不包含中文
- Unicode



##### URL的编码和解码

“%编码”规范

对URL中属于ASCI字符集的非保留字不做编码;对URL中的保留字需要取其ASCI内码，然后加上"%"前缀将该字符进行编码；对于URL中的非ASCI字符需要取其Unicode内码，然后加上"%"前缀将该字符进行编码。



##### 常见的认证方式

- **BASIC认证（基本认证）：**不加密（明文），不安全。
- **DIGEST认证（摘要认证）：**加密，发送nonce：一个随机的字符串。
- **SSL客户端认证：**SSL客户端认证是借由HTTPS的客户端证书完成认证的方式。<font color=FF0000> 凭借客户端证书认证（比如网银，除了输入用户名和密码，还要下载他们的证书）</font>，服务器可确认访问是否来自已登录的客户端。
- **FormBase认证（基于表单的认证）：**基于表单的认证方法并不是在HTTP协议中定义的。<mark>使用由Web应用程序各自实现基于表单的认证方式</mark>。通过Cookie和Session的方式来保持用户的状态。



**HTTP的长连接和短连接**

HTTP协议是基于 请求/响应 模式的，因此只要服务端给了响应，本次HTTP请求就结束了。

HTTP的长连接和短连接<font color=FF0000 size=4> **本质上是TCP长连接和短连接**</font>。

HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接,结束就中断。

HTTP/1.1起，默认使用长连接，用以保持连接特性。

**短连接：**建立连接一数据传输一关闭连接..建立连接一数据传输一关闭连接

**长连接：**建立连接-数据传输..(保持连接) .数据传输-关闭连接



**代理的作用**

- 抓包
- 翻墙
- 匿名访问
- 过滤器：避免用户访问一些不被允许的内容，比如“儿童模式”



**网关**

网关可以作为某种翻译器使用，它抽象出了一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂。网关扮演的是“协议转换器"的角色。

示例如下：

<img src="https://i.loli.net/2021/10/12/jLOSshqo6gtHzdl.png" alt="image-20211012140353072" style="zoom: 33%;" />

Web网关在一侧使用HTTP协议,在另一侧使用另一种协议。<客户端协议>/<服务器端协议>

(HTTP/)服务器端A:通过HTTP协议与客户端对话，通过其他协议与服务器通信。

(/HTTP)客户端网关:通过其他协议与客户端对话，通过HTTP协议与服务器通信。

**常见的网关类型**

- (HTTP/*) 服务器端Web 网关
- (HTTP/HTTPS) 服务器端安全网关
- (HTTPS/HTTP) 服务器安全加速器网关
- 资源网关



**HTTP缓存**

可使用头

- **Cache-Control：**请求响应头，缓存控制字段。可选值如下：
  
  - no-store：所有内容都不缓存。
  
  - no-cache：缓存，但是浏览器使用缓存前，都会请求服务器判断缓存资源是否是最新。
  
    **注：**这里顺带提一下 Pragma 通用首部
  
    > Pragma 是一个在 HTTP/1.0 中规定的通用首部，这个首部的效果依赖于不同的实现，所以在“请求-响应”链中可能会有不同的效果。它<font color=FF0000>用来 **向后兼容** 只支持 HTTP/1.0 协议的缓存服务器</font>，<font color=FF0000>**那时候 HTTP/1.1 协议中的 Cache-Control 还没有出来**</font>。
    >
    > **语法：**
    >
    > ```http
    > Pragma: no-cache
    > ```
    >
    > <font color=FF0000>与 Cache-Control: no-cache 效果一致</font>。<font color=FF0000>强制要求缓存服务器在返回缓存的版本之前将请求提交到源头服务器进行验证</font>。
    >
    > 摘自：[MDN - Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma)
  
  - max-age=x（单位秒）：请求缓存后的x秒不再发起请求（ http1.1 属性）
  - s-maxage=x（单位秒）：<font color=FF0000> 代理服务器请求源站缓存后的x秒不再发起请求，只对代理服务器缓存有效</font>。
  - public：客户端和代理服务器 ( CDN ) 都可缓存
  - private：只有客户端可以缓存，即：代理服务器将无法缓存。
  
- **Expires：**响应头，代表资源过期时间，由服务器返回提供，是http1.0 的属性在与max-age共存的情况下，优先级要低。

- **Last-Modified：**<mark style="background:fuchsia">响应头</mark>，资源最新修改时间，由服务器告诉浏览器。

- **if-Modified-Since：**<mark style="background:aqua">请求头</mark>，资源最新修改时间，由浏览器告诉服务器，<mark>和Last-Modified是一对**（请求头和相应头）**，它俩会进行对比</mark>。

- **Etag：**<mark style="background:fuchsia">响应头</mark>，资源标识，由服务器告诉浏览器。

- **if-None-Match：**<mark style="background:aqua">请求头</mark>，缓存资源标识，由浏览器告诉服务器（其实就是上次服务器给的Etag），<mark>和Etag是一对**（请求头和相应头）**，它俩会进行对比</mark>。

**头的使用场景**

- **场景一：**让服务器与浏览器约定一个文件过期时间，则使用 Expires

- **场景二：**让服务器与浏览器在约定文件过期时间的基础上，再加一个文件最新修改时间的对比 -- Last-Modified 与 if-Modified-Since。如果文件过期了（expires时间到了），浏览器会发送 if-Modified-Since（即上次服务器返回的 Last-Modified），服务器会将请求头中的最新修改时间和服务器上的最新修改时间，做一下对比。如果不等，则服务器会重新发送文件、Expires、Last-Modified；如果相等，则会返回状态码 304 (Not Modified)

  - **解决的问题：**如果Expires时间到了，可以服务器的文件依旧没有改，这时可以通过这两个来避免服务器再次传输，而继续使用缓存

- **场景三：**让服务器与浏览器在过期时间Expires + Last-Modified 的基础上，<font color=FF0000> 增加一个文件内容唯一对比标记</font> -- Etag与 lf-None-Match。Expires不稳定，再加入一个max-age来加以代替

  - **解决的问题：**由于 Last-Modified 使用秒来判定是否改变，在高并发的情况下，如果Last-Modified 相等，<font color=FF0000> 并不能保证文件没有被修改过</font>；所以需要 ETag

    

**浏览器无法<font color=FF0000>主动</font>感知服务器文件变化**

解决方案：

- **md5 / hash 缓存：**通过不缓存html，为静态文件添加MD5或者hash标识，解决浏览器无法跳过缓存过期时间主动感知文件变化的问题。
- **CDN 缓存：**CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器,通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。



**浏览器操作对HTTP缓存的影响**

| 用户操作                  | Expires / Cache-Control         | Last-Modified / Tag             |
| ------------------------- | ------------------------------- | ------------------------------- |
| 地址栏回车                | 有效                            | 有效                            |
| 页面链接跳转              | 有效                            | 有效                            |
| 新开窗口                  | 有效                            | 有效                            |
| 前进、后退                | 有效                            | 有效                            |
| F5刷新                    | <font color=FF0000> 无效</font> | 有效                            |
| Ctrl + F5刷新（强制请求） | <font color=FF0000> 无效</font> | <font color=FF0000> 无效</font> |

其中<font color=FF0000> “无效”</font>表示，忽略掉这些http头，强行进行请求。



**内容协商机制**

内容协商机制：指客户端和服务器端就响应的**资源内容**进行交涉，然后**提供给客户端最为适合的资源**。内容协商以响应资源的语言、字符集、编码方式等作为判断的基准。

**内容协商方式**

- **客户端驱动：**客户端发起请求，<font color=FF0000> 服务器发送可选项列表</font>，<font color=FF0000> 客户端作出选择后在发送第二次请求</font>。
  - 优点：容易实现，尊重用户的意愿
  - 缺点：增加时延，要发送两次请求
- <mark style="background:aqua">**服务器驱动：**</mark>服务器检查客户端的请求<font color=FF0000> 头部集</font>并决定提供哪个版本的页面。<font color=FF0000> **使用最为广泛**</font>
  - 优点：快速
  - 缺点：在头部集都不匹配的时候，服务器需要进行猜测
- **透明协商：**某个中间设备（通常是缓存代理）代表客户端进行协商。
  - http没有提供规范，但这可能是<font color=FF0000> 未来的趋势</font>



**<mark style="background:aqua">服务器驱动</mark>内容协商 - 请求首部集**

- **Accept：**告知服务器发送何种媒体类型；对应的<mark>响应头</mark>是 Content-Type
- **Accept-Language：**告知服务器发送何种语言；对应的<mark响应头是 Content-Language
- **Accept-Charset：**告知服务器发送何种字符集；对应的响应头是 Content-Type（注意，这里有两个Content-Type）
- **Accept-Encoding：**告知服务器采用何种编码；对应的响应头是 Content-Encoding



**服务器驱动内容协商 - 近似匹配（使用权重q）**

```http
Accept-Language: en;q=0.5, fr;q=0.0, nl;q=1.0, tr;q=0.0
```



**断点续传和多线程下载**

断点续传和多线程下载：HTTP是通过在Header里两个参数实现的，<font color=FF0000> **客户端发请求** </font>时对应的是 <font color=FF0000> **Range**</font>，<font color=0000FF> **服务器端响应**</font>时对应的是 <font color=0000FF> **Content-Range**</font>。

- **Range**
  用于请求头中，指定一个字节的和最后一字节的位置（<font color=FF0000> 名义上是左开右闭，但是http为了下载更加完善，选择了两边都是闭区间</font>），一般格式：

  ```http
  Range:(unit=first byte pos)-[last byte pos]
  ```

  示例：

  ```http
  Range: bytes=0-499
  Range: bytes=500-999
  Range: bytes=-500
  Range: bytes=500-
  Range: bytes=500-600,601-999
  ```

- **Content-Range**
  用于响应头中,在发出带Range 请求后，服务器会在Content-Range头部返回当前接受的范围和文件总大小。**一般格式：**

  ```http
  Content-Range: bytes (unit first byte pos)- [last byte pos]/[entity length]
  ```

  而在响应完成后，返回的响应头内容也不同：

  - HTTP/1.1 200 Ok （不使用断点续传方式）
  - HTTP/1.1 206 Partial Content （使用断点续传方式）

**多线程下载的原理**是<font color=FF0000> **主动的分片**</font>（<font color=FF0000> **断点续传是被动的分片**</font>），比如第一个线程的 Range 是0-1024，第二个Range是 1025-2048；以此类推。



**HTTPS协议概述**

- HTTPS可以被认为是 HTTP + TLS

- TLS 是传输层加密协议，<font color=FF0000> 前身是SSL协议</font>（TLS 和 SSL协议建立在TCP 和 HTTP协议之间）

  TLS实际上是TCP之上建立了一个加密通道

  **TLS协议有五个部分：**

  - 应用数据层协议
  - 握手协议
  - 报警协议
  - 加密消息确认协议
  - 心跳协议

  TLS 协议版本：TLS1.0、TLS1.1、TLS1.2、SSL3.0

  - SSL3.0 由于 poodle攻击，导致不稳定
  - TLS1.0 也存在部分安全漏洞，如RC4、BEAST攻击方式
  - TLS1.1 TLS1.2 暂时没有发现什么漏洞
  - TLS1.3 也已推出



**HTTPS功能介绍**

HTTPS主要解决了中间人攻击，防止网站被劫持。

- **内容加密**

  - 非对称密钥交换
  - 对称内容加密

- **身份认证**

  - 数字证书

  CA厂商和浏览器厂商 / OS厂商是有合作的

  - firefox 自己维护了一个可信任的 CA列表
  - Chrome / IE 使用的是OS的可信任的 CA列表

- **数据完整性**



**HTTPS使用成本**

- 证书费用以及更新维护
- HTTPS 会降低用户访问速度
- 消耗CPU资源，需要增加大量机器



**HTTPS对性能的影响**

- 协议交互所增加的网络 RTT（Round-trip-delay）

  https 连接过程：

  <img src="https://i.loli.net/2021/10/13/mfeiAw96gRWUNbl.png" alt="image-20211013105919282" style="zoom: 33%;" />

  **OCSP：**Online Certificate Status Protocol（在线证书状态协议）

- **计算耗时**
  - 浏览器计算耗时
  - 服务端计算耗时



**HTTP协议的瓶颈**

- **一个TCP连接上只能发送一个HTTP请求** 

  浏览器对<font color=FF0000> 同域名请求</font>的最大并发数也有限制，不同浏览器不一样，Chrome是6个（具体可以参考：https://cloud.tencent.com/developer/article/1683127）

- 请求只能从客户端开始。客户端不可以接受除响应以外的指令

- 请求/ 响应头部不经过压缩就发送

- 每次互相发送相同的头部造成的浪费较多

- 非强制压缩发送



**轮询**

- **Ajax轮询：**浏览器 <font color=FF0000> 定时</font>询问服务器
- **Long poll（长轮询）**：使用的阻塞模型，客户端发送消息之后，<font color=FF0000> 等待</font>服务器返回消息，服务器有消息了，才会返回给客户端

这两个询问方式都是 非常消耗资源的，同时也是有可能出现异常情况的，比如服务器会报 503。

**补充：**这两种轮询方式的缺点

- ajax轮询 需要服务器有很快的处理速度和资源。（速度）
- long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）

这时候就需要WebSocket



**WebSocket**

WS之所以被称为“基于HTTP”，只是为了兼容HTTP；HTTP 和 WS 是两个不同的协议。同时，WS借用HTTP来完成一部分握手。

WS是一个<font color=FF0000> 持 久化</font>的协议

**websocket的握手**

**客户端的请求报文**

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw=
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example. com
```

- **Upgrade: websocket Connection: Upgrade** 告知服务器切换协议
- **Sec-WebSocket-Key：**是一个Base64字符串，是浏览器随机生成的；用于验证服务器是否是真的Websocket助理
- **Sec_WebSocket-Protocol：**是一个用户定义的字符串，用来<font color=FF0000> 区分同一个URL</font>下，<font color=FF0000> 不同的服务所需要的协议</font>
- **Sec-WebSocket-Version：**是<font color=FF0000> 告诉服务器所使用的Websocket Draft（协议版本）</font>。在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦

**服务器的响应报文**

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

- **Upgrade: websocket Connection: Upgrade** 这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~并且，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。

- **Sec-WebSocket-Accept：**这个则是<font color=FF0000>经过服务器确认，并且加密过后的 Sec-WebSocket-Key</font>。服务器：好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。

  <font color=FF0000>**补充：**</font>摘自：[WebSocket协议：5分钟从入门到精通 - 极乐君的文章 - 知乎](https://zhuanlan.zhihu.com/p/32739737)

  Sec-WebSocket-Accept 是根据客户端请求首部的 Sec-WebSocket-Key 计算出来，计算公式为：

  1. 将Sec-WebSocket-Key跟258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。
  2. 通过SHA1计算出摘要，并转成base64字符串。

- **Sec-WebSocket-Protocol：**则是表示最终使用的协议

<font color=FF0000>至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了</font>。

**上面说的：Ajax轮询和long poll轮询的缺点，那么WS是如何解决的呢？**

其实<font color=FF0000>我们所用的程序是要**经过两层代理**的，即**HTTP协议在Nginx等服务器的解析下**，然后再传送给相应的**Handler（PHP等）**来处理</font>。
<mark>简单地说，我们有一个非常快速的接**线员（Nginx）**，他负责把问题转交给相应的**客服（Handler）**</mark>。
本身**接线员基本上速度是足够的**，但是每次都卡在**客服（Handler）**了，老有**客服**处理速度太慢。，导致客服不够。
Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持**久连接**，有信息的时候客服想办法通知接线员，然后**接线员**在统一转交给客户。
这样就可以解决客服处理速度过慢的问题了。

同时，在传统的方式（HTTP）上，要不断的建立，关闭HTTP协议，<font color=FF0000>由于HTTP是非状态性的，每次都要 **重新传输identity info（鉴别信息）**，来告诉服务端你是谁</font>。
虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的**处理时间**，而且还会在网路传输中消耗**过多的流量/时间。**
<font color=FF0000>但是Websocket只需要**一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中**，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息</font>。
<font color=FF0000>同时由**客户主动询问**，转换为**服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。）**，没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的**客服（Handler）**了</font>

以上关于WS的内容摘自：[WebSocket 是什么原理？为什么可以实现持久连接？ - Ovear的回答 - 知乎](https://www.zhihu.com/question/20215561/answer/40316953)

WS只需要一次HTTP握手，整个通讯过程是建立在一次连接状态中；避免了http的非状态性，服务端会一直知道客户端的状态，知道客户端关闭。

<img src="https://i.loli.net/2021/10/13/Lq8AtdZisN4hfCQ.png" alt="image-20211013161045991" style="zoom:33%;" />

**WS的特点：**

- 真正的全双工方式
- 减少通信量（不需要再发送 http header）
- 多路复用

<font size=4>**更多补充：**</font>

WebSocket 是<font color=FF0000>**HTML5开始提供**</font>的一种浏览器与服务器进行全双工通讯的网络技术。

**优点：**

说到优点，这里的对比参照物是HTTP协议，概括地说就是：支持双向通信，更灵活，更高效，可扩展性更好。

- 支持双向通信，实时性更强。
- 更好的二进制支持。
- 较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部。
- 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）

**数据帧格式**

客户端、服务端数据的交换，离不开数据帧格式的定义。因此，在实际讲解数据交换之前，我们先来看下WebSocket的数据帧格式。

WebSocket客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。

- 发送端：将消息切割成多个帧，并发送给服务端；
- 接收端：接收消息帧，并将关联的帧重新组装成完整的消息；

**下面给出了WebSocket数据帧的统一格式**。熟悉TCP/IP协议的同学对这样的图应该不陌生。

1. 从左到右，单位是比特。比如 `FIN`、`RSV1 `各占据1比特，`opcode `占据4比特。
2. 内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开）

```java
 0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
```

// TODO

摘自：[WebSocket协议：5分钟从入门到精通 - 极乐君的文章 - 知乎](https://zhuanlan.zhihu.com/p/32739737)



**SPDY**

SPDY 结构

<img src="https://i.loli.net/2021/10/13/iwEHRJYBCDAP3tG.png" alt="image-20211013161807183" style="zoom: 33%;" />

SPDY修复了HTTP的缺陷，**HTTP的缺陷如下：**

- **单路连接 请求低效：**一个 TCP 连接只能对应一个 HTTP请求
- HTTP 只允许由客户端主动发起请求
- **HTTP 头部冗余：**重复发送HTTP Header

**于是SPDY 的改进：**

- **多路复用 请求优化**
  - 在一个 TCP连接上，可以有多个（无限个）并发的 HTTP请求，共用一个TCP 会话。
  - 同时避免反复创建新连接，造成的延时，将TCP 的效率发挥到最高
  - 另外，可以对多路复用设置优先级，可以让关键的资源优先被传输、处理
- **支持服务器推送技术：**
  - 服务器可以主动向客户端传输数据
- SPDY 压缩了 HTTP头
- 强制使用了 SSL传输协议



**HTTP2.0**

HTTP2.0 结构

<img src="https://i.loli.net/2021/10/13/ewHrRB5Xlb74W8x.png" alt="image-20211013163856744" style="zoom: 45%;" />

**HTTP2.0 性能增强的核心：<font color=FF0000> 二进制分帧</font>**

二进制分帧即：下图中的 Binary Framing

![150826074396731](https://i.loli.net/2021/10/13/7bHdhiMVUCqgI6B.jpg)

在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码 ，其中<font color=FF0000> **HTTP1.x 的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面**</font>。

然后，<font color=FF0000> HTTP 2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流</font>。 相应地，<font color=FF0000> 每个数据流以消息的形式发送，而消息由一或多个帧组成，**这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装**</font>。

**首部表**

HTTP2.0在客户端和服务端使用了<font color=FF0000> **首部表**</font>，来<font color=FF0000> 跟踪和存储之前发送的键值对</font>，对于相同的数据，不再通过每次请求的响应发送。通信期间，几乎不会改变通用的键值对，只需要发送一次

<img src="https://i.loli.net/2021/10/13/pP3jdThnIoHNvte.png" alt="image-20211013165658554" style="zoom: 33%;" />

**HTTP2.0 多路复用**

<img src="https://i.loli.net/2021/10/13/XCsenvkHfhGMr6A.png" alt="image-20211013172052922" style="zoom: 33%;" />

**单连接多资源的优势：**

- 可以<font color=FF0000> 减少服务链接压力</font>，内存占用少了，连接吞吐量大了
- 由于TCP连接减少而使<font color=FF0000> 网络拥塞状况得以改观</font>
- 慢启动时间减少，<font color=FF0000> 拥塞和丢包恢复速度更快</font>

**HTTP2.0 并行双向字节流的请求和响应（乱序发送数据）**

注：这就是 全双工的？

![150826074396732](https://i.loli.net/2021/10/13/YXhpuxcQ75aI9Tv.jpg)

在HTTP2.0上，客户端和服务器可以把HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。注意，同一链接上有多个不同方向的数据流在传输。客户端可以一边乱序发送stream，也可以一边接收者服务器的响应，而服务器那端同理。

把 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP/2.0 最 重要的一项增强。这个机制会在整个 Web 技术栈中引发一系列连锁反应，从而带来巨大的性能提升，因为：

- 可以并行交错地发送请求，请求之间互不影响;
- 可以并行交错地发送响应，响应之间互不干扰;
- 只使用一个连接即可并行发送多个请求和响应;
- 消除不必要的延迟，从而减少页面加载的时间;

由于乱序发送，是否会因为数据是相关的（有先后顺序的），而造成应该先发送到的数据迟迟无法送到？这时就有了 HTTP/2.0 的 <font color=FF0000> “请求优先级”</font> 的概念：

- 高优先级的流都应该优先发送

- 优先级不是绝对的

- 不同优先级混合也是必须的



**webDAV追加方法**

| 方法      | 用途           |
| --------- | -------------- |
| PROPFIND  | 获取属性       |
| PROPPATCH | 修改属性       |
| MKCOL     | 创建集合       |
| COPY      | 复制资源及属性 |
| MOVE      | 移动资源       |
| LOCK      | 资源加锁       |
| UNLOCK    | 资源解锁       |

**webDAV新增状态码**

| 状态码                  | 含义                                             |
| ----------------------- | ------------------------------------------------ |
| 102 Processing          | 可正常处理请求，但目前是处理中状态               |
| 207 Multi-Status        | 存在多种状态                                     |
| 422 UnprocessibleEntity | 格式正确,内容有误                                |
| 423 Locked              | 资源已被加锁                                     |
| 424 FailedDependency    | 处理与某请求关联的请求失败，因此不再维持依赖关系 |
| 507 InsufficientStorage | 保存空间不足                                     |

 

**QUIC & HTTP3.0**

HTTP2.0 / SPDY / QUIC 对比图

<img src="https://i.loli.net/2021/10/14/Pmu6O7DqH3yjpUB.png" alt="image-20211014095020442" style="zoom: 40%;" />

**HTTP2.0的问题**

- **队头阻塞：**由底层制成的TCP 协议造成的，使用多路复用，一旦连接中出现了丢包的情况，会导致HTTP2.0 的表现不如 HTTP1.x ，因为在丢包的情况下，整个TCP 都需要等待重传，后面的所有数据都被阻塞住了。而对于HTTP1.x 而言，是开启多个 TCP 连接的，出现丢包，只会影响其中一个连接，仍可以正常传输数据
- **建立连接的握手延迟大：**
  - http1.x、https 和 http2.0 都使用了TCP 进行传输
  - https 和 http2.0 还需要通过TLS协议进行安全传输（TLS完全握手 需要至少两个RTT 才能建立；即使简化握手，也需要一个RTT）
  - TCP 三次握手还有延迟

**QUIC 的特性**

- 0 RTT 建立连接
- 没有队头阻塞的多路复用（更适合移动端）
- 前向纠错：每个数据包除了本身的数据之外，还包含了部分其他包的内容，少量的丢包，可以通过其他包的冗余数据，直接组装，而无需重传（相较冗余数据，数据重传代价更大）



**WASC 将 Web应用安全威胁分为六大类**

1. **Authentication (验证)：**用来确认某用户、服务或是应用身份的攻击手段

2. **Authorization (授权)：**用来决定是否某用户、服务或是应用具有执行请求动作必要权限的攻击手段
3. **Client-Side Attacks (客户侧攻击)：**用来扰乱或是探测Web 站点用户的攻击手段
4. **Command Execution (命令执行)：**在Web站点上执行远程命令的攻击手段
5. **Information Disclosure (信息暴露)：**用来获取Web站点具体系统信息的攻击手段
6. **Logical Attacks (逻辑性攻击)：**用来扰乱或是探测Web应用逻辑流程的攻击手段



**OWASP最重要的项目是：web应用的十大安全隐患**

- **A1:2017-注入：**将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生注入SQL注入、NoSQL注入、OS注入和LDAP注入缺陷。
-  **A2:2017-失效：**通过错误使用应用程序的身份认证和会话管理，攻击者能够破译密码、密钥或会话令牌。
- **A3:2017-敏感：**许多Web程序和API都无法正确护敏数据，攻击者可能通过 窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃等犯罪行为
- **A4:2017-XML外部实体(XXE) ：**许多较早的或配置错误的XML处理器评估的XML文件中的外部实体引用。攻击者可利用外部实体窃取内部文件、执行远程代码
- **A5:2017-失效的访问控制：**未对通过身份验证的用户实施恰当的访问控制。
- **A6:2017-安全配置错误：**安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云错误等造成。
- **A7:2017-跨站脚本(XSS) ：**XSS让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。
- **A8:2017-不完全的反序列化：**不安全的反序列化会导致远程代码执行。
- **A9:2017-使用含有已知漏洞的组件：**组件如库、框架和其他软件模块拥有和应用程序相同的权限
- **A10:2017-不足的日志记录和监控：**不足的日志记录和监控，以及相应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性、篡改、提取或销毁数据



**验证机制**

- 验证机制是web应用程序中最简单的一种<font color=FF0000> 安全机制</font>

  - 一般来说,应用程序<font color=FF0000> 必须核实</font>用户提交的用户名和密码是否正确。正确则允许登录，否则禁止登录

- 验证机制是应用程序防御恶意攻击的<font color=FF0000> 核心机制</font>

  - 它处在<font color=FF0000> 安全防御</font>的最前沿，如果被用户轻易突破，通常应用程序的全部功能、数据都会被其控制。

  - <font color=FF0000> 缺乏安全有效的验证机制</font>，其他核心安全机制都无法实施（会话管理和访问控制）

**典型的身份验证模式讨论**

<img src="https://i.loli.net/2021/10/14/S7qCpuAoZKrWDcy.png" alt="image-20211014140949126" style="zoom: 33%;" />

**验证技术**

- 基于HTML 表单的验证
- 多元机制，如组合型密码
- 客户端 SSL 证书

**双因子认证**
双因子认证的核心是综合 what you know（个人密码）和 what you have（手机）来达到双重认证效果。目前很多电商、银行都采用了该认证方式。



**会话管理漏洞的防御**

- **令牌传输安全**
  - <font color=FF0000> 令牌只能通过HTTPS传送</font>。
  - 如果使用HTTP cookie传送令牌（大多数情况下），<font color=FF0000> 应将这些cookie标记为secure</font>，以防止用户浏览器通过HTTP传送它们。
- 增加软硬会话过期
  - **软会话过期：**它指的是<font color=FF0000> 用户在一定的时间内与应用系统没有交互，则会话过期</font>，也就是我们常说的<font color=FF0000> Session失效</font>。
  - **硬会话过期：**它指的是用户登录到系统中经过一定的时间后,不管用户做什么,该会话都会过期。
- 提供完善的注销功能
  - 用户可以手动地使当前会话过期，这就是我们在几乎所有网站上都看到的 logout按钮。
  - TIPS：要保证注销不存在会话终止漏洞。



**SQL注入威胁**

**SQL注入危害：**

- 探知数据库的具体结构，为进一步攻击做准备
- 泄露数据，尤其是机密信息、账户信息等
- 取得更高权限，来修改表数据甚至是内部结构

**防治手段：**

<font color=FF0000> 参数化查询</font>是对 SQL注入根本性的<font color=FF0000> 防御策略</font>，也叫做预处理语句，在建立一个包含用户输入的SQL语句时分为两步：

1. 指定查询结构,用户输入预留占位符
2. 指定占位符的内容



**XSS攻击原理**

- 跨站脚本攻击 (Cross Site Scripting)，XSS 是一种经常出现在web应用中的计算机安全漏洞。
- 它允许恶意web用户将代码植入到提供给其它用户使用的页面中，其他用户在观看网页时，恶意脚本就会执行（比如垃圾邮件）。

这类攻击通常通过注入HTML 或 js 等脚本发动攻击。

攻击成功后，攻击者可以得到私密网页内容和cookie等。

最近几年XSS攻击已经成为最流行的攻击方式。

**XSS攻击危害**

- 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号
- 控制数据,包括读取、篡改、添加、删除企业敏感数据的能力
- 盗窃企业重要的具有商业价值的资料
- 非法转账
- 强制发送网站挂马
- 控制受害者机器向其它网站发起攻击

**XSS 分类**

针对XSS的攻击方式不同，我们可以把XSS分为如下三大类
- **反射式XSS**

  - 也称为非永久性XSS，是目前最流行的XSS攻击。
  - 它出现在服务器直接使用客户端提交的数据，如url的数据、html表单中提交数据等，并且没有对数据进行无害化处理。
  - 如果提交的数据中含有HTML控制字符而没有被正确处理，那么一个简单的XSS攻击就会发生。
  - 典型的反射式攻击可通过一个邮件或中间网站，诱饵是一个看起来可信任的站点的链接，其中包含XSS攻击脚本。
  - 如果信任的网站没有正确处理这个脚本，用户点击后就会导致浏览器执行含有恶意攻击的脚本。

- **存储式XSS**

  - 也成为永久性XSS，危害更大。
  - 攻击将攻击脚本上传到Web服务器上,使得所有访问该页面的用户都面临信息泄漏的可能,其中也包括了Web服务器的管理员。
  - 存储式XSS多发生在最终显示给其他用户的位置包含：
    - 个人信息字段，如姓名、地址、电子邮件、电话等
    - 文档、上传文件及其他数据的名称
    - 提交给管理员的反馈或问题
    - 向其他应用程序用户传送的消息、注释、问题等
    - 在用户之间共享的上传文件内容
  - 典型的存储式XSS攻击过程
    - 有一个Web站点，该站点允许用户发布信息/浏览已发布的信息。
    - 攻击者注意到这个站点具有存储式的XSS漏洞。
    - 于是攻击者发布一个热点信息，利用该漏洞获取用户信息，吸引其它用户纷纷阅读。
    - 任何其他人浏览该信息，其会话cookies或者其它信息将被攻击者盗走。

- **基于DOM的XSS**

  - 反射式 XSS攻击和存储式 XSS攻击都是通过服务器端提取用户提交的数据。
  - 并且以不安全的方式将其返回给用户。
  - 基于 DOM的攻击仅仅通过 JavaScript 的方式执行。

  也就是说这种攻击常发生在应用程序每次返回相同的静态html，而通过客户端JavaScript动态生成信息，并不会跟服务端交互获取的时候。

**XSS的攻击载荷**（最有可能被攻击的地方，即弱点）

- **会话令牌**
  XSS攻击最普遍的方式。截取一名受害者的会话令牌,劫持他的会话,进而作为受害者的身份来使用应用程序,执行任意操作并占有该用户的账户。

- **虚拟置换**
  这种攻击需要在一个Web应用程序页面注入恶意数据，从而向应用程序的用户传送误导性信息。
  包括简单的向站点注入html，或者使用脚本注入精心设计的内容。
  攻击者实际上没有修改保存在服务器上的内容，而是利用程序处理并显示用户提交的输入方面的缺陷实现置换。

- **注入木马**
  这种攻击造成的后果远比虚拟置换严重，它在易受攻击的应用程序中注入实际运行的功能，旨在欺骗终端用户执行某种有害操作（如输入敏感数据）。随后将它们传送给攻击者。

  在一个明显的攻击中，攻击者注入的功能向用户显示一个木马登录表单，要求他们向攻击者控制的服务器提交他们自己的证书。
  如果由技巧熟练的攻击者实施，这种攻击还允许用户无缝登录到真正的应用程序中，以便他们不会发觉访问过程中的任何反常情况。然后，攻击者就可以自由使用受害者的证书实现自己的目的。

  这种类型的有效载荷非常适宜于用在钓鱼攻击中,向用户传送一个经过专门设计、连接可信应用程序的URL,并要求他们正常登录以访问这个URL。

**XSS 防御措施**

1. **输入验证**
   如果应用程序在某个位置收到的用户提交的数据将来有可能被复制到它的响应中，应用程序应根据这种情形对
   这些数据执行尽可能严格的确认。
   需要确认的数据的潜在特性包括以下几点：

   - 数据不是太长
   - 数据仅包含某组合法字符
   - 数据与一个特殊的正规表达式相匹配
   - 根据应用程序希望在每个字段中收到的数据类型，应尽可能限制性地对姓名、电子邮件地址、账号等应用不同的确认规则

2. **输出编码**

   - 如果应用程序将某位用户或第三方提交的数据复制到它的响应中,那么应用程序应对这些数据进行HTML编码,以净化可能的恶意字符。

   - HTML编码 指用对应的HTML实体替代字面量字符。这样做可确保浏览器安全处理可能为恶意的字符，把它们当作HTML文档的内容而非结构处理。比如说：

     ```
     " -> &quot;
     ' -> &#x27;
     < -> &lt;
     > -> &gt;
     / -> x2F;
     ```

应用程序之所以结合使用输入确认与输出净化，原因在于这种方法能够提供两层防御：如果其中一层被攻破，另一层还能提供一些保护。

许多执行输入与输出确认的过滤都容易被攻破。

结合这两种技巧,应用程序就能够获得额外的保护,即使攻击者发现其中一种过滤存在缺陷,另一种过滤仍然能够阻止他实施攻击。

在这两种防御中,输出确认最为重要,必不可少。实施严格的输入确认应被视为一种次要故障恢复。



**CSRF攻击原理**

CSRF (Cross-site Request Forgery)，**跨站请求伪造**，也被 称为"one click attack"或者“session riding”，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。
尽管听起来像跨站脚本 (XSS) ，但它与XSS 非常不同，并且击方式几乎相左。

XSS 利用站点内的信任用户（受害者） ，而CSRF通过伪装来自受信任用户的请求来利用受信任的网站。
通过社会工程学的手段（如通过电子邮件发送一个链接）来蛊惑受害者进行一些敏感性的操作，如修改密码、修改E-mail、转账等，而受害者还不知道他已经中。

CSRF的破坏力依赖于受害者在信息系统中的权限（如果是管理员的话，危害相当大）。

**CSRF攻击过程深度剖析**

1. Web浏览器对于Cookie和HTTP身份验证信息之类的会话信息的处理方式：

   - 目前,浏览器会自动地发送标识用户对话的信息,而无须用户干预。
   - 换句话说,当浏览器发送这些身份信息的时候,用户根本感觉不到。

   **举例：**假设站点A上有一个Web应用程序，并且受害者正好已经在该站点上通过了身份认证，这时，相应消息中就会有Cookie来记录这个信息。这个Cookie 的作用：

   - 主要是被站点作为用户会话的标志，即如果站点收到了带有受害者的Cookie的请求，那么它就会把这个请求看作是已登录的受害者发来的。
   - 一般情况下,浏览器收到站点设置的Cookie之后，每当向该站点发送请求的时候，浏览器都会“自动地”连同该Cookie一起发出。

2. 应用程序赖以管理会话的信息对浏览器的透明性问题：

   - 为了提高Web 的便利性，来管理会话的信息，如Cookie或者基于HTTP的身份验证（如HTTP基本认证、非基于表单的认证）等敏感信息，都是由浏览器来存放的。并在每当向需要身份验证的应用程序发送请求时自动捎带上。
   - 也就是说，浏览器可以访问会话管理信息，如果Web应用程序完全依赖于这类信息来识别一个用户会话，就为跨站请求伪造创造了条件。

**CSRF攻击预防**

- 增加一些确认操作：确认是否继续

- 重新认证：

  - 在做一些重要敏感操作时候，要求用户<font color=FF0000> 重新输入密码</font>进行<font color=FF0000> 二次验证</font>，只有正确了才进行操作。

    这种做法显然更安全，但对于用户看起来不是特别友好 -- 毕竟是增加了一步操作。

- <font color=FF0000> **使用Token**</font>（终极解决方法）：

  - 在用户刚登录的时候，产生一个新的不可预知的CSRF Token，并且把此Token存放在用户的session中。
  - 在任何一个需要保护的表单中,增加一个隐藏的字段来存放这个Token。
  - 对于需要保护的URL，增加一个参数来存放此Token。
  - 提交此请求的时候，在服务器端检查提交的Token与用户session中的Token是否一致，如果一致，继续处理请求,否则返回一个错误信息给用户。
  - 在用户退出或者session过期的时候,用户信息(包括 CSRF Token)从session中移除并且销毁session.



> ### HTTP协议原理+实践 Web开发工程师必学



**Cookie是用来保持会话信息的**



**浏览器输入URL后HTTP请求返回的完整过程**

<img src="https://i.loli.net/2021/10/15/Cw2WjVgkNFYZA3z.png" alt="image-20211015101139725" style="zoom: 50%;" />

- **Redirect：**判断是否需要Redirect，以及要Redirect到哪里。比如301 Moved Parmently的情况

- **App Cache：**查看在App Cache中是否有请求资源的缓存，如果没有就要去服务器请求资源 



**TCP/IP五层结构**

- **物理层：**主要作用是定义物理设备如何传输数据

- **数据链路层：**在通信的实体间建立数据链路连接

- **网络层：**为数据在结点之间传输创建逻辑链路
- **传输层：**向用户提供可靠的端到端 (End-to- End) 服务（比如数据过大，需要分包分片），传输层向高层屏蔽了下层数据通信的细节
- **应用层：**为应用软件提供了很多服务，构建于TCP协议之上，屏蔽网络传输相关细节



**HTTP/0.9**

- 只有一个命令：GET

- 没有HEADER等描述数据的信息

- 服务器发送完毕，就关闭 TCP 连接

**HTTP/1.0**

- 增加了很多命令：POST、HEADER、...
- 增加status code 和 header
- 多字符集支持、多部分发送、权限、缓存等

**HTTP/1.1**

- 持久连接，（短连接有三次握手相当耗费性能，还带来延迟的缺点）
- 添加pipeline，
- 添加 host头部（可以在同一台服务器上运行多个项目，提高使用效率）和其他一些命令

**HTTP2**

- 所有数据都以二进制传输，所有的数据都是通过帧来传输
- 同一个连接里面发送多个请求不再需要按照顺序来（可以并行，即多路复用）
- 头信息压缩以及<font color=FF0000> 推送</font>（服务端主动发送资源）等提高效率的功能



**TCP **

三次握手时序图

<img src="https://i.loli.net/2021/10/15/E2IfhWYPc3iaJoB.png" alt="image-20211015111106127" style="zoom:33%;" />





**HTTP方法**是用来定义队资源的操作



**可以使用curl以发送和接收http请求**

- ```sh
  curl baidu.com
  ```

  返回：

  ```html
  <html>
  <meta http-equiv="refresh" content="0;url=http://www.baidu.com/">
  </html>
  ```

  这里是访问 baidu.com，会默认跳转到 www.baidu.com

- ```sh
  curl www.baidu.com
  ```

  返回：html格式的文本

  ```html
  <!DOCTYPE html>
  <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc> <div id=wrapper> <div id=head> <div class=head_wrapper> <div class=s_form> <div class=s_form_wrapper> <div id=lg> <img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129> </div> <form id=form name=f action=//www.baidu.com/s class=fm> <input type=hidden name=bdorz_come value=1> <input type=hidden name=ie value=utf-8> <input type=hidden name=f value=8> <input type=hidden name=rsv_bp value=1> <input type=hidden name=rsv_idx value=1> <input type=hidden name=tn value=baidu><span class="bg s_ipt_wr"><input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus></span><span class="bg s_btn_wr"><input type=submit id=su value=百度一下 class="bg s_btn"></span> </form> </div> </div> <div id=u1> <a href=http://news.baidu.com name=tj_trnews class=mnav>新闻</a> <a href=http://www.hao123.com name=tj_trhao123 class=mnav>hao123</a> <a href=http://map.baidu.com name=tj_trmap class=mnav>地图</a> <a href=http://v.baidu.com name=tj_trvideo class=mnav>视频</a> <a href=http://tieba.baidu.com name=tj_trtieba class=mnav>贴吧</a> <noscript> <a href=http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb>登录</a> </noscript> <script>document.write('<a href="http://www.baidu.com/bdorz/login.gif?login&tpl=mn&u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&")+ "bdorz_come=1")+ '" name="tj_login" class="lb">登录</a>');</script> <a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;">更多产品</a> </div> </div> </div> <div id=ftCon> <div id=ftConw> <p id=lh> <a href=http://home.baidu.com>关于百度</a> <a href=http://ir.baidu.com>About Baidu</a> </p> <p id=cp>&copy;2017&nbsp;Baidu&nbsp;<a href=http://www.baidu.com/duty/>使用百度前必读</a>&nbsp; <a href=http://jianyi.baidu.com/ class=cp-feedback>意见反馈</a>&nbsp;京ICP证030173号&nbsp; <img src=//www.baidu.com/img/gs.gif> </p> </div> </div> </div> </body> </html>
  ```

- ```sh
  curl -v www.baidu.com
  ```

  返回：除了html文本外，还包含http的相应和请求报文

  ```http
  *   Trying 180.101.49.12...
  * TCP_NODELAY set
  * Connected to www.baidu.com (180.101.49.12) port 80 (#0)
  > GET / HTTP/1.1
  > Host: www.baidu.com
  > User-Agent: curl/7.64.1
  > Accept: */*
  >
  < HTTP/1.1 200 OK
  < Accept-Ranges: bytes
  < Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
  < Connection: keep-alive
  < Content-Length: 2381
  < Content-Type: text/html
  < Date: Fri, 15 Oct 2021 05:38:50 GMT
  < Etag: "588604c8-94d"
  < Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT
  < Pragma: no-cache
  < Server: bfe/1.0.8.18
  < Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
  <
  <!DOCTYPE html>
  <!--STATUS OK--><html> <head><meta http-equiv=content-type content=text/html;charset=utf-8><meta http-equiv=X-UA-Compatible content=IE=Edge><meta content=always name=referrer><link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css><title>百度一下，你就知道</title></head> <body link=#0000cc> <div id=wrapper> <div id=head> <div class=head_wrapper> <div class=s_form> <div class=s_form_wrapper> <div id=lg> <img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129> </div> <form id=form name=f action=//www.baidu.com/s class=fm> <input type=hidden name=bdorz_come value=1> <input type=hidden name=ie value=utf-8> <input type=hidden name=f value=8> <input type=hidden name=rsv_bp value=1> <input type=hidden name=rsv_idx value=1> <input type=hidden name=tn value=baidu><span class="bg s_ipt_wr"><input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus></span><span class="bg s_btn_wr"><input type=submit id=su value=百度一下 class="bg s_btn"></span> </form> </div> </div> <div id=u1> <a href=http://news.baidu.com name=tj_trnews class=mnav>新闻</a> <a href=http://www.hao123.com name=tj_trhao123 class=mnav>hao123</a> <a href=http://map.baidu.com name=tj_trmap class=mnav>地图</a> <a href=http://v.baidu.com name=tj_trvideo class=mnav>视频</a> <a href=http://tieba.baidu.com name=tj_trtieba class=mnav>贴吧</a> <noscript> <a href=http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb>登录</a> </noscript> <script>document.write('<a href="http://www.baidu.com/bdorz/login.gif?login&tpl=mn&u='+ encodeURIComponent(window.location.href+ (window.location.search === "" ? "?" : "&")+ "bdorz_come=1")+ '" name="tj_login" class="lb">登录</a>');</script> <a href=//www.baidu.com/more/ name=tj_briicon class=bri style="display: block;">更多产品</a> </div> </div> </div> <div id=ftCon> <div id=ftConw> <p id=lh> <a href=http://home.baidu.com>关于百度</a> <a href=http://ir.baidu.com>About Baidu</a> </p> <p id=cp>&copy;2017&nbsp;Baidu&nbsp;<a href=http://www.baidu.com/duty/>使用百度前必读</a>&nbsp; <a href=http://jianyi.baidu.com/ class=cp-feedback>意见反馈</a>&nbsp;京ICP证030173号&nbsp; <img src=//www.baidu.com/img/gs.gif> </p> </div> </div> </div> </body> </html>
  * Connection #0 to host www.baidu.com left intact
  * Closing connection 0
  ```



**JSONP实现原理**

浏览器允许link、img、script等带src的标签，是允许其跨域的，不在乎服务器是否设置跨域的头（Access-Control-Allow-Origin 的设置）
详细使用 示例，参见：[[HTML & CSS备忘录#关于 JSONP 的补充]]


##### CORS相关

**跨域请求分为两种：**

- 简单请求
- 非简单请求

**一个 简单的请求 是指满足以下两个条件的请求：**

1. **简单的方法：**GET，POST 或 HEAD
2. **简单的 header**，仅允许自定义下列 header：
   - Accept，
   - Accept-Language，
   - Content-Language，
   - Content-Type 的值为 application/x-www-form-urlencoded，multipart/form-data 或 text/plain。

<font color=FF0000> **补充：**</font>还需要满足如下两点（不过用的很少）：

- XMLHttpRequestUpload对象均没有注册任何事件监听器；

  XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。

- 请求中没有使用 ReadableStream对象

任何其他请求都被认为是“非简单请求”。例如，具有 PUT 方法或 API-Key HTTP-header 的请求就不是简单请求。

<font color=FF0000> **当尝试发送一个非简单请求时，浏览器会发送一个特殊的“预检（preflight）”请求到服务器 —— 询问服务器，你接受此类跨源请求吗？**</font>并且，除非服务器明确通过 header 进行确认，否则非简单请求不会被发送。

**预检请求使用 <font color=FF0000>OPTIONS</font> 方法**

如果想要给简单请求做扩展（添加其他可以使用的Method、Header等），可以使用 Access-Control-Request-Method、Access-Control-Request-Headers、Access-Control-Max-Age（在设定的时间内，不需要再做预检请求了，直接通过）、Access-Control-Allow-Origin、Access-Control-Allow-Credentials 属性。

以上内容，同时也参考了 [JS 现代教程 - Fetch：跨域请求](https://zh.javascript.info/fetch-crossorigin#jian-dan-de-qing-qiu) 中的内容，原课程中的内容并不全面

另外，也可以参考：摘自：[MDN - 跨源资源共享 (CORS)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)



**Cache-Control**

特性：

- 可缓存性
  - public：http数据传输过程中经过的设备都可以缓存（包括代理服务器）
  - private：只有发起请求的浏览器才能缓存，<font color=FF0000> **代理服务器将无法缓存**</font>
  - no-store：任何一个节点都不能缓存
- 到期：
  - max-age=\<seconds>：缓存多少秒后失效
  - s-maxage=\<seconds>：只有在代理服务器中才会生效
  - max-stale=\<seconds>：即使缓存过期了，浏览器还可以使用该过期的缓存
- 重新验证：
  - must-revalidate：在设置了max-age中，如果该内容已经过期了，必须去原服务端发送请求，重新获取这份数据，再来验证这个内容是否真的过期了，而不能直接使用本地的缓存
  - proxy-revalidate：与must-revalidate 一样，不过，只能用在代理服务器上
- 其他：
  - no-cache：可以在本地进行缓存，本地也可以使用缓存，但是要等待服务器验证之后才能使用。就是要经过服务器端的验证。
  - no-transform：告诉代理服务器，不允许改动资源（比如格式转换、压缩）

<font color=FF0000> **注意：这些头都是限制性的、声明性质的，没有任何强制的约束力**</font>

由于Cache的存在，如果max-age 没有到期，将不会重新发送http请求，但是也有不好的地方，就是如果服务器资源改变了，浏览器资源无法第一时间更新，这时候就要用 文件名+文件hash作为文件名来防止资源改变



##### 数据协商

在客户端给服务端发送请求时，客户端会声明：这个请求，希望拿到的数据格式和数据相关的限制。服务端会根据该请求里面的内容，来决定返回什么样的数据。

**分类中包含请求和返回两部分：**

- **请求** Accept
  - Accept：想要的数据类型
  - Accept-Encoding：数据的编码方式，限制服务端端数据压缩
  - Accept-Language：语言
  - User-Agent：返回什么样的页面（比如PC端的页面，还是移动端的页面；或者要不要兼容该浏览器）
- **返回** Content
  - Content-Type：
  - Content-Encoding
  - Content-Language



##### **301 Moved Permanently**

服务器使用  301 Moved Permanently 需要谨慎，因为会涉及到http 缓存的问题。一旦使用了 301 Moved Permanently，这个资源改了回去，变成200 OK，如果用户一直不清缓存；那使用还是会调用 301 Moved Permanently 相关的缓存，而不是重新建立请求，获取服务器上的数据。



##### CSP

CSP 的作用：

- 限制资源获取
- 报告资源获取越权

属性：

- default-src 限制全局

- 指定资源类型
  - connect-src：请求发向的目标，进行限制
  - img-src：图片可以从那几个网址进行加载
  - manifest-src：
  - media-src
  - font-src
  - frame-src
  - script-src：脚本可以从那几个网址进行加载
  - style-src：样式可以从那几个网址进行加载



**Nginx**

Mac 下 homebrew 安装的 Nginx安装的路径：/usr/local/etc/nginx

基本代理的配置，示例如下：

```nginx
# nginx.conf 配置文件下：

server {
	listen 80;
	server_name foo.com
	
	location / {
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host # 可加可不加，这个只是在设置别名
	}
}
```

此时，http://127.0.0.1:8888 将会被 foo.com 代理，访问 foo.com 就是在访问 http://127.0.0.1:8888。另外，这里server 可以配置多个。

**Nginx代理缓存**

```nginx
# nginx.conf 配置文件下：

# cache 是nginx所在文件夹下的文件夹
# levels 表示是否要创建二级文件夹
# keys_zone设置缓存的名字，可以在server中配置不同的缓存；10m是放在内存中的缓存大小
proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m

server {
	listen 80;
	server_name foo.com;
	
	location / {
	  # 配置上面定义的缓存
		proxy_cache my_cache;
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host
	}
}
```

代理缓存是在代理那一层设置的，每一个新的请求都会经过代理；所以只要代理缓存已经缓存过一次了，在浏览器这边，只要第一个用户请求，其他的用户都可以直接从代理缓存拿到数据。



**HTTP & HTTPS**

HTTP是明文传输的，数据都是未加密的，不安全；而HTTPS是数据加密的

HTTPS握手过程：

<img src="https://i.loli.net/2021/10/18/AIGCoBna8hqyb6k.png" alt="image-20211018234514531" style="zoom:33%;" />



**在Nginx中配置HTTPS**

使用openssl生成公钥和私钥，并设置保存路径（可以放在nginx文件夹下）；之后配置 nginx.conf

```nginx
# nginx.conf 配置文件下：

proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m

server {
	# https默认端口443
	listen 443;
	server_name foo.com;
	
	# 开启ssl
	ssl on;
	# 指定对应的证书，如果生成的公钥私钥，放在nginx文件夹下的cert文件夹下
	ssl_certificate_key cert/bar-privkey.pem;
	ssl_certificaqte cert/bar.pem;
	
	location / {
		proxy_cache my_cache;
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host
	}
}
```

这时https配置就已经生效，如果还想要设置，在http协议下，自动转换成https协议：

```nginx
# nginx.conf 配置文件下：

proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m

# 配置将http自动转换为https
server {
	listen 80 default_server;
	listen [::]:80 default_server;
	server_name foo.com;
	return 302 https://$server_name$request_uri;
}

server {
	listen 443;
	server_name foo.com;
	
	ssl on;
	ssl_certificate_key cert/bar-privkey.pem;
	ssl_certificaqte cert/bar.pem;
	
	location / {
		proxy_cache my_cache;
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host
	}
}
```



**HTTP2.0**

优势：

- 信道复用：只需要一个TCP 连接
- 分帧传输：发送数据不需要连续的顺序
- Server Push



##### Nginx配置HTTP2

在Nginx服务器（作为代理服务器）上配置HTTP2 要比直接在自己的服务器上配置HTTP2 要简便很多，因为很多逻辑都需要修改。即：规避了开发中需要考虑的问题，直接从代理服务器层面解决（适配器模式）

```nginx
# nginx.conf 配置文件下：

proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m

server {
	listen 80 default_server;
	listen [::]:80 default_server;
	server_name foo.com;
	return 302 https://$server_name$request_uri;
}

server {
  # 添加http2
	listen 443 http2;
	server_name foo.com;
  # 当nginx检测到link响应首部时，会主动往客户端推送资源
  http2_push_preload on;
	
	ssl on;
	ssl_certificate_key cert/bar-privkey.pem;
	ssl_certificaqte cert/bar.pem;
	
	location / {
		proxy_cache my_cache;
		proxy_pass http://127.0.0.1:8888;
		proxy_set_header Host $host
	}
}
```



---

#### HTTP概述

HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。

**客户端：user-agent**
<font color=FF0000>user-agent 就是任何能够为用户发起行为的工具</font>。这个角色通常都是由浏览器来扮演。一些例外情况，比如是工程师使用的程序，以及Web开发人员调试应用程序（比如Postman）。

浏览器<font color=FF0000>**总是**</font>作为发起一个请求的实体，他永远不是服务器（虽然近几年已经出现一些机制能够模拟由服务器发起的请求消息了）。

**Web服务端**
在上述通信过程的另一端，是由Web Server来服务并提供客户端所请求的文档。<font color=FF0000>**Server只是虚拟意义上代表一个机器**</font>：它<mark>可以是共享负载（负载均衡）的一组服务器组成的计算机集群，也可以是一种复杂的软件</mark>，通过向其他计算机（如缓存，数据库服务器，电子商务服务器 ...）发起请求来获取部分或全部资源。

<font color=FF0000>**Server 不一定是一台机器，但一个机器上可以装载的众多Servers**</font>。在HTTP/1.1 和Host头部中，它们甚至可以共享同一个IP地址。

**代理（Proxies）**
在浏览器和服务器之间，有许多计算机和其他设备转发了HTTP消息。<font color=FF0000>由于Web栈层次结构的原因，它们大多都出现在传输层、网络层和物理层上，对于HTTP应用层而言就是透明的</font>，虽然它们可能会对应用层性能有重要影响。还有一部分是表现在应用层上的，被称为代理（Proxies）。代理（Proxies）既可以表现得透明，又可以不透明（“改变请求”会通过它们）。<font color=FF0000>**代理主要有如下几种作用**</font>：

- 缓存（可以是公开的也可以是私有的，像浏览器的缓存）
- 过滤（像反病毒扫描，家长控制...）
- 负载均衡（让多个服务器服务不同的请求）
- 认证（对不同资源进行权限管理）
- 日志记录（允许存储历史信息）

**HTTP 的基本性质**

- **HTTP 是简单的：**

  虽然下一代HTTP/2协议将HTTP消息封装到了帧（frames）中，HTTP大体上还是被设计得简单易读（即：HTTP/1.1及之前，HTTP报文是语义可读的，HTTP/2 就不可读了）。HTTP报文能够被人读懂，还允许简单测试，降低了门槛，对新人很友好。

- **HTTP 是可扩展的：**

  在 HTTP/1.0 中出现的 HTTP headers 让协议扩展变得非常容易。只要服务端和客户端就新 headers 达成语义一致，新功能就可以被轻松加入进来。

- **HTTP 是无状态，有会话的：**

  HTTP是无状态的：在同一个连接中，两个执行成功的请求之间是没有关系的。把Cookies添加到头部中，创建一个会话让每次请求都能共享相同的上下文信息，达成相同的状态。注意，HTTP本质是无状态的，使用Cookies可以创建有状态的会话。

**HTTP 能控制什么**

多年以来，HTTP良好的扩展性使得越来越多的Web功能归其控制。缓存和认证很早就可以由HTTP来控制了。另一方面，对同源同域的限制到2010年才有所改变。

**以下是可以被HTTP控制的常见特性：**

- **缓存 ：**文档如何缓存能通过HTTP来控制。服务端能告诉代理和客户端哪些文档需要被缓存，缓存多久，而客户端也能够命令中间的缓存代理来忽略存储的文档。
- **开放同源限制：**<mark>为了防止网络窥听和其它隐私泄漏，浏览器强制对Web网站做了分割限制。只有来自于相同来源的网页才能够获取网站的全部信息</mark>。<font color=FF0000>这样的限制有时反而成了负担，HTTP可以通过修改头部来开放这样的限制，因此Web文档可以是由不同域下的信息拼接成的（某些情况下，这样做还有安全因素考虑）</font>。
- **认证：**一些页面能够被保护起来，仅让特定的用户进行访问。基本的认证功能可以直接通过HTTP提供，使用Authenticate相似的头部即可，或用HTTP Cookies来设置指定的会话。
- **代理和隧道：**<font color=FF0000>通常情况下，服务器和/或客户端是处于内网的，对外网隐藏真实 IP 地址</font>。因此 <font color=FF0000>HTTP 请求就要通过代理越过这个网络屏障</font>。但并非所有的代理都是 HTTP 代理。例如，SOCKS协议的代理就运作在更底层，一些像 FTP 这样的协议也能够被它们处理。
- **会话：**使用HTTP Cookies允许你用一个服务端的状态发起请求，这就创建了会话。虽然基本的HTTP是无状态协议。这很有用，不仅是因为这能应用到像购物车这样的电商业务上，更是因为这使得任何网站都能轻松为用户定制展示内容了。

**HTTP 报文**
<font color=FF0000>HTTP/1.1以及更早的HTTP协议报文都是语义可读的</font>。<font color=FF0000 size=4>**在HTTP/2中，这些报文被嵌入到了一个新的二进制结构，帧。帧允许实现很多优化，比如报文头部的压缩和复用**</font>。<font color=FF0000>即使只有原始HTTP报文的一部分以HTTP/2发送出来，每条报文的语义依旧不变，<font size=4>**客户端会重组原始HTTP/1.1请求**</font>。因此用HTTP/1.1格式来理解HTTP/2报文仍旧有效</font>。

**基于HTTP的APIs**

- 基于HTTP的最常用API是XMLHttpRequest API，可用于在user agent和服务器之间交换数据。 现代Fetch API提供相同的功能，具有更强大和灵活的功能集。

- <font color=FF0000>另一种API，即服务器发送的事件，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件</font>。 <font color=FF0000>使用EventSource接口**（Server Sent Events 相关）**，客户端打开连接并建立事件句柄</font>。 客户端浏览器自动将到达HTTP流的消息转换为适当的Event对象，并将它们传递给专门处理这类type事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给 （EventSource 接口的）onmessage 事件处理程序处理。

摘自：[MDN - HTTP概述](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview)



#### POST 方法

HTTP POST 方法 <font color=FF0000> **发送数据给服务器**</font>。<font color=FF0000> 请求主体的类型由 Content-Type 首部指定</font>。

<mark>PUT 和 POST方法的区别是</mark><font color=FF0000> ，**PUT方法是幂等的**：连续调用一次或者多次的效果相同（无副作用）</font>。<font color=FF0000> **连续调用同一个POST可能会带来额外的影响**，比如多次提交订单</font>。

<font color=FF0000> 一个 POST 请求通常是通过 HTML 表单发送， 并返回服务器的修改结果</font>。<mark>在这种情况下，content type 是通过在 \<form> 元素中设置正确的 enctype 属性，或是在 \<input> 和 \<button> 元素中设置 formenctype 属性</mark>来选择的：

- **application/x-www-form-urlencoded：**<font color=FF0000> 数据被编码成以 '&' 分隔的键-值对，同时以 '=' 分隔键和值</font>。非字母或数字的字符会被 percent-encoding（百分比编码）：这也就是为什么这种类型不支持二进制数据（应使用 multipart/form-data 代替）。
- **multipart/form-data**
- **text/plain**

当 POST 请求是通过**除 HTML 表单之外的方式发送**时，<font color=FF0000> 例如使用 XMLHttpRequest，那么请求主体可以是任何类型</font>。按HTTP 1.1规范中描述，POST为了以统一的方法来涵盖以下功能：

- 注释已有的资源
- 在公告板，新闻组，邮件列表或类似的文章组中发布消息;
- 通过注册新增用户;
- 向数据处理程序提供一批数据，例如提交一个表单;
- 通过追加操作，扩展数据库数据.

| 属性                 | 值                                        |
| :------------------- | ----------------------------------------- |
| 请求是否有主体       | 是                                        |
| 成功的响应是否有主体 | 是                                        |
| 安全                 | 否                                        |
| 幂等                 | 否                                        |
| 可缓存               | Only if freshness information is included |
| HTML 表单是否支持    | 是                                        |

**语法**

```http
POST /index.html
```

**示例**
使用<font color=FF0000 size=4> **默认的 application/x-www-form-urlencoded**</font> 做为 content type 的简单表单:

```http
POST / HTTP/1.1
Host: foo.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

say=Hi&to=Mom
```

使用 multipart/form-data 作为 content type 的表单:

```http
POST /test.html HTTP/1.1
Host: example.org
Content-Type: multipart/form-data;boundary="boundary"

--boundary
Content-Disposition: form-data; name="field1"

value1
--boundary
Content-Disposition: form-data; name="field2"; filename="example.txt"

value2
```

摘自：[MDN - POST](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST)



#### PUT 方法

HTTP PUT 请求方法使用请求中的负载创建或者替换目标资源。

PUT 与 POST 方法的区别在于，PUT方法是幂等的：调用一次与连续调用多次是等价的（即没有副作用），而连续调用多次POST方法可能会有副作用，比如将一个订单重复提交多次。

| 属性                                              | 值                                |
| :------------------------------------------------ | --------------------------------- |
| 请求是否有主体                                    | 可以有                            |
| 成功的返回是否有主体                              | 否                                |
| <font color=FF0000> **安全**</font>               | <font color=FF0000>**否** </font> |
| 幂等                                              | 是                                |
| 可缓存                                            | 否                                |
| <font color=FF0000> 可以在HTML forms中使用</font> | <font color=FF0000> **否**</font> |

**语法**

```http
PUT /new.html HTTP/1.1
```

**示例**

- **请求**

  ```http
  PUT /new.html HTTP/1.1
  Host: example.com
  Content-type: text/html
  Content-length: 16
  
  <p>New File</p>
  ```

- **应答**

  - 如果<font color=FF0000> 目标资源**不存在**</font>，<font color=FF0000> 并且PUT方法成功创建了一份</font>，<mark>那么源头服务器**必须返回201 (Created)** 来通知客户端资源已创建</mark>。

    ```http
    HTTP/1.1 201 Created
    Content-Location: /new.html
    ```

  - 如果<font color=FF0000> 目标资源**已经存在**</font>，<font color=FF0000> 并且依照请求中封装的表现形式成功进行了更新</font>，那么，<mark>源头服务器**必须返回200 (OK) 或者204 (No Content)** 来表示请求的成功完成</mark>。

    ```http
    HTTP/1.1 204 No Content
    Content-Location: /existing.html
    ```

摘自：[MDN - PUT](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PUT)



#### DELETE 方法

**HTTP DELETE** 请求方法<font color=FF0000> 用于删除指定的资源</font>。

| 属性                                              | 值                                |
| :------------------------------------------------ | --------------------------------- |
| 请求是否有主体                                    | 可以有                            |
| 成功的返回是否有主体                              | 可以有                            |
| <font color=FF0000> **安全**</font>               | <font color=FF0000>**否** </font> |
| <font color=FF0000> **幂等**</font>               | <font color=FF0000>**是**</font>  |
| 可缓存                                            | 否                                |
| <font color=FF0000> 可以在HTML forms中使用</font> | <font color=FF0000> **否**</font> |

**语法**

```http
DELETE /file.html HTTP/1.1
```

**示例**

- **请求**

  ```http
  DELETE /file.html HTTP/1.1
  ```

- **响应**

  <font color=FF0000> 如果 DELETE方法成功执行，那么可能会有以下几种状态码</font>：

  - 状态码  202 (Accepted) 表示请求的操作可能会成功执行，但是尚未开始执行。

  - 状态码 204 (No Content) 表示操作已执行，但是无进一步的相关信息。

  - <font color=FF0000> 状态码  200 (OK) 表示操作已执行，并且响应中提供了相关状态的描述信息</font>。

    ```http
    HTTP/1.1 200 OK
    Date: Wed, 21 Oct 2015 07:28:00 GMT
    
    <html>
      <body>
        <h1>File deleted.</h1>
      </body>
    </html>
    ```

摘自：[MDN - DELETE](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE)



#### OPTIONS方法

HTTP 的 OPTIONS 方法 <font color=FF0000> **用于获取目的资源所支持的通信选项** </font>。<mark>客户端可以对特定的 URL 使用 OPTIONS 方法</mark>，也可以对整站（通过将 URL 设置为“*”）使用该方法。

**语法**

```http
OPTIONS /index.html HTTP/1.1
OPTIONS * HTTP/1.1
```

| 属性                 | 值   |
| :------------------- | ---- |
| 请求是否有正文       | 否   |
| 成功的响应是否有正文 | 是   |
| 安全                 | 是   |
| 幂等                 | 是   |
| 可缓存               | 否   |
| HTML 表单 是否支持   | 否   |

**语法**

```http
OPTIONS /index.html HTTP/1.1
OPTIONS * HTTP/1.1
```

**示例：**

- **检测服务器所支持的请求方法**

  可以使用 OPTIONS 方法对服务器发起请求，以检测服务器支持哪些 HTTP 方法：

  ```sh
  curl -X OPTIONS http://example.org -i
  ```

  <font color=FF0000> 响应报文包含一个 <font size=4>**Allow 首部字段**</font>，该字段的值表明了服务器支持的所有 HTTP 方法</font>：

  ```http
  HTTP/1.1 200 OK
  Allow: OPTIONS, GET, HEAD, POST
  Cache-Control: max-age=604800
  Date: Thu, 13 Oct 2016 11:45:00 GMT
  Expires: Thu, 20 Oct 2016 11:45:00 GMT
  Server: EOS (lax004/2813)
  x-ec-custom-error: 1
  Content-Length: 0
  ```

- **CORS 中的预检请求**
  在 CORS 中，可以使用 OPTIONS 方法发起一个<font color=FF0000> **预检请求**</font>，以<font color=FF0000> 检测实际请求是否可以被服务器所接受</font>。预检请求报文中的 <font color=FF0000 size=4> **Access-Control-Request-Method**</font> 首部字段<font color=FF0000> **告知服务器**</font>实际请求所使用的 HTTP 方法；<font color=FF0000 size=4> **Access-Control-Request-Headers**</font> 首部字段<font color=FF0000> **告知服务器**</font>实际请求所携带的自定义首部字段。<font color=FF0000> 服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求</font>。

  ```http
  OPTIONS /resources/post-here/ HTTP/1.1
  Host: bar.other
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
  Accept-Language: en-us,en;q=0.5
  Accept-Encoding: gzip,deflate
  Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
  Connection: keep-alive
  Origin: http://foo.example
  Access-Control-Request-Method: POST
  Access-Control-Request-Headers: X-PINGOTHER, Content-Type
  ```

- <mark>服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中</mark>。

  ```http
  HTTP/1.1 200 OK
  Date: Mon, 01 Dec 2008 01:15:39 GMT
  Server: Apache/2.0.61 (Unix)
  Access-Control-Allow-Origin: http://foo.example
  Access-Control-Allow-Methods: POST, GET, OPTIONS
  Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
  Access-Control-Max-Age: 86400
  Vary: Accept-Encoding, Origin
  Content-Encoding: gzip
  Content-Length: 0
  Keep-Alive: timeout=2, max=100
  Connection: Keep-Alive
  Content-Type: text/plain
  ```

摘自：[MDN - OPTIONS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS)



#### HEAD方法

HTTP HEAD 方法 <font color=FF0000> **请求资源的头部信息**</font>，并且<font color=FF0000> 这些头部与 HTTP GET 方法请求时返回的一致</font>。<mark>该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载，以此可以节约带宽资源</mark>；也可以判断，一个链接是否可以访问，以及最近是否有更新

<font color=FF0000> **HEAD 方法的响应不应包含响应正文**</font>。<font color=FF0000>即使包含了正文也必须忽略掉</font>。虽然描述正文信息的 entity headers，例如 Content-Length 可能会包含在响应中，但它们并不是用来描述 HEAD 响应本身的，而是用来描述同样情况下的 GET 请求应该返回的响应。

如果 HEAD 请求的结果显示在上一次 GET 请求后缓存的资源已经过期了，即使没有发出GET请求，缓存也会失效

| 属性                 | 值   |
| :------------------- | ---- |
| 请求是否有正文       | 否   |
| 成功的响应是否有正文 | 否   |
| 安全                 | 是   |
| 幂等                 | 是   |
| 可缓存               | 是   |
| HTML 表单 是否支持   | 否   |

**语法**

```http
HEAD /index.html
```

摘自：[MDN - HEAD](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD)



#### CONNECT

在 HTTP 协议中，CONNECT 方法<font color=FF0000> 可以开启一个客户端与所请求资源之间的双向沟通的通道</font>。它<font color=FF0000> 可以用来创建隧道 ( tunnel )</font>。

例如，CONNECT 可以用来访问采用了 SSL 协议的站点。客户端要求代理服务器将 TCP 连接作为通往目的主机隧道。之后该服务器会代替客户端与目的主机建立连接。连接建立好之后，代理服务器会面向客户端发送或接收 TCP 消息流。

<font color=FF0000> CONNECT 是一个应用范围为点到点的方法</font>。

| 属性                 | 值   |
| :------------------- | ---- |
| 请求是否有正文       | 否   |
| 成功的响应是否有正文 | 是   |
| 安全                 | 否   |
| 幂等                 | 否   |
| 可缓存               | 否   |
| HTML 表单 是否支持   | 否   |

**语法**

```http
CONNECT www.example.com:443 HTTP/1.1
```

**示例**

一些代理服务器在创建隧道时会要求进行身份验证。参见  Proxy-Authorization 首部。

```http
CONNECT server.example.com:80 HTTP/1.1
Host: server.example.com:80
Proxy-Authorization: basic aGVsbG86d29ybGQ=
```

摘自：[MDN - CONNECT](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/CONNECT)

**补充：**CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。

摘自：图解HTTP - P40



#### TRACE

HTTP TRACE 方法 实现<font color=FF0000> 沿通向目标资源的路径的**消息环回**（loop-back）**测试**</font> ，提供了一种实用的 debug 机制。

<mark>请求的最终接收者应当原样反射（reflect）它接收到的消息</mark>，<font color=FF0000> 除了以下字段部分，作为一个 **Content-Type** 为 message/http 的200（OK）响应的消息的主体（body）返回给客户端</font>。

<font color=FF0000> 最终接收者是指初始（origin）服务器</font>，<font size=4>**或者**</font> <font color=FF0000> 第一个接收到 Max-Forwards 值为 0的请求的服务器</font>（这里可以借鉴 TTL）。

| 属性                                     | 值   |
| :--------------------------------------- | ---- |
| 有主体（body）的请求（request）          | 否   |
| 包含主体（body）的成功的响应（response） | 否   |
| 安全                                     | 否   |
| 幂等                                     | 是   |
| 可缓存                                   | 否   |
| 允许用于 HTML 表单（form）               | 否   |

**语法**

```http
TRACE /index.html
```

摘自：[MDN - TRACE](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/TRACE)



#### Date

Date 是一个<font color=FF0000> 通用首部</font>，其中<font color=FF0000> **包含了报文创建的日期和时间**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 头类型       | 通用头 |
| 禁用首部名称 | 是     |

语法

```http
Date: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
```

指令

- **\<day-name>：**"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", 或 "Sun" 之一 （<font color=FF0000> 区分大小写</font>）。
- **\<day>：**<font color=FF0000> 2位数字</font>表示天数，例如， "04" 或 "23"。
- **\<month>：**"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" 之一（<font color=FF0000> 区分大小写</font>）。
- **\<year>：**<font color=FF0000> 4位数字</font>表示年份，例如， "1990" 或 "2016"。
- **\<hour>：**<font color=FF0000> 2位数字</font>表示小时数，例如， "09" 或 "23"。
- **\<minute>：**<font color=FF0000> 2位数字</font>表示分钟数，例如， "04" 或 "59"。
- **\<second>：**<font color=FF0000> 2位数字</font>表示秒数，例如， "04" 或 "59"。
- **GMT：**格林尼治标准时间。 <font color=FF0000>**在HTTP协议中，时间都是用格林尼治标准时间来表示的，而不是本地时间**</font>。

示例

```http
Date: Wed, 21 Oct 2015 07:28:00 GMT
```

摘自：[MDN - Date](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date)



#### Allow

Allow 首部字段<font color=FF0000> 用于枚举资源所支持的 HTTP 方法的集合</font>。

若服务器<font color=FF0000> 返回状态码 405 Method Not Allowed</font>，则<font color=FF0000> 该首部字段亦需要同时返回给客户端</font>。<mark>如果 Allow  首部字段的值为空，说明资源不接受使用任何 HTTP 方法的请求。这是可能的，比如服务器需要临时禁止对资源的任何访问</mark>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 实体头 |
| 禁用首部名称 | 否     |

**语法**

```http
Allow: <http-methods>
```

**声明**

- \<http-methods>：HTTP 请求方法的集合。

**示例**

```http
Allow: GET, POST, HEAD
```

摘自：[MDN - Allow](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Allow)



#### Connection

<font color=FF0000> Connection 头（header） **决定当前的事务完成后，是否会关闭网络连接**</font>。<mark>如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成</mark>。

> **注意：** <font color=FF0000> **特定于连接的标头字段（例如Connection）<font color=FF0000 size=4>不得与 HTTP/2 一起使用</font>**</font>。

除去标准的逐段传输 ( hop-by-hop) 头（Keep-Alive、Transfer-Encoding、TE、Connection、Trailer、Upgrade、Proxy-Authorization 和 Proxy-Authenticate），任何逐段传输头都需要在 Connection 头中列出，这样才能让第一个代理知道必须处理它们且不转发这些头。标准的逐段传输头也可以列出（常见的例子是 Keep-Alive，但这不是必须的）。

| 属性         | 值     |
| ------------ | ------ |
| 头类型       | 通用头 |
| 禁用首部名称 | 是     |

**语法**

```http
Connection: keep-alive
Connection: close
```

**指令**

- **close：**<mark>表明客户端或服务器想要关闭该网络连接</mark>，这是<font color=FF0000> HTTP/1.0请求的默认值</font>

- **以逗号分隔的HTTP头（通常仅有 keep-alive）：**表明客户端想要保持该网络连接打开，<font color=FF0000>**HTTP/1.1 的请求默认使用一个持久连接**</font>。这个请求头列表由头部名组成，这些头将被第一个非透明的代理或者代理间的缓存所移除：这些头定义了发出者和第一个实体之间的连接，而不是和目的地节点间的连接。

摘自：[MDN - Connection](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection)

#### Keep-Alive

Keep-Alive 是一个<font color=FF0000>通用消息头</font>，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。

需要将 The Connection 首部的值设置为  "keep-alive" 这个首部才有意义。同时需要注意的是，在HTTP/2 协议中， Connection 和 Keep-Alive  是被忽略的；在其中采用其他机制来进行连接管理。

| 属性               | 值       |
| :----------------- | -------- |
| 首部类型           | 通用首部 |
| 禁止修改的消息首部 | 否       |

##### **语法**

```http
Keep-Alive: parameters
```

##### **指令**

**parameters**

<mark>一系列用逗号隔开的参数，每一个参数由一个标识符和一个值构成，并使用等号 ( '=' ) 隔开</mark>。下述标识符是可用的：

- **timeout：**<font color=FF0000>指定了一个空闲连接需要 **保持打开状态** 的最小时长（以秒为单位）</font>。需要注意的是，<font color=FF0000 size=4>**如果没有在传输层设置 keep-alive TCP message 的话，大于 TCP 层面的超时设置会被忽略**</font>。
- **max：**<font color=FF0000>在连接关闭之前，在此连接可以发送的请求的最大值</font>。在非管道连接中，除了 0 以外，这个值是被忽略的，因为需要在紧跟着的响应中发送新一次的请求。HTTP 管道连接则可以用它来限制管道的使用。

##### 示例

**含有 Keep-Alive 首部的响应示例：**

```http
HTTP/1.1 200 OK
Connection: Keep-Alive
Content-Encoding: gzip
Content-Type: text/html; charset=utf-8
Date: Thu, 11 Aug 2016 15:23:13 GMT
Keep-Alive: timeout=5, max=1000
Last-Modified: Mon, 25 Jul 2016 04:32:39 GMT
Server: Apache

(body)
```

摘自：[MDN - Keep-Alive](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive)



#### Location

Location 首部<font color=FF0000> 指定的是**需要将页面重新定向至的地址**</font>。<font color=FF0000> 一般在响应码为3xx的响应中才会有意义</font>。

发送新请求，获取 Location 指向的新页面所采用的方法与初始请求使用的方法以及重定向的类型相关：

- <font color=FF0000>**303 (See Also)** </font>：<font color=FF0000 size=4>**始终引致请求使用 GET 方法**</font>，而 <font color=FF0000> **307 (Temporary Redirect)** </font>和 <font color=FF0000> **308 (Permanent Redirect)** </font>则不转变初始请求中的所使用的方法；
- <font color=FF0000> **301 (Permanent Redirect)**</font> 和 <font color=FF0000> **302 (Found)**</font>：<font color=FF0000>在大多数情况下 **不会转变初始请求中的方法**</font>，不过一些比较早的用户代理可能会引发方法的变更（所以你基本上不知道这一点）。

<font size=4><font color=FF0000>**状态码**</font> 为上述之一的所有响应<font color=FF0000>都会带有一个 Location 首部</font></font>。

<font color=FF0000> **除了重定向响应之外， 状态码为 201 (Created) 的消息也会带有Location首部**。它指向的是新创建的资源的地址</font>。

<font color=FF0000>Location 与 Content-Location是不同的，**前者 ( Location ) 指定的是一个 <font size=4>重定向请求的目的地址（或者新创建的文件的URL）</font>，而后者（ Content-Location ) 指向的是 <font size=4>经过内容协商后的资源的直接地址</font>，不需要进行进一步的内容协商**</font>。<font color=FF0000>Location 对应的是响应，而Content-Location对应的是要返回的实体</font>。

| 属性         | 值       |
| ------------ | -------- |
| 报文类型     | 响应首部 |
| 禁用首部名称 | 否       |

**语法**

```http
Location: <url>
```

指令

- **\<url>：**相对地址（相对于要访问的URL）或绝对地址。

示例

```http
Location: /index.html
```

摘自：[MDN - Location](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location)

#### Content-Location

Content-Location 首部指定的是要 <font color=FF0000>返回的数据的地址选项</font>。最主要的用途是用来<font color=FF0000>指定要访问的资源经过[内容协商](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation)后的结果的URL</font>。

Location 与 Content-Location是不同的，前者（Location ）指定的是一个重定向请求的目的地址（或者新创建的文件的URL），而后者（ Content-Location） 指向的是可供访问的资源的直接地址，不需要进行进一步的内容协商。<font color=FF0000 size=4>**Location 对应的是响应，而 Content-Location对应的是要返回的实体**</font>。

| 属性               | 值       |
| :----------------- | -------- |
| 首部类型           | 实体首部 |
| 禁止修改的消息首部 | 否       |

**语法**

```http
Content-Location: <url>
```

**指令**

- **\<url>：**相对地址（相对于要访问的URL）或绝对地址。

**示例**

```http
Content-Location: /index.html
```

摘自：[MDN - Content-Location](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Location)



#### Via

Via 是一个<font color=FF0000> **通用首部**</font>，是<font color=FF0000> 由代理服务器添加</font>的，<font color=FF0000> 适用于正向和反向代理</font>，<font color=FF0000> 在请求和响应首部中均可出现</font>。这个消息首部<font color=FF0000> 可以用来追踪消息转发情况，**防止循环请求**</font>，以及<font color=FF0000> 识别在请求或响应传递链中消息发送者对于协议的支持能力</font>。

| 属性         | 值       |
| ------------ | -------- |
| 报文类型     | 通用首部 |
| 禁用首部名称 | 是       |

语法

```http
Via: [ <protocol-name> "/" ] <protocol-version> <host> [ ":" <port> ]
Via: [ <protocol-name> "/" ] <protocol-version> <pseudonym>
```

指令

- **\<protocol-name>：**<font color=FF0000> 可选</font>。所使用的协议名称，如 "HTTP"。（如下示例，http之类的协议名称可以省略）
- **\<protocol-version>：**所使用的协议版本号， 例如 "1.1"。
- **\<host> & \<port>：**公共代理的URL及端口号。
- **\<pseudonym>：**内部代理的名称或别名。

示例

```http
Via: 1.1 vegur
Via: HTTP/1.1 GWA
Via: 1.0 fred, 1.1 p.example.net
```

摘自：[MDN - Via](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Via)



#### TE

TE 请求型头部<font color=FF0000> 用来指定**用户代理希望使用的<font size=4>传输编码类型</font>**</font>。(<mark>可以将其非正式称为 Accept-Transfer-Encoding</mark>， 这个名称显得更直观一些)。**注：**要注意和 Transfer-Encoding 的区别

可以参考  Transfer-Encoding 来获取更多关于传输编码的细节信息。**值得注意的是， <font color=FF0000> 支持 HTTP/1.1 协议的接收方一定可以处理 chunked 传输编码请求</font>，所以没有必要一定在  TE 首部指定“chunked”关键字**。然而，如果客户端将要接收编码在chunked包体里面的"trailer"信息的时候，主动指定该头部将会非常有用。

| 属性         | 值       |
| ------------ | -------- |
| 报文类型     | 请求首部 |
| 禁用首部名称 | 是       |

**语法**

```http
TE: compress
TE: deflate
TE: gzip
TE: trailers
// 多个指令, 使用 quality value 语法来表示优先级:
TE: trailers, deflate;q=0.5
```

**指令**

- **compress：**这个名称代表采用了 <mark> Lempel-Ziv-Welch (LZW) 压缩算法的传输编码格式</mark>。
- **deflate：**这个名称代表采用了 <font color=FF0000> zlib 结构的传输编码格式</font>。
- **gzip：**这个名称代表采用了  <font color=FF0000> Lempel-Ziv coding (LZ77) 压缩算法，以及32位CRC校验的传输编码格式</font>。
- **trailers：**表示<font color=FF0000> 客户端期望在采用分块传输编码的响应中接收挂载字段</font>。
- **q：**当多种形式的传输编码格式都可以接受的时候，这个采用了质量价值语法的参数可以用来对不同的编码形式按照**优先级**进行排序

摘自：[MDN - TE](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/TE)

#### Transfer-Encoding

Transfer-Encoding 消息首部指明了<font color=FF0000>（服务器）将 entity 安全传递给用户（**注：**即UA）所采用的编码形式</font>。

<font color=FF0000>Transfer-Encoding 是一个 <font size=4>**逐跳传输消息首部**</font></font>（**注：**这就是Transfer-Encoding 和 Content-Encoding 的区别，后面有详细的说明content-Encoding 的 ），<font color=FF0000>即 <font size=4>**仅应用于两个节点之间的消息传递**</font>，而不是所请求的资源本身</font>。<mark>一个多节点连接中的每一段都可以应用不同的 Transfer-Encoding 值</mark>。<font color=FF0000>如果你 **想要将压缩后的数据应用于整个连接，那么请使用端到端传输消息首部  Content-Encoding**</font>。

当这个消息首部出现在 HEAD 请求的响应中，而这样的响应没有消息体，那么它其实指的是应用在相应的  GET 请求的应答的值。

| 属性               | 值       |
| :----------------- | -------- |
| 首部类型           | 响应首部 |
| 禁止修改的消息首部 | 是       |

**语法**

```http
Transfer-Encoding: chunked
Transfer-Encoding: compress
Transfer-Encoding: deflate
Transfer-Encoding: gzip
Transfer-Encoding: identity
// Several values can be listed, separated by a comma
Transfer-Encoding: gzip, chunked
```

**指令**

- **chunked：**数据以一系列分块的形式进行发送。 [`Content-Length`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length) 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 '`\r\n`' ，之后是分块本身，后面也是'`\r\n`' 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。

  **举例：**<mark>分块编码主要应用于如下场景，即要传输大量的数据，但是在请求在没有被处理完之前响应的长度是无法获得的</mark>。例如，当需要用从数据库中查询获得的数据生成一个大的HTML表格的时候，或者需要传输大量的图片的时候。一个分块响应形式如下：

  ```http
  HTTP/1.1 200 OK
  Content-Type: text/plain
  Transfer-Encoding: chunked
  
  7\r\n
  Mozilla\r\n
  9\r\n
  Developer\r\n
  7\r\n
  Network\r\n
  0\r\n
  \r\n
  ```

- **compress：**采用 [Lempel-Ziv-Welch](http://en.wikipedia.org/wiki/LZW) (LZW) 压缩算法。这个名称来自UNIX系统的 *compress* 程序，该程序实现了前述算法。 与其同名程序已经在大部分UNIX发行版中消失一样，这种内容编码方式已经被大部分浏览器弃用，部分因为专利问题（这项专利在2003年到期）。

- **deflate：**采用 [zlib](http://en.wikipedia.org/wiki/Zlib) 结构 (在 [RFC 1950](https://tools.ietf.org/html/rfc1950) 中规定)，和 [*deflate*](http://en.wikipedia.org/wiki/DEFLATE) 压缩算法(在 [RFC 1951](https://tools.ietf.org/html/rfc1952) 中规定)。

- **gzip：**表示采用 [Lempel-Ziv coding](http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77) (LZ77) 压缩算法，以及32位CRC校验的编码方式。这个编码方式最初由 UNIX 平台上的 *gzip* 程序采用。<font color=FF0000>出于兼容性的考虑， HTTP/1.1 标准提议支持这种编码方式的服务器应该识别作为别名的 `x-gzip `指令</font>。

- **identity：**用于指代自身（例如：未经过压缩和修改）。除非特别指明，这个标记始终可以被接受。

摘自：[MDN - Transfer-Encoding](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding)

#### Accept-Encoding

HTTP 请求头 Accept-Encoding 会<font color=FF0000>将客户端能够理解的内容编码方式——通常是 **某种压缩算法**——进行通知（给服务端）</font>。通过内容协商的方式，<font color=FF0000>服务端会选择一个客户端提议的方式，使用并在响应头 Content-Encoding 中通知客户端该选择</font>。

<mark>即使客户端和服务器都支持相同的压缩算法，在 identity 指令可以被接受的情况下，服务器也可以选择对响应主体不进行压缩</mark>。导致这种情况出现的两种常见的情形是：

- <font color=FF0000>要发送的数据已经经过压缩，再次进行压缩不会导致被传输的数据量更小</font>。一些图像格式的文件会存在这种情况；
- <font color=FF0000>服务器超载，无法承受压缩需求导致的计算开销</font>。通常，如果服务器使用超过80%的计算能力，微软建议不要压缩。

只要 identity —— 表示不需要进行任何编码——没有被明确禁止使用（通过 identity;q=0 指令或是 *;q=0 而没有为 identity 明确指定权重值），则服务器禁止返回表示客户端错误的 406 Not Acceptable 响应。

| 属性               | 值     |
| :----------------- | ------ |
| 首部类型           | 请求头 |
| 禁止修改的消息首部 | 是     |

**语法**

```http
Accept-Encoding: gzip
Accept-Encoding: compress
Accept-Encoding: deflate
Accept-Encoding: br
Accept-Encoding: identity
Accept-Encoding: *
// Multiple algorithms, weighted with the quality value syntax:
Accept-Encoding: deflate, gzip;q=1.0, *;q=0.5
```

**指令**

- **gzip：**表示采用 [Lempel-Ziv coding](http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77) (LZ77) 压缩算法，以及32位CRC校验的编码方式。
- **compress：**采用 [Lempel-Ziv-Welch](http://en.wikipedia.org/wiki/LZW) (LZW) 压缩算法。
- **deflate：**采用 [zlib](http://en.wikipedia.org/wiki/Zlib) 结构和 [*deflate*](http://en.wikipedia.org/wiki/DEFLATE) 压缩算法。
- **br：**表示采用 [Brotli](https://en.wikipedia.org/wiki/Brotli) 算法的编码方式。
- **identity：**用于指代自身（例如：未经过压缩和修改）。除非特别指明，这个标记始终可以被接受。
- **\*：**匹配其他任意未在该请求头字段中列出的编码方式。假如该请求头字段不存在的话，这个值是默认值。它并不代表任意算法都支持，而仅仅表示算法之间无优先次序。
- **;q= (qvalues weighting)：**值代表优先顺序，用相对[质量价值](https://developer.mozilla.org/zh-CN/docs/Glossary/Quality_values) 表示，又称为权重。

摘自：[MDN - Accept-Encoding](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Encoding)

#### Content-Encoding

实体消息首部 Content-Encoding <font color=FF0000>列出了对当前实体消息（消息荷载）应用的任何编码类型，以及编码的顺序</font>。它<font color=FF0000>让接收者知道需要以何种顺序解码该实体消息才能获得原始荷载格式</font>。 Content-Encoding 主要用于在不丢失原媒体类型内容的情况下压缩消息数据。

请注意<font color=FF0000>**原始媒体/内容的类型通过 Content-Type 首部给出**，而 **Content-Encoding 应用于数据的表示**，或“编码形式”</font>。如果原始媒体以某种方式编码（例如 zip 文件），则该信息不应该被包含在 Content-Encoding 首部内。

<font color=FF0000>一般建议服务器应对数据尽可能地进行压缩，并在适当情况下对内容进行编码</font>。<mark>对一种压缩过的媒体类型如 zip 或 jpeg 进行额外的压缩并不合适，因为这反而有可能会使荷载增大</mark>。

| 属性               | 值                                                           |
| :----------------- | ------------------------------------------------------------ |
| 首部类型           | [Representation header (en-US)](https://developer.mozilla.org/en-US/docs/Glossary/Representation_header) |
| 禁止修改的消息首部 | 否                                                           |

**语法**

```http
Content-Encoding: gzip
Content-Encoding: compress
Content-Encoding: deflate
Content-Encoding: br
// 多个，按应用的编码顺序列出
Content-Encoding: deflate, gzip
```

**指令**

- **gzip：**表示采用 [Lempel-Ziv coding](https://zh.wikipedia.org/wiki/LZ77与LZ78#LZ77)（LZ77）压缩算法，以及32位 CRC 校验的编码方式。这个编码方式最初由 UNIX 平台上的 *gzip* 程序采用。出于兼容性的考虑，HTTP/1.1 标准提议支持这种编码方式的服务器应该识别作为别名的 `x-gzip `指令。
- **compress：**采用 [Lempel-Ziv-Welch](https://zh.wikipedia.org/wiki/LZW)（LZW）压缩算法。这个名称来自 UNIX 系统的 *compress* 程序，该程序实现了前述算法。与其同名程序已经在大部分 UNIX 发行版中消失一样，这种内容编码方式已经被大部分浏览器弃用，部分因为专利问题（这项专利在2003年到期）。
- **deflate：**采用 [zlib](https://zh.wikipedia.org/wiki/Zlib) 结构（在 [RFC 1950](https://datatracker.ietf.org/doc/html/rfc1950) 中规定），和 [deflate](https://zh.wikipedia.org/wiki/DEFLATE) 压缩算法（在 [RFC 1951](https://datatracker.ietf.org/doc/html/rfc1951) 中规定)。
- **br：**表示采用 [Brotli](https://zh.wikipedia.org/wiki/Brotli) 算法的编码方式。

摘自：[MDN - Content-Encoding](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Encoding)



#### Vary

Vary 是一个HTTP<font color=FF0000> 响应头部</font>信息，它<font color=FF0000> 决定了对于未来的一个请求头，**应该用一个缓存的回复 (response)  还是向源服务器请求一个新的回复**</font>。它<font color=FF0000> 被服务器用来表明在 content negotiation algorithm（**内容协商算法**）中**选择一个资源代表的时候应该使用哪些头部信息**</font>（headers）。

<mark><font color=FF0000> 在响应状态码为 304 Not Modified  的响应中，也要设置 Vary 首部</font>，而且要与相应的 200 OK 响应设置得一模一样</mark>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

语法

```http
Vary: *
Vary: <header-name>, <header-name>, ...
```

说明

- **\*：**<font color=FF0000> 所有的请求都被视为唯一并且非缓存的</font>，使用 Cache-Control: no-store, 来实现则更适用，这样用于说明不存储该对象更加清晰。
- **\<header-name>：**<font color=FF0000> 逗号分隔的一系列http头部名称，用于确定缓存是否可用</font>。

**例子：**动态服务
哪种情况下使用 Vary：对于User-Agent 头部信息，例如你提供给移动端的内容是不同的，可用防止你客户端误使用了用于桌面端的缓存。 并可帮助Google和其他搜索引擎来发现你的移动端版本的页面，同时告知他们不需要Cloaking。

```http
Vary: User-Agent
```

摘自：[MDN - Vary](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary)

<font size=4>**补充：**</font>vary 的作用是：在发送请求时，只有<font color=FF0000> 指定的HTTP头的值相同的情况下</font>，才会去使用缓存。



#### DNT

请求首部 **DNT** (**D**o **N**ot **T**rack) 表明了用户对于网站追踪的偏好。它允许用户指定自己是否更注重个人隐私还是定制化内容。

| 属性         | 值     |
| ------------ | ------ |
| 头类型       | 请求头 |
| 禁用首部名称 | 是     |

**语法：**

```http
DNT: 0
DNT: 1
```

**指令**

- 0：表示<font color=FF0000> 用户愿意目标站点追踪用户个人信息</font>。
- 1：表示<font color=FF0000> 用户**不愿意**目标站点追踪用户个人信息</font>。

用户对 DNT 的设置还可以使用 Navigator.doNotTrack 属性进行读取：

```js
navigator.doNotTrack; // "0" or "1"
```

摘自：[MDN - DNT](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/DNT)



#### Retry-After

在HTTP协议中，响应首部 Retry-After <font color=FF0000>表示用户代理需要**等待多长时间之后才能继续发送请求**</font>。这个首部**主要应用于以下两种场景**：

- 当与 503（Service Unavailable，当前服务不存在）响应一起发送的时候，表示服务下线的预期时长。
- 当与重定向响应一起发送的时候，比如 301（Moved Permanently，永久迁移），表示用户代理在发送重定向请求之前需要等待的最短时间。

| 属性               | 值       |
| :----------------- | -------- |
| 首部种类           | 响应首部 |
| 禁止修改的消息首部 | 否       |

**语法**

```http
Retry-After: <http-date>
Retry-After: <delay-seconds>
```

**指令**

- **\<http-date>：**<font color=FF0000>表示 **在此时间之后** 可以重新尝试</font>。参见 [Date](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Date) 首部来获取HTTP协议中关于日期格式的细节信息。
- **\<delay-seconds>：**一个非负的十进制整数，<font color=FF0000>表示在重试之前需要等待的秒数</font>。

摘自：[MDN - Retry-After]()



#### Range

The Range 是一个 <font color=FF0000> **请求首部**</font>，<font color=FF0000> 告知服务器返回文件的哪一部分</font>。<mark>在一个  Range 首部中，**可以一次性请求多个部分**，服务器会以 multipart 文件的形式将其返回</mark>。<mark style="background: aqua">如果服务器返回的是范围响应，需要使用 206 Partial Content 状态码</mark>。<mark style="background-color: fuchsia">假如所请求的范围不合法，那么服务器会返回  416 Range Not Satisfiable 状态码，表示客户端错误</mark>。服务器允许忽略  Range  首部，从而返回整个文件，状态码用 200

| 属性         | 值     |
| ------------ | ------ |
| 头类型       | 请求头 |
| 禁用首部名称 | 否     |

**示例：**

<img src="https://i.loli.net/2021/10/02/xpgK7J46UuqTXSL.png" alt="image-20211002165634152" style="zoom: 30%;" />

**语法**

```http
Range: <unit>=<range-start>-
Range: <unit>=<range-start>-<range-end>
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>, <range-start>-<range-end>
```

**指令**

- **\<unit>：**范围<font color=FF0000>所采用的单位</font>，<font color=FF0000>通常是字节</font>（bytes）。
- **\<range-start>：**一个整数，表示在特定单位下，范围的起始值。
- **\<range-end>：**一个整数，表示在特定单位下，范围的结束值。<mark>这个值是可选的，如果不存在，表示此范围一直延伸到文档结束</mark>。

**示例**

```http
Range: bytes=200-1000, 2000-6576, 19000-
```

摘自：[MDN - Range](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range)

#### If-Range

If-Range **HTTP 请求头字段** <font color=FF0000>用来使得 Range 头字段在一定条件下起作用</font>：<font color=FF0000>**当字段值中的条件得到满足时，Range 头字段才会起作用**，同时服务器回复206 部分内容状态码，以及Range 头字段请求的相应部分</font>；<mark>如果字段值中的条件没有得到满足，服务器将会返回 200 OK 状态码，并返回完整的请求资源</mark>。

字段值中 <font color=FF0000>既可以用 Last-Modified 时间值用作验证</font>，<font color=0000FF>也可以用 ETag 标记作为验证</font>，<font size=4>**但不能将两者同时使用**</font>。

If-Range 头字段通常用于断点续传的下载过程中，用来自从上次中断后，确保下载的资源没有发生改变。

| 属性               | 值       |
| :----------------- | -------- |
| 首部类型           | 请求首部 |
| 禁止修改的消息首部 | 否       |

**语法**

```http
If-Range: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
If-Range: <etag>
```

**说明**

- **\<etag>：**一个资源标签 ( entity tag ) 代表着所请求的资源。它是由被双引号包围的ACSII 编码的字符串组成的（例如"675af34563dc-tr34"）。<font color=FF0000>当应用弱匹配算法时，E-Tag会有一个 W/ 前缀</font>。

- **\<day-name>：**"Mon"，"Tue"，"Wed"，"Thu"，"Fri"，"Sat"或者"Sun"当中的一个（大小写敏感）。
- **\<day>：**两位数字，例如"04"或者"23"。
- **\<month>：**"Jan"，"Feb"，"Mar"，"Apr"，"May"，"Jun"，"Jul"，"Aug"，"Sep"，"Oct"，"Nov"，"Dec"中的一个（大小写敏感）
- **\<year>：**四位数字，例如"1990"或者"2016"。
- **\<hour>：**两位数字，例如"09"或者"23"。
- **\<minute>：**两位数字，例如"04"或者"59"。
- **\<second>：**两位数字，例如"04"或者"59"。
- **GMT：**格林威治标准时间。HTTP 协议的日期总是要使用GMT，而不是当地时间。

摘自：[MDN - If-Range](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Range)

#### Accept-Ranges

服务器使用 HTTP 响应头 Accept-Ranges <font color=FF0000> **标识自身支持范围请求** ( partial requests )</font>。字段的<font color=FF0000> 具体值**用于定义范围请求的单位** </font>。

当<font color=FF0000> 浏览器发现 Accept-Ranges 头时，**可以尝试继续中断了的下载**，而不是重新开始</font>。

| 类型               | 值     |
| :----------------- | ------ |
| 头部类型           | 响应头 |
| 禁止修改的 HTTP 头 | 否     |

**语法**

```http
Accept-Ranges: bytes
Accept-Ranges: none
```

**指令**

- **none：**<font color=FF0000> 不支持任何范围请求单位</font>，<mark>由于其等同于没有返回此头部，因此很少使用</mark>。不过一些浏览器，比如IE9，会依据该头部去禁用或者移除下载管理器的暂停按钮。
- **bytes：**<font color=FF0000> 范围请求的单位是 bytes （字节）</font>。

摘自：[MDN - Accept-Ranges](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Ranges)

#### If-Match

请求首部 If-Match 的使用 <font color=FF0000>表示这是一个**条件请求**</font>：<font color=FF0000>在请求方法为 GET 和 HEAD 的情况下，**服务器仅在请求的资源满足此首部列出的 ETag值时才会返回资源**</font>。而对于 PUT 或其他非安全方法来说，只有在满足条件的情况下才可以将资源上传。
<font color=FF0000>**ETag 之间的比较使用的是强比较算法**，即只有<mark>在每一个字节都相同的情况下，才可以认为两个文件是相同的</mark></font>。<mark>在 ETag 前面添加 W/ 前缀表示可以采用相对宽松的算法</mark>。

**以下是两个常见的应用场景：**

- <font color=FF0000>对于 **GET  和 HEAD 方法**，搭配  Range首部使用，可以用来保证新请求的范围与之前请求的范围是对同一份资源的请求</font>。如果  ETag 无法匹配，那么需要返回 416 (Range Not Satisfiable，范围请求无法满足) 响应。
- 对于其他方法来说，尤其是 PUT，If-Match 首部可以用来避免更新丢失问题。它可以用来检测用户想要上传的不会覆盖获取原始资源之后做出的更新。如果请求的条件不满足，那么需要返回 412（Precondition Failed，先决条件失败）响应。

| 属性               | 值     |
| :----------------- | ------ |
| 首部类型           | 请求头 |
| 禁止修改的消息首部 | 否     |

**语法**

```http
If-Match: <etag_value>
If-Match: <etag_value>, <etag_value>, …
If-Match: *
```

**指令**

- **<etag_value>：**<font color=FF0000>唯一地表示一份资源的实体标签</font>。标签是由 ASCII 字符组成的字符串，用双引号括起来（如 "675af34563dc-tr34"）。前面可以加上 W/ 前缀表示应该采用弱比较算法。
- ***：**星号是一个特殊值，可以指代任意资源。

**示例**

```http
If-Match: "bfc13a64729c4290ef5b2c2730249c88ca92d82d"
If-Match: W/"67ab43", "54ed21", "7892dd"
If-Match: *
```

摘自：[MDN - If-Match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match)

#### If-None-Match

If-None-Match 是一个条件式请求首部。<font color=FF0000>对于 GET 和 HEAD 请求方法来说，**当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端才会返回所请求的资源**，响应码为 200</font>。对于<mark>其他方法</mark>来说，<mark>**当且仅当** 最终 **确认没有已存在的资源的 ETag 属性值** 与这个首部中所列出的 **相匹配** 的时候，才会对请求进行相应的处理</mark>。

<mark style="background: aqua">对于  GET 和 HEAD 方法来说，当验证失败的时候，服务器端必须返回响应码 304 （Not Modified，未改变）</mark>。对于能够引发服务器状态改变的方法，则返回 412 （Precondition Failed，前置条件失败）。需要注意的是，服务器端在生成状态码为 304 的响应的时候，必须同时生成以下会存在于对应的 200 响应中的首部：Cache-Control、Content-Location、Date、ETag、Expires 和 Vary 。

<font color=FF0000>ETag 属性之间的比较采用的是弱比较算法，即两个文件不必逐个字节相同</font>（**注：**<mark>这里MDN 中文版本感觉有问题，参考了英文版感觉应该翻译错了</mark>），<font color=FF0000>内容一致也可以认为是相同的</font>。例如，如果两个页面仅仅在页脚的生成时间有所不同，就可以认为二者是相同的。

当<font color=FF0000>与  If-Modified-Since  一同使用的时候，If-None-Match 优先级更高</font>（假如服务器支持的话）。

**以下是两个常见的应用场景：**

- 采用 GET 或 HEAD  方法，来更新拥有特定的ETag 属性值的缓存。
- 采用其他方法，尤其是  PUT，将 If-None-Match used 的值设置为 * ，用来生成事先并不知道是否存在的文件，可以确保先前并没有进行过类似的上传操作，防止之前操作数据的丢失。这个问题属于更新丢失问题的一种。

| 属性               | 值       |
| :----------------- | -------- |
| 首部类型           | 请求首部 |
| 禁止修改的消息首部 | 否       |

**语法**

```http
If-None-Match: <etag_value>
If-None-Match: <etag_value>, <etag_value>, …
If-None-Match: *
```

指令

- **<etag_value>：**唯一地表示所请求资源的实体标签。形式是采用双引号括起来的由 ASCII 字符串（如"675af34563dc-tr34"），有可能包含一个 W/ 前缀，来提示应该采用弱比较算法（这个是画蛇添足，因为 <font color=FF0000>If-None-Match 用且仅用这一算法</font>（**注：**这里表示：<font color=FF0000>If-None-Match 只有弱比较</font>））。
- ***：**星号是一个特殊值，可以代表任意资源。它只用在进行资源上传时，通常是采用 PUT 方法，来检测拥有相同识别ID的资源是否已经上传过了。

摘自：[MDN - If-None-Match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match)

#### If-Modified-Since

If-Modified-Since 是一个 **条件式请求首部**，<font color=FF0000>服务器只在所请求的 **资源在给定的日期时间 之后 对内容进行过修改的情况下才会将资源返回**</font>，状态码为 200  。<mark>如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的  304  响应</mark>，而<mark>在 Last-Modified 首部中会带有上次修改时间</mark>。 不同于  If-Unmodified-Since，<font color=FF0000>**If-Modified-Since 只可以用在 GET 或 HEAD 请求中**</font>。

<mark>当与 If-None-Match 一同出现时，它（If-Modified-Since）会被忽略掉</mark>，除非服务器不支持 If-None-Match。（**注：**这个说法 [[#If-None-Match]]中也有提及。另外，这个规则可以理解为：有 ETag 的 优先级更高）

<font color=FF0000>最常见的应用场景是来 **更新没有特定 ETag 标签的缓存实体**</font>。

| 属性               | 值       |
| :----------------- | -------- |
| 首部类型           | 请求首部 |
| 禁止修改的消息首部 | 否       |

**语法：**

```http
If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
```

**指令：**注，可选配置和一样 [[#If-Range]] 一样，这里略。

摘自：[MDN - If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since)

#### If-Unmodified-Since

HTTP协议中的 If-Unmodified-Since 消息头用于请求之中，使得当前请求成为<font color=FF0000>条件式请求</font>：<font color=FF0000>只有当资源 **在指定的时间之后没有进行过修改** 的情况下，服务器**才会返回请求的资源**</font>，或是接受 POST 或其他 “不安全的” 方法的请求。<mark>如果所请求的资源在指定的时间之后发生了修改，那么会返回 412 (Precondition Failed) 错误</mark>。

**常见的应用场景有两种：**

- 与 “不安全的” 方法如 POST 搭配使用，可以用来优化并发控制，例如在某些wiki应用中的做法：假如在原始副本获取之后，服务器上所存储的文档已经被修改，那么对其作出的编辑会被拒绝提交。
- 与含有 If-Range 消息头的范围请求搭配使用，用来确保新的请求片段来自于未经修改的文档。

| 属性               | 值       |
| :----------------- | -------- |
| 首部类型           | 请求首部 |
| 禁止修改的消息首部 | 否       |

**语法**

```http
If-Unmodified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
```

**指令：**注，可选配置和一样 [[#If-Range]] 一样，这里略。

摘自：[MDN - If-Unmodified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since)

#### Last-Modified

The Last-Modified  是一个响应首部，其中<font color=FF0000>包含源头服务器认定的资源做出修改的日期及时间</font>。 <mark style="background: aqua">它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致</mark>。<mark>由于精确度比  ETag 要低，所以这是一个备用机制</mark>。<font color=FF0000>包含有  If-Modified-Since 或 If-Unmodified-Since 首部的条件请求会使用这个字段</font>。

| 属性                               | 值       |
| :--------------------------------- | -------- |
| 首部类型                           | 响应首部 |
| 禁止修改的消息首部                 | 否       |
| CORS安全列表的响应头（简单响应头[[#Access-Control-Allow-Headers]] 以及 [[现代 JavaScript 教程 阅读笔记#对于简单请求]] 都有提及） | 是       |

**语法**

```http
Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
```

**指令：**注，可选配置和一样 [[#If-Range]] 一样，这里略。

摘自：[MDN - Last-Modified](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified)

#### Cache-Control

 Cache-Control 通用消息头字段，<font color=FF0000>被用于在 http请求 和 响应中，通过 **指定指令来 <font size=4>实现缓存机制</font>**</font>。<font color=FF0000>**缓存指令是 <font size=4>单向</font> 的**，这意味着在请求中设置的指令，不一定被包含在响应中</font>（注：也就是说：指令内容，不会原样返回）。

| 属性                                     | 值       |
| :--------------------------------------- | -------- |
| 首部类型                                 | 通用首部 |
| 禁止修改的消息首部                       | 否       |
| 简单请求响应头（ CORS安全列表的响应头 ） | 是       |

**指令格式具有以下有效规则：**

- 不区分大小写，但建议使用小写。
- 多个指令以逗号分隔。
- 具有可选参数，可以用令牌或者带引号的字符串语法。

**指令按照 “请求/响应” 分类**

**注：**部分指令是：**既可以在<font color=FF0000>请求</font>中使用，也可以在<font color=FF0000>响应</font>中使用**。另外，下面的分类似乎没有 [MDN  - Cache-Control - Cache directives](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control#cache_directives) 直观

- **缓存<font color=FF0000>请求</font>指令：**客户端可以在 HTTP <font color=FF0000>**请求中使用**</font> 的标准 Cache-Control 指令。

  ```http
  Cache-Control: max-age=<seconds>
  Cache-Control: max-stale[=<seconds>]
  Cache-Control: min-fresh=<seconds>
  Cache-control: no-cache
  Cache-control: no-store
  Cache-control: no-transform
  Cache-control: only-if-cached
  ```

- **缓存<font color=FF0000>响应</font>指令：**服务器可以在 <font color=FF0000>**响应中使用**</font> 的标准 Cache-Control 指令。

  ```http
  Cache-control: must-revalidate
  Cache-control: no-cache
  Cache-control: no-store
  Cache-control: no-transform
  Cache-control: public
  Cache-control: private
  Cache-control: proxy-revalidate
  Cache-Control: max-age=<seconds>
  Cache-control: s-maxage=<seconds>
  ```

-  **<font color=FF0000>扩展</font> Cache-Control 指令：**拓展缓存指令 <font color=FF0000>不是核心 HTTP缓存标准文档的一部分</font>，使用前请注意检查 [兼容性](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control#浏览器兼容性)！

  ```http
  Cache-control: immutable
  Cache-control: stale-while-revalidate=<seconds>
  Cache-control: stale-if-error=<seconds>
  ```

##### 指令按照 “用途” 分类

- **协商缓存验证**

  - **public：**表明<font color=FF0000>响应可以被任何对象</font>（包括：发送请求的客户端，代理服务器，等等）<font color=FF0000>缓存</font>，<font color=FF0000>即使是通常不可缓存的内容</font>。例如：

    - 该响应没有 max-age 指令或 Expires 消息头

    - 该响应对应的请求方法是 [POST](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST) 。

  - **private：**表明 <font color=FF0000>响应**只能被单个用户缓存**</font>，<font color=FF0000>不能作为共享缓存（即 **代理服务器不能缓存它**）</font>。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。

  - **no-cache：**<font color=FF0000>在发布缓存副本之前，强制要求 缓存把请求提交给原始服务器进行验证</font>（协商缓存验证）。这里 MDN 中文讲的有点看不懂，看下英文版：

    > The no-cache <font color=FF0000>response directive</font> indicates that <font color=FF0000>the response can be stored in caches</font>, <font color=FF0000>but the response **must be validated with the origin server before each reuse**</font>, <mark>even when the cache is disconnected from the origin server</mark>.
    >
    > 摘自：[MDN - Cache-Control(en-US)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)

  - **no-store：**<font color=FF0000>缓存 **不应存储** 有关客户端请求或服务器响应的任何内容</font>，即<font color=FF0000 size=4>**不使用任何缓存**</font>。

- **到期**

  - **max-age=\<seconds>：**<font color=FF0000>设置缓存存储的最大周期</font>，<font color=FF0000>超过这个时间缓存被认为过期</font>（单位秒）。与 Expires 相反，<font color=FF0000>时间是 **相对于请求的时间**</font>。

  - **s-maxage=\<seconds>：**<font color=FF0000>覆盖 max-age 或者 Expires头</font>，但是<font color=FF0000>**仅适用于共享缓存 ( SharedCache )**（比如各个代理），**私有缓存 ( private cache ) 会忽略它**</font>。**注：**根据讲述，这里的 s-maxage 表示 shared。

  - **max-stale[=\<seconds>]：**<font color=FF0000>表明 客户端愿意接收一个已经过期的资源</font>。可以设置一个 <font color=FF0000>**可选**</font> 的秒数，表示 响应不能已经过时超过该给定的时间。**注：**自我理解：如果资源过期时间不超过 max-stale-seconds，则依然接收；否则，拒收

    > Clients can <mark>use this header when the origin **server is down or too slow**</mark> and can accept cached responses from caches even if they are a bit old.
    >
    > Note that <mark>the **major browsers do not support** requests with `max-stale`</mark>.

  - **min-fresh=\<seconds>：**表示<font color=FF0000>客户端希望获取一个能在指定的秒数内保持其最新状态的响应</font>。

    **注：**个人理解：浏览器希望 接受 一个 在未来 min-fresh-seconds 秒内 未过期 ( non-stale / fresh ) 的 请求（资源）。这里说的不清楚，英文版如下：

    > The `min-fresh=N` request directive indicates that the client allows a stored response that is [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness) for at least *N* seconds.
    >
    > ```http
    > Cache-Control: min-fresh=600
    > ```
    >
    > <mark>In the case above, if the response with</mark> `Cache-Control: max-age=3600` <mark>was stored in caches 51 minutes ago, the cache couldn't reuse that response</mark>. **注：**因为已经过去了 51min，再过 9min 资源将过期，而 min-fresh 时间是 10min ( 600ms )
    >
    > Clients can use this header when the user requires the response to not only be [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness), <font color=FF0000>but also requires that it won't be updated for a period of time</font>. **注：**除了资源不会过期外，还需要该资源在 min-fresh-seconds 时间内不会更改。
    >
    > Note that <mark>the **major browsers do not support** requests with `min-fresh`</mark>.

  - **stale-while-revalidate=\<seconds>：**表明<font color=FF0000>客户端愿意接受陈旧的响应，**同时在后台异步检查新的响应**</font>。<font color=FF0000>**秒值指示客户愿意接受 陈旧响应的时间长度**</font>。

    > The `stale-while-revalidate` response directive indicates that the cache could reuse a stale response while it revalidates it to a cache.
    >
    > ```http
    > Cache-Control: max-age=604800, stale-while-revalidate=86400
    > ```
    >
    > In the example above, the response is [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness) for 7 days (604800s). After 7 days it becomes [stale](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness), <font color=FF0000>but the cache is allowed to reuse it for any requests that are made in the following day (86400s), **provided that they revalidate the response in the background**</font>.
    >
    > <font color=FF0000 size=4>**Revalidation will make the cache be [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness) again**</font>, so <font color=FF0000>it appears to clients that it was always [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness) during that period</font> — effectively hiding the latency penalty of revalidation from them.
    >
    > <font color=FF0000>If no request happened during that period, the cache became [stale](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness) and the next request will revalidate normally</font>.

  - **stale-if-error=\<seconds>：**表示如果新的检查失败（注：根据英文版，这里的意思是服务器响应码为 50* ），则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。

    > The `stale-if-error` response directive indicates that the cache can reuse a [stale response](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness) <font color=FF0000>when an origin server responds with an error (500, 502, 503, or 504)</font>.
    >
    > ```http
    > Cache-Control: max-age=604800, stale-if-error=86400
    > ```
    >
    > In the example above, the response is [fresh](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness) for 7 days (604800s). After 7 days it becomes [stale](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness), but <font color=FF0000>it can be used for an extra 1 day (86400s) if the server responds with an error</font>.
    >
    > <font color=FF0000>After a period of time, the stored response became [stale](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#freshness) normally</font>. This means that the client will receive an error response as-is if the origin server sends it.

- **重新验证和重新加载** （**注：**这里都是响应指令）
  - **must-revalidate：**一旦资源过期（比如已经超过 max-age ），<font color=FF0000>在成功向原始服务器验证之前，缓存不能用该资源响应后续请求</font>
  - **proxy-revalidate：**与 must-revalidate 作用相同，但它<font color=FF0000>仅适用于共享缓存（例如代理），并被私有缓存忽略</font>（**注：**proxy 和 private cache 冲突）。
  - **immutable：**表示<font color=FF0000>响应正文不会随时间而改变</font>。<font color=FF0000>**资源（如果未过期）在服务器上不发生改变**</font>，因此<font color=FF0000>**客户端不应发送重新验证请求头（例如 If-None-Match 或 If-Modified-Since ）来检查更新**，即使用户显式地刷新页面</font>。

- **其他**

  - **no-transform：**<font color=FF0000>不得对资源进行转换或转变</font>。Content-Encoding、Content-Range、Content-Type等HTTP头不能由代理修改。例如，<mark>非透明代理或者如 Google's Light Mode 可能对图像格式进行转换，以便节省缓存空间或者减少缓慢链路上的流量</mark>。<font color=FF0000>no-transform指令不允许这样做</font>。

  - **only-if-cached：**表明<font color=FF0000>客户端只接受已缓存的响应</font>，并且<font color=FF0000>**不要向原始服务器检查是否有更新的拷贝**</font>。

摘自：[MDN - Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)



#### Access-Control-Request-Method

请求头  Access-Control-Request-Method <font color=FF0000> 出现于 preflight request （预检请求）中</font>，用于<font color=FF0000> 通知服务器在真正的请求中会采用哪种  HTTP 方法</font>。因为预检请求所使用的方法总是 OPTIONS ，与实际请求所使用的方法不一样，所以这个请求头是必要的。

| 属性         | 值     |
| ------------ | ------ |
| http头种类   | 请求头 |
| 禁用首部名称 | 是     |

语法

```http
Access-Control-Request-Method: <method>
```

指令

- \<method>：一种 HTTP请求方法 , 例如 GET、POST 或 DELETE。

摘自：[MDN - Access-Control-Request-Method](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Method)

#### Access-Control-Request-Headers

请求头  Access-Control-Request-Headers <font color=FF0000> 出现于 preflight request （预检请求）中，用于通知服务器在真正的请求中会采用哪些请求头</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报头类型     | 请求头 |
| 禁用首部名称 | 是     |

语法

```http
Access-Control-Request-Headers: <header-name>, <header-name>, ...
```

指令

- \<header-name>：在实际请求中将要包含的一系列 HTTP 头，以逗号分隔。

示例

```http
Access-Control-Request-Headers: X-PINGOTHER, Content-Type
```

摘自：[MDN - Access-Control-Request-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Request-Headers)

#### Access-Control-Allow-Methods

响应首部 Access-Control-Allow-Methods 在<font color=FF0000> 对 preflight request（预检请求）的应答中**明确了客户端所要访问的资源允许使用的方法或方法列表**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**

```http
Access-Control-Allow-Methods: <method>, <method>, ...
```

**指令**

- **\<method>：**用逗号隔开的允许使用的 HTTP request methods 列表。

例子

```http
Access-Control-Allow-Methods: POST, GET, OPTIONS
```

摘自：[MDN - Access-Control-Allow-Methods](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Methods)

#### Access-Control-Allow-Headers

响应首部 Access-Control-Allow-Headers <font color=FF0000> 用于 preflight request （预检请求）中，列出了将会在正式请求的 Access-Control-Request-Headers 字段中出现的首部信息</font>。

<font color=FF0000> 简单首部</font>，如 simple headers、Accept、Accept-Language、Content-Language、Content-Type （只限于解析后的值为 application/x-www-form-urlencoded、multipart/form-data 或 text/plain 三种MIME类型（不包括参数）），<font color=FF0000> 它们始终是被支持的，不需要在这个首部特意列出</font>。

<font color=FF0000> 如果请求中含有 Access-Control-Request-Headers 字段，那么这个首部是必要的</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**

```http
Access-Control-Allow-Headers: <header-name>[, <header-name>]*
Access-Control-Allow-Headers: *
```

**指令**

- **\<header-name>：**<font color=FF0000> 可支持的请求首部名字。请求头会列出所有支持的首部列表，用逗号隔开</font>。

  注意以下这些特定的首部是一直允许的：Accept, Accept-Language, Content-Language, Content-Type （但只在其值属于 MIME 类型 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种时）。这些被称作简单首部，你无需特意声明它们。

* **\* (wildcard)：**对于没有凭据的请求（没有HTTP cookie或HTTP认证信息的请求），值“ *”仅作为特殊的通配符值。 在具有凭据的请求中，它被视为没有特殊语义的文字标头名称“ *”。 请注意，Authorization标头不能使用通配符，并且始终需要明确列出。

摘自：[MDN - Access-Control-Allow-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Headers)

#### Access-Control-Max-Age

The Access-Control-Max-Age 这个响应头<font color=FF0000> 表示 preflight request（预检请求）的**返回结果**（即 Access-Control-Allow-Methods 和Access-Control-Allow-Headers 提供的信息） <font size=4>**可以被缓存多久**</font></font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**指令**

- **\<delta-seconds>：**返回结果可以被缓存的最长时间（秒）。
  - 在 Firefox 中，上限是24小时（即 86400 秒）。
  - 在 Chromium v76 之前， 上限是 10 分钟（即 600 秒)。
  - 从 Chromium v76 开始，上限是 2 小时（即 7200 秒)。
  - Chromium 同时规定了一个默认值 5 秒。
  - 如果值为 -1，表示禁用缓存，则每次请求前都需要使用 OPTIONS 预检请求。

**示例**
将预检请求的结果缓存10分钟：

```http
Access-Control-Max-Age: 600 
```

摘自：[MDN - Access-Control-Max-Age](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Max-Age)

#### Access-Control-Allow-Origin

Access-Control-Allow-Origin 响应头<font color=FF0000> 指定了**该响应的资源是否被允许与给定的origin共享**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**

```http
Access-Control-Allow-Origin: *
Access-Control-Allow-Origin: <origin>
```

**指令**

- **\*：**对于不需具备凭证（credentials）的请求，服务器会以“*”作为通配符，从而<font color=FF0000> 允许所有域都具有访问资源的权限</font>。
- **\<origin>：**指定一个可以访问资源的URI。

如果服务器未使用“*”，而是指定了一个域，那么为了向客户端表明服务器的返回会根据Origin请求头而有所不同，必须在Vary响应头中包含Origin。

```http
Access-Control-Allow-Origin: https://developer.mozilla.org
Vary: Origin
```

摘自：[MDN - Access-Control-Allow-Origin](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)

#### Access-Control-Allow-Credentials

Access-Control-Allow-Credentials 响应头<font color=FF0000> 表示是否可以将对请求的响应暴露给页面</font>。<font color=FF0000> 返回true则可以，其他值均不可以</font>。

<font color=FF0000 size=4> **Credentials可以是 cookies, authorization headers 或 TLS client certificates**</font>。

当<font color=FF0000> 作为对预检请求的响应的一部分时，这能表示是否真正的请求可以使用credentials</font>。注意简单的 GET 请求没有预检，所以若一个对资源的请求带了credentials，如果这个响应头没有随资源返回，响应就会被浏览器忽视，不会返回到web内容。

<font color=FF0000 size=4> **Access-Control-Allow-Credentials 头 工作中与 XMLHttpRequest.withCredentials 或 Fetch API中的Request() 构造器中的credentials 选项结合使用**</font>。Credentials <font color=FF0000> **必须在前后端都被配置**</font>（即 the Access-Control-Allow-Credentials header 和 XHR 或Fetch request中都要配置）才能使带 credentials 的 CORS 请求成功。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

**语法**

```http
Access-Control-Allow-Credentials: true
```

**指令**

- **true：**这个头的唯一有效值（区分大小写）。如果不需要credentials，相比将其设为false，请直接忽视这个头。

<font size=4>**例子**</font>

**允许credentials：**

```http
Access-Control-Allow-Credentials: true
```

**使用带credentials的 XHR ：**

```js
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://example.com/', true);
xhr.Credentials = true;
xhr.send(null);
```

**使用带credentials的 Fetch ：**

```js
fetch(url, {
  credentials: 'include'
})
```

摘自：[MDN - Access-Control-Allow-Credentials](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials)

#### Access-Control-Expose-Headers

响应首部 Access-Control-Expose-Headers 列出了哪些首部可以作为响应的一部分暴露给外部。

默认情况下，只有七种 simple response headers （简单响应首部）可以暴露给外部：

- Cache-Control
- Content-Language
- Content-Length
- Content-Type
- Expires
- Last-Modified
- Pragma

如果想要让客户端可以访问到其他的首部信息，可以将它们在 Access-Control-Expose-Headers 里面列出来。注：类似的内容，在[[现代 JavaScript 教程 阅读笔记#对于简单请求]] 中也有提及

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

语法

```http
Access-Control-Expose-Headers: <header-name>, <header-name>, ...
```

指令

- \<header-name>：包含0个或多个除“简单响应首部”之外的首部名称列表，可以暴露给外部，供页面资源使用。

示例

- 想要暴露一个非简单响应首部，可以这样指定：

  ```http
  Access-Control-Expose-Headers: Content-Length
  ```

- 想要额外暴露自定义的首部，例如 X-Kuma-Revision，可以指定多个，用逗号隔开：

  ```http
  Access-Control-Expose-Headers: Content-Length, X-Kuma-Revision
  ```

摘自：[MDN - Access-Control-Expose-Headers](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Expose-Headers)

**注：**这里说起来有点抽象，可以参考 [[现代 JavaScript 教程 阅读笔记#对于简单请求]] 中的内容



#### Proxy-Authorization

Proxy-Authorization 是一个<font color=FF0000> **请求首部**</font>，<font color=FF0000> 其中包含了**用户代理提供给<font size=4>代理服务器</font>**的**用于身份验证的凭证**</font>。<font color=FF0000> 这个首部通常是在服务器返回了 407 Proxy Authentication Required 响应状态码及 **Proxy-Authenticate 首部 <font size=4>后</font> 发送**的</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 请求头 |
| 禁用首部名称 | 否     |

语法

```http
Proxy-Authorization: <type> <credentials>
```

指令

- **\<type>：**<font color=FF0000> 身份验证类型</font>。一个常见的类型是 "基本验证"（basic authentication）。IANA 机构维护了[ 一系列的身份验证机制](https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml)。除了基本验证 之外，还有：digest认证、SSL客户端认证、基于表单认证

- **\<credentials>：**凭证的构成方式如下：

  - <mark>将用户名和密码用冒号拼接（aladdin:opensesame）</mark>。
  - 将拼接生成的字符串使用 base64 编码方式进行编码（YWxhZGRpbjpvcGVuc2VzYW1l）。

  <font color=FF0000> **注意：**</font> Base64 编码方式不是用来加密或者获取摘要的！这种方法的安全性相当于将凭证使用明文发送（base64 是一种可逆编码方式）。在使用基本身份验证方式的时候推荐与 HTTPS 搭配使用。

示例

```http
Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

摘自：[MDN - Proxy-Authorization](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authorization)

#### Proxy-Authenticate

The HTTP Proxy-Authenticate 是一个<font color=FF0000> **响应首部**</font>，<font color=FF0000>指定了**获取 代理服务器 上的资源访问权限而采用的身份验证方式**</font>。<font color=FF0000> 代理服务器对请求进行验证，以便它进一步传递请求</font>。

<font color=FF0000> Proxy-Authenticate 首部需要与 407 Proxy Authentication Required 响应一起发送</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

语法

```http
Proxy-Authenticate: <type> realm=<realm>
```

指令

- **\<type>：**身份验证类型。一个常见的类型是 "基本验证"。IANA 机构维护了 一系列的身份验证机制（详情见上面的Proxy-Authorization）。
- **realm=\<realm>：**<font color=FF0000> 对于被保护区域（即安全域）的描述</font>。<mark>如果没有指定安全域，客户端通常用一个格式化的主机名来代替</mark>。

示例

```http
Proxy-Authenticate: Basic
Proxy-Authenticate: Basic realm="Access to the internal site"
```

摘自：[MDN - Proxy-Authenticate](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Proxy-Authenticate)

#### Authorization

HTTP 协议中的 Authorization <font color=FF0000>**请求消息头**</font>，<font color=FF0000>含有服务器 **用于验证用户代理身份的 <font size=4>*凭证* ( credentials ) </font>**，通常会在服务器返回 401 Unauthorized 状态码，以及 WWW-Authenticate 消息头之后在后续请求中发送此消息头</font>。

> **注：**关于 Authorization 的使用场景，也可以参考：[现代 JS 教程 - fetch - credentials](https://zh.javascript.info/fetch-api#credentials)

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 请求头 |
| 禁用首部名称 | 否     |

##### 语法

```http
Authorization: <type> <credentials>
```

##### 指令

- **\<type>：**<font color=FF0000>验证类型</font>。 常见的是 “基本验证 ( Basic ) ”。其他类型包括：在 IANA 机构注册的验证方案， AWS 服务器的验证方案 ( AWS4-HMAC-SHA256 )
- **\<credentials>：**如果使用 “基本验证”方案，凭证通过如下步骤生成：
  - 用冒号将用户名和密码进行拼接（如：aladdin:opensesame ）。
  - 将第一步生成的结果用 base64 方式编码 ( YWxhZGRpbjpvcGVuc2VzYW1l )

##### 示例

```http
Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```

摘自：[MDN - Authorization](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authorization)

#### WWW-Authenticate

HTTP WWW-Authenticate 响应头<font color=FF0000> 定义了使用何种验证方式（ Basic、digest、SSL 客户端、FormBase ）去获取对资源的连接</font>。

WWW-Authenticate header<font color=FF0000> **通常会和一个 401 Unauthorized 的响应一同被发送**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

##### 语法

```http
WWW-Authenticate: <type> realm=<realm>
```

##### 指令

- **\<type>：**Authentication type，一个通用类型 "Basic"。 IANA 维护了一个 list of Authentication schemes。
- **realm=\<realm>：**一个保护区域的描述。如果未指定 realm，客户端通常显示一个格式化的主机名来替代。
- **charset=\<charset>：**<font color=FF0000> 当提交用户名和密码时，告知客户端服务器首选的**编码方案**</font>。唯一的允许值是不区分大小写的字符串 "UTF-8" 。这与 realm 字符串的编码无关。

##### 示例

通常的，一个服务器响应包含一个像如下 WWW-Authenticate 的头信息：

```http
WWW-Authenticate: Basic
WWW-Authenticate: Basic realm="Access to the staging site"
```

摘自：[MDN - WWW-Authenticate](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/WWW-Authenticate)



#### Accept

Accept 请求头 <font color=FF0000>用来 **告知（服务器）客户端可以处理的 内容类型**</font>，这种内容类型用 MIME类型 来表示。借助内容协商机制，<font color=FF0000>服务器</font>可以从诸多备选项中选择一项进行应用，并<font color=FF0000>使用 Content-Type 应答头通知客户端它的选择</font>。浏览器会基于请求的上下文来为这个请求头设置合适的值，比如获取一个CSS层叠样式表时值与获取图片、视频或脚本文件时的值是不同的。

| 属性               | 值       |
| :----------------- | -------- |
| 首部类型           | 请求首部 |
| 禁止修改的消息首部 | 否       |
| 简单头部           | 是       |

**语法**

```http
Accept: <MIME_type>/<MIME_subtype>
Accept: <MIME_type>/*
Accept: */*
// Multiple types, weighted with the quality value syntax:
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

**指令**

- **\<MIME_type>/<MIME_subtype>：**<font color=FF0000>**单一精确的 MIME 类型**，例如text/html</font>
- **<MIME_type>/*：**<font color=FF0000>**一类 MIME 类型，但是没有指明子类**</font>。 image/* 可以用来指代 image/png, image/svg, image/gif 以及任何其他的图片类型。
- **\*/*：**任意类型的 MIME 类型
- **;q= （q因子权重）：**值代表优先顺序，用相对[质量价值](https://developer.mozilla.org/en-US/docs/Glossary/Quality_values)表示，又称作权重。

示例

```http
Accept: text/html
Accept: image/*
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

摘自：[MDN - Accept](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept)

#### Content-Type

Content-Type 实体头部<font color=FF0000>用于指示资源的MIME类型 media type </font>。

在响应中，Content-Type 标头<font color=FF0000>告诉客户端实际返回的内容的内容类型</font>。浏览器会在某些情况下进行 MIME 查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff 。**注：**关于 X-Content-Type-Options 见 [[#X-Content-Type-Options]]

| 属性         | 值       |
| ------------ | -------- |
| 报文类型     | 实体报头 |
| 禁用首部名称 | 不是     |
| 简易响应头   | 是       |

- **句法：**

  ```http
  Content-Type: text/html; charset=utf-8
  Content-Type: multipart/form-data; boundary=something
  ```

- **指令：**

  - **media-type：**<font color=FF0000>资源或数据的 MIME type</font> 。如：上面的 text/html
  - **charset：**<font color=FF0000>字符编码标准</font>。如：上面的 charset=utf-8
  - **boundary：**<font color=FF0000>对于多部分实体，boundary 是必需的</font>，其包括来自一组字符的1到70个字符，已知通过电子邮件网关是非常健壮的，而不是以空白结尾。它用于封装消息的多个部分的边界。

摘自：[MDN - Content-Type](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)



#### Content-Length

Content-Length 是一个实体消息首部，<font color=FF0000>用来**指明发送给接收方的消息主体的大小**</font>，即<font color=FF0000>用十进制数字表示的八位元组的数目（**即字节 bit 的数目**）</font>。

| 属性         | 值       |
| ------------ | -------- |
| 报文类型     | 实体报头 |
| 禁用首部名称 | 是       |

**语法：**

```http
Content-Length: <length>
```

摘自：[MDN - Content-Length](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length)



#### HTTP cookies

HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie ）<font color=FF0000>是 <font size=4>**服务器发送到用户浏览器**</font></font>（**注：**这点事一定要记牢！<font color=FF0000 size=4>**Cookie 是 服务器生成，并发给浏览器的**</font> ）<font color=FF0000>并保存在本地的一小块数据</font>，<font color=FF0000>它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</font>。<mark style=background-color:hotpink>通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态</mark>。<font color=FF0000>Cookie 使 <font size=4>**基于无状态的 HTTP 协议**</font> 记录稳定的状态信息成为了可能</font>

##### Cookie 主要用于以下三个方面

- <font color=FF0000>会话状态管理</font>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- <font color=FF0000>个性化设置</font>（如用户自定义设置、主题等）
- <font color=FF0000>浏览器行为跟踪</font>（如跟踪分析用户行为等）

##### 创建Cookie

<font color=FF0000>当服务器收到 HTTP 请求时，**服务器可以在响应头里面添加一个 Set-Cookie 选项**</font>。<font color=FF0000>浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过  Cookie 请求头部将 Cookie 信息发送给服务器</font>。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

##### Set-Cookie 响应头部和 Cookie 请求头部

<font color=FF0000 size=4>**服务器使用 Set-Cookie 响应头部向用户代理（一般是浏览器）发送 Cookie信息**</font>。一个简单的 Cookie 可能像这样：

```http
Set-Cookie: <cookie名>=<cookie值>
```

<font color=FF0000>服务器通过该头部告知客户端保存 Cookie 信息</font>。

```http
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[页面内容]
```

<font color=FF0000>**现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 Cookie 请求头部再发送给服务器**</font>。

```http
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

##### 定义 Cookie 的生命周期

Cookie 的生命周期可以通过<font color=FF0000>**两种方式定义**</font>：

- **会话期 Cookie 是最简单的 Cookie：**<font color=FF0000>浏览器关闭之后它会被自动删除</font>，<font color=FF0000>也就是说它仅在会话期内有效</font>。<font color=FF0000>会话期Cookie**不需要指定过期时间（Expires）或者有效期（Max-Age）**</font>。<mark>需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长</mark>。
- **持久性 Cookie** 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。

例如：

```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

<mark>如果您的站点对用户进行身份验证，则每当用户进行身份验证时</mark>，<font color=FF0000>它都应重新生成并重新发送会话 Cookie，甚至是已经存在的会话 Cookie</font>。<mark>此技术有助于防止会话固定攻击（session fixation attacks），在该攻击中第三方可以重用用户的会话</mark>。

##### 限制访问 Cookie

<font color=FF0000>有两种方法可以确保 Cookie 被安全发送</font>，并且不会被意外的参与者或脚本访问：<font color=FF0000>**Secure 属性和HttpOnly 属性**</font>。

- <font color=FF0000>**标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端**</font>，因此可以预防 man-in-the-middle 攻击者的攻击。<font color=FF0000>但**即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输**</font>，<mark style=background-color:hotpink>因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它</mark>。

- <font color=FF0000>JavaScript Document.cookie API 无法访问带有 HttpOnly 属性的 Cookie</font>；<font color=FF0000>此类 Cookie 仅作用于服务器</font>。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性。此预防措施有助于缓解跨站点脚本 ( XSS ) 攻击。

**Cookie 的作用域**

<font color=FF0000>Domain 和 Path 标识定义了Cookie 的作用域：**即允许 Cookie 应该发送给哪些 URL**</font>。

- **Domain 属性：**<font color=FF0000>**Domain 指定了哪些主机可以接受 Cookie**</font>。<font color=FF0000>如果不指定，默认为 origin，不包含子域名</font>。<font color=FF0000>如果指定了 Domain，则一般包含子域名</font>。<mark style=background-color:hotpink>因此，指定 Domain 比省略它的限制要少</mark>。但是，当子域需要共享有关用户的信息时，这可能会有所帮助。 

  例如，如果设置 Domain=mozilla.org ，则 Cookie 也包含在子域名中（如 developer.mozilla.org ）。

- **Path 属性：**<font color=FF0000>**Path 标识指定了主机下的<font size=4>哪些路径</font>可以接受 Cookie**</font>（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。
  <mark style=background-color:hotpink>例如，设置 Path=/docs，则以下地址都会匹配：</mark>

  ```
  /docs
  /docs/Web/
  /docs/Web/HTTP
  ```

##### SameSite attribute

SameSite Cookie 允许服务器要求<font color=FF0000>某个 cookie 在**跨站请求**时不会被发送</font>，（其中Site由可注册域定义），<mark style=background-color:hotpink>从而可以阻止跨站请求伪造攻击（CSRF）</mark>。

SameSite cookies 是相对较新的一个字段，所有主流浏览器都已经得到支持。下面是例子：

```http
Set-Cookie: key=value; SameSite=Strict
```

**SameSite 可以有下面三种值：**

- **None：**<font color=FF0000>浏览器会在同站请求、跨站请求下继续发送 cookies</font>，不区分大小写。
- **Strict：**<font color=FF0000>浏览器将只在**访问相同站点**时发送 cookie</font>。（在原有 Cookies 的限制条件上的加强）
- **Lax：**<font color=FF0000>与 Strict 类似</font>，<font color=FF0000>但**用户从外部站点导航至URL时（例如通过链接）除外**</font>。 <font color=FF0000>**在新版本浏览器中，为默认选项**</font>，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到URL时才会发送。如 link 链接

##### Cookie prefixes

<font color=FF0000>cookie 机制的使得服务器无法确认 cookie 是在安全来源上设置的，甚至无法确定 cookie 最初是在哪里设置的</font>。

子域上的易受攻击的应用程序可以使用 Domain 属性设置 cookie，从而可以访问所有其他子域上的该 cookie。会话固定攻击中可能会滥用此机制。有关主要缓解方法，请参阅会话劫持（ session fixation）。

**但是，作为深度防御措施，可以使用 cookie 前缀来断言有关 cookie 的特定事实**。有两个前缀可用：

- **\_\_Host-：**如果 cookie 名称具有此前缀，则仅当它也用 Secure 属性标记，是从安全来源发送的，不包括 Domain 属性，并将 Path 属性设置为 / 时，它才在 Set-Cookie 标头中接受。这样，这些 cookie 可以被视为 "domain-locked”。
- **\_\_Secure-：**如果 cookie 名称具有此前缀，则仅当它也用 Secure 属性标记，是从安全来源发送的，它才在 Set-Cookie 标头中接受。该前缀限制要弱于 \__Host- 前缀。
  带有这些前缀点 Cookie， 如果不符合其限制的会被浏览器拒绝。请注意，这确保了如果子域要创建带有前缀的 cookie，那么它将要么局限于该子域，要么被完全忽略。由于应用服务器仅在确定用户是否已通过身份验证或 CSRF 令牌正确时才检查特定的 cookie 名称，因此，这有效地充当了针对会话劫持的防御措施。

> 前缀示例如下：
>
> ```http
> # cookie 前缀（<cookie-prefix>），值可能性为 __Secure-、__Host-
> Set-Cookie: <cookie-prefix><cookie-name>=<cookie-value>
> ```
>
> 摘自：[Cookie 从入门到进阶：一文彻底弄懂其原理以及应用](https://mp.weixin.qq.com/s/ljZ51xJZvG-8mx0CvU7vVA)

##### 安全

信息被存在 Cookie 中时，需要明白 cookie 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 JSON Web Tokens 之类的替代身份验证/机密机制。

<font color=FF0000>**当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息**</font>。

**缓解涉及Cookie的攻击的方法：**

- <font color=FF0000>使用 HttpOnly 属性</font>可防止通过 JavaScript 访问 cookie 值。
- <font color=FF0000>用于敏感信息（例如指示身份验证）的 Cookie 的生存期应较短</font>，<font color=FF0000>并且 SameSite 属性设置为Strict 或 Lax</font>。在支持 SameSite 的浏览器中，这样做的作用是确保不与跨域请求一起发送身份验证 cookie，因此，这种请求实际上不会向应用服务器进行身份验证。

摘自：[MDN - HTTP cookies](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)

#### Set-Cookie

<font color=FF0000>响应首部 Set-Cookie **被用来由服务器端向客户端发送 cookie**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 是     |

##### 语法

```http
Set-Cookie: <cookie-name>=<cookie-value>
Set-Cookie: <cookie-name>=<cookie-value>; Expires=<date>
Set-Cookie: <cookie-name>=<cookie-value>; Max-Age=<non-zero-digit>
Set-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>
Set-Cookie: <cookie-name>=<cookie-value>; Path=<path-value>
Set-Cookie: <cookie-name>=<cookie-value>; Secure
Set-Cookie: <cookie-name>=<cookie-value>; HttpOnly

Set-Cookie: <cookie-name>=<cookie-value>; SameSite=Strict
Set-Cookie: <cookie-name>=<cookie-value>; SameSite=Lax

// Multiple directives are also possible, for example:
Set-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>; Secure; HttpOnly
```

##### 指令

- **\<cookie-name>=\<cookie-value>：**<font color=FF0000>一个 cookie 开始于一个名称/值对</font>：
  - **\<cookie-name>：** <mark style=background-color:hotpink>可以是除了控制字符 (CTLs)、空格 (spaces) 或制表符 (tab)之外的任何 US-ASCII 字符</mark>。同时不能包含以下分隔字符： ( ) < > @ , ; : \ " /  [ ] ? = { }.
  - **\<cookie-value>：** <mark style=background-color:hotpink>是可选的</mark>，<font color=FF0000>如果存在的话，那么需要包含在双引号里面</font>。支持除了控制字符（CTLs）、空格（whitespace）、双引号（double quotes）、逗号（comma）、分号（semicolon）以及反斜线（backslash）之外的任意 US-ASCII 字符。关于编码：许多应用会对 cookie 值按照 URL编码（URL encoding）规则进行编码，但是按照 RFC 规范，这不是必须的。不过满足规范中对于 \<cookie-value> 所允许使用的字符的要求是有用的。
  - **\_\_Secure- 前缀：**<font color=FF0000>以 \_\_Secure- 为前缀的 cookie（其中连接符是前缀的一部分），必须与 secure 属性一同设置</font>，同时必须应用于安全页面（即使用 HTTPS 访问的页面）。
  - **\_\_Host- 前缀：**<font color=FF0000>以 __Host- 为前缀的 cookie，必须与 secure 属性一同设置</font>，必须应用于安全页面（即使用 HTTPS 访问的页面），<font color=FF0000>必须不能设置 domain 属性 （也就不会发送给子域），同时 path 属性的值必须为“/”</font>。
  
- **Expires=\<date>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>cookie 的最长有效时间</font>，<font color=FF0000>形式为符合 HTTP-date 规范的时间戳</font>。参考 Date 可以获取详细信息。

  <font color=FF0000>如果没有设置这个属性，那么表示这是一个会话期 cookie</font>（**注：**即 session cookie，一次会话后就会销毁）；一个会话结束于客户端被关闭时，这意味着会话期 cookie 在彼时会被移除。

  然而，很多 Web 浏览器支持会话恢复功能，这个功能可以使浏览器保留所有的 tab 标签，然后在重新打开浏览器的时候将其还原。与此同时，cookie 也会恢复，就跟从来没有关闭浏览器一样。

- **Max-Age=\<non-zero-digit>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>在 cookie 失效之前需要经过的秒数</font>。<font color=FF0000>**秒数为 0 或 -1 将会使 cookie 直接过期**</font>。一些老的浏览器（ie6、ie7 和 ie8）不支持这个属性。对于其他浏览器来说，<font color=FF0000>假如二者 （指 Expires 和Max-Age） 均存在，那么 **Max-Age 优先级更高**</font>。

- **Domain=\<domain-value>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>指定 cookie 可以送达的主机名</font>。<font color=FF0000>假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）</font>。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。

- **Path=\<path-value>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部</font>。字符  %x2F ("/") 可以解释为文件目录分隔符，此目录的下级目录也满足匹配的条件（例如，如果 path=/docs，那么 "/docs", "/docs/Web/" 或者 "/docs/Web/HTTP" 都满足匹配的条件）。

- **Secure：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>一个带有安全属性的 cookie 只有在请求使用SSL和HTTPS协议的时候才会被发送到服务器</font>。然而，<mark style=background-color:hotpink>保密或敏感信息永远不要在 HTTP cookie 中存储或传输，因为整个机制从本质上来说都是不安全的</mark>，比如前述协议并不意味着所有的信息都是经过加密的。
  注意：非安全站点（http:）已经不能再在 cookie 中设置 secure 指令了（在Chrome 52+ and Firefox 52+ 中新引入的限制）。

- **HttpOnly：**<mark style=background-color:hotpink>可选</mark>，设置了 <font color=FF0000>HttpOnly 属性的 cookie 不能使用 JavaScript 经由  Document.cookie 属性、XMLHttpRequest 和  Request APIs 进行访问，以防范跨站脚本攻击</font>。

- **SameSite=Strict / Lax：** <mark style=background-color:hotpink>可选</mark>，🧪 <font color=FF0000>允许服务器设定一则 cookie **不随着跨域请求一起发送**</font>，这样可以在一定程度上防范跨站请求伪造攻击（CSRF）。

摘自：[MDN - Set-Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)

#### Cookie

Cookie <font color=FF0000>是一个请求首部</font>，<font color=FF0000>**其中含有先前由服务器通过 Set-Cookie  首部投放并存储到客户端的 HTTP cookies**</font>。
这个首部<font color=FF0000>可能会被完全移除</font>，<mark>例如在浏览器的隐私设置里面设置为禁用cookie</mark>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 请求头 |
| 禁用首部名称 | 是     |

**语法**

```http
Cookie: <cookie-list>
Cookie: name=value
Cookie: name=value; name2=value2; name3=value3
```

**\<cookie-list>：**一系列的名称/值对，形式为 \<cookie-name>=\<cookie-value>。<font color=FF0000>名称/值对之间用分号和空格 ('; ')隔开</font>。

**示例**

```http
Cookie: PHPSESSID=298zf09hf012fh2; csrftoken=u32t4o3tb3gg43; _gat=1;
```

摘自：[MDN - Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie)

#### 关于 cookieStore 的补充

js 原生对于 cookie 键值对的 CURD 操作 不是很方便，可使用  [js-cookie](https://github.com/js-cookie/js-cookie) 的库；现在出来一个新的特性：cookieStore，但处于试验阶段；同时也只能用于 https 中。另外，下面放一张 “设置 Cookie速查表”

| 平台                    | 操作示例                                   | 说明                                                         |
| :---------------------- | :----------------------------------------- | :----------------------------------------------------------- |
| 服务端                  | set-cookie: \<cookie-name>=\<cookie-value> | 服务端通过设置 set-cookie 控制 Cookie                        |
| 浏览器 document.cookie  | document.cookie = "name=scar";             | 获取并设置与当前文档相关联的 cookie，操作不灵活。            |
| 浏览器 Cookie Store API | cookieStore.set("name", "scar")            | 新特性，<font color=FF0000>仅支持在 HTTPS 使用</font>，目前还在实验阶段。 |

##### **cookieStore 的特性**

- <font color=FF0000 size=4>**异步操作：**</font>它可以异步访问 Cookie，不阻塞主进程，<font color=FF0000>document.cookie 是同步操作</font>。

- **错误抛出机制：**<font color=FF0000>**Cookie Store API 有一个明确的机制来报告 Cookie 存储错误**</font>，而 <font color=FF0000>document.cookie 如果设置失败也不会提醒</font>，所以需要轮询查 Cookie 的方法来确保设置成功。

- **service workers 支持：**因为 document.cookie 的同步设计，所以 service workers 不支持。Cookie Store API 的异步特性更适合，所以 service workers 支持通过它访问 Cookie。

摘自：[Cookie 从入门到进阶：一文彻底弄懂其原理以及应用](https://mp.weixin.qq.com/s/ljZ51xJZvG-8mx0CvU7vVA)

The `CookieStore` interface of the [`Cookie Store API`](https://developer.mozilla.org/en-US/docs/Web/API/Cookie_Store_API) <font color=FF0000>provides methods for getting and setting cookies **asynchronously** from **either a page or a service worker**</font>.

The `CookieStore` is accessed via attributes in the global scope in a [`Window`](https://developer.mozilla.org/en-US/docs/Web/API/Window) or [`ServiceWorkerGlobalScope`](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope) context. Therefore there is no constructor.

```mermaid
classDiagram
EventTarget <|-- CookieStore
```

**方法**

- **CookieStore.delete()：**The `delete()` method deletes a cookie with the given name or options object, <font color=FF0000>it returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves when the deletion completes</font>.
- **CookieStore.get()：**The `get()` method gets a single cookie with the given name or options object, <font color=FF0000>it returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with details of a single cookie</font>.
- **CookieStore.getAll()：**The `getAll()` method gets all matching cookies, <font color=FF0000>it returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves with a list of cookies</font>.
- **CookieStore.set()：**The `set()` method sets a cookie with the given name and value or options object, <font color=FF0000>it returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves when the cookie is set</font>.

**事件**

**CookieStore.change_event：**The `change` event fires when a change is made to any cookie.

摘自：[MDN - CookieStore (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/CookieStore)



#### Content-Disposition

在常规的 HTTP 应答中，<font color=FF0000>Content-Disposition 响应头指示回复的内容该以何种形式展示</font>，<font color=FF0000>是以**内联的形式**（即网页或者页面的一部分），还是以**附件的形式**下载并保存到本地</font>。

<mark style=background-color:hotpink>在 multipart/form-data 类型的应答消息体中，Content-Disposition 消息头可以被用在 multipart 消息体的子部分中，用来给出其对应字段的相关信息</mark>。各个子部分由在Content-Type 中定义的分隔符分隔。用在消息体自身则无实际意义。

Content-Disposition 消息头最初是在 MIME 标准中定义的，HTTP 表单及 POST 请求只用到了其所有参数的一个子集。只有 form-data 以及可选的 name 和 filename 三个参数可以应用在HTTP场景中。

| 属性         | 值                                                           |
| ------------ | ------------------------------------------------------------ |
| 报文类型     | 请求头：for the main body<br> 通用头：for a subpart of a multipart body |
| 禁用首部名称 | 否                                                           |

##### 语法

- **作为消息主体中的消息头**

  在 HTTP 场景中，第一个参数或者是 inline（默认值，表示回复中的消息体会以页面的一部分或者整个页面的形式展示），或者是 attachment（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将 filename 的值预填为下载后的文件名，假如它存在的话）。

  ```http
  Content-Disposition: inline
  Content-Disposition: attachment
  Content-Disposition: attachment; filename="filename.jpg"
  ```

- **作为multipart body中的消息头**

  在 HTTP 场景中。第一个参数总是固定不变的 form-data；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号('=')连接，参数值用双引号括起来。参数之间用分号(';')分隔。

  ```http
  Content-Disposition: form-data
  Content-Disposition: form-data; name="fieldName"
  Content-Disposition: form-data; name="fieldName"; filename="filename.jpg"
  ```

##### 指令

- **name：**<font color=FF0000>后面是一个表单字段名的字符串</font>，每一个字段名会对应一个子部分。在同一个字段名对应多个文件的情况下（例如，带有 multiple 属性的 \<input type=file> 元素），则多个子部分共用同一个字段名。如果 name 参数的值为 '\_charset\_' ，意味着这个子部分表示的不是一个 HTML 字段，而是在未明确指定字符集信息的情况下各部分使用的默认字符集。
- **filename：**后面是要传送的文件的初始名称的字符串。这个参数总是可选的，而且不能盲目使用：路径信息必须舍掉，同时要进行一定的转换以符合服务器文件系统规则。这个参数主要用来提供展示性信息。当与 Content-Disposition: attachment 一同使用的时候，它被用作"保存为"对话框中呈现给用户的默认文件名。
- **filename\***："filename" 和 "filename\*" 两个参数的唯一区别在于，"filename\*" 采用了  RFC 5987 中规定的编码方式。当 "filename" 和 "filename\*" 同时出现的时候，应该优先采用 "filename\*"，假如二者都支持的话。

摘自：[MDN - Content-Disposition](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition)



#### Referer

<font color=FF0000>Referer 请求头包含了当前 **请求页面的来源页面的地址** ，即表示 **当前页面是通过此来源页面里的链接进入的**</font>。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。

> **注意 ⚠️**：referer 实际上是 "referrer" 误拼写。<font color=FF0000>Referer 请求头可能暴露用户的浏览历史，涉及到用户的隐私问题</font>

##### 在以下两种情况下，Referer 不会被发送

- 来源页面采用的协议为表示 本地文件的 "file" 或者 "data" URI
- <font color=FF0000>**当前请求页面采用的是非安全协议，而来源页面采用的是安全协议 ( HTTPS )**</font>

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 请求头 |
| 禁用首部名称 | 是     |

##### 语法

```http
Referer: <url>
```

##### 指令

**\<url>**：当前页面被链接而至的前一页面的绝对路径或者相对路径。不包含 URL fragments ( 例如 "#section" ）和 userinfo (例如 "https://username:password@example.com/foo/bar/" 中的 "username:password" )。

##### 示例

```http
Referer: https://developer.mozilla.org/en-US/docs/Web/JavaScript
```

摘自：[MDN - Referer](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer)



#### Link

HTTP 实体报头 `Link` 提供了序列化 HTTP 头部链接的方法。它<font color=FF0000>在语义上与 HTML 元素 \<link> 相等</font>。

##### 语法

```http
Link: < uri-reference >; param1=value1; param2="value2"
```

**\<uri-reference>**：<font color=FF0000>URI reference 必须要用 `<` 和 `>` 来关闭</font>。

##### 参数

link 头部包含以 `;` 分隔的参数，<font color=FF0000>这些参数与 HTML 元素 \<link> 的属性一致</font>。

##### 示例

URI 必须要用 `<` 和 `>` 来关闭：

```http
Link: <https://example.com>; rel="preload"

Link: https://bad.example; rel="preload"
```

摘自：[MDN - Link](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Link)



#### http/1.1 首部字段一览

##### 通用首部字段

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存的行为             |
| Connection        | 逐跳首部、连接的管理       |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

##### 请求首部字段

| 首部字段名          | 说明                                                       |
| ------------------- | ---------------------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                                   |
| Accept-Charset      | 优先的字符集                                               |
| Accept-Encoding     | 优先的内容编码                                             |
| Accept-Language     | 优先的语言（自然语言）                                     |
| Authorization Web   | 认证信息                                                   |
| Expect              | 期待服务器的特定行为                                       |
| From                | 用户的电子邮箱地址                                         |
| Host                | 请求资源所在服务器                                         |
| If-Match            | 比较实体标记（ETag）                                       |
| If-Modified-Since   | 比较资源的更新时间                                         |
| If-None-Match       | 比较实体标记（<font color=FF0000>与 If-Match 相反</font>） |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求                       |
| If-Unmodified-Since | 比较资源的更新时间（与If-Modified-Since相反）              |
| Max-Forwards        | 最大传输逐跳数                                             |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                             |
| Range               | 实体的字节范围请求                                         |
| Referer             | 对请求中 URI 的原始获取方                                  |
| TE                  | 传输编码的优先级                                           |
| User-Agent          | HTTP 客户端程序的信息                                      |

##### 响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定URI      |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

##### 实体首部字段

| 首部字段名       | 说明                         |
| ---------------- | ---------------------------- |
| Allow            | 资源可支持的HTTP方法         |
| Content-Encoding | 实体主体适用的编码方式       |
| Content-Language | 实体主体的自然语言           |
| Content-Length   | 实体主体的大小（单位：字节） |
| Content-Location | 替代对应资源的URI            |
| Content-MD5      | 实体主体的报文摘要           |
| Content-Range    | 实体主体的位置范围           |
| Content-Type     | 实体主体的媒体类型           |
| Expires          | 实体主体过期的日期时间       |
| Last-Modified    | 资源的最后修改日期时间       |

摘自：《图解HTTP》 P82

 

#### Data URLs

Data URLs，即<font color=FF0000>前缀为 data: 协议的URL </font>，其<font color=FF0000>允许内容创建者向文档中嵌入小文件</font>。

**语法：**

```js
data:[<mediatype>][;base64],<data>
```

<font color=FF0000>Data URLs **由四个部分组成**</font>：

- 前缀 ( data: )
- <font color=FF0000>指示数据类型的 MIME 类型</font>
- <font color=FF0000>如果非文本，则为可选的 base64 标记</font>
- <font color=FF0000>**数据本身**</font>

mediatype 是个 MIME 类型的字符串，例如 "image/jpeg" 表示 JPEG 图像文件。<font color=FF0000>如果被省略，则默认值为 text/plain;charset=US-ASCII</font>

<font color=FF0000>如果数据是文本类型，你可以直接将文本嵌入</font> (根据文档类型，使用合适的实体字符或转义字符)。<font color=FF0000>如果是二进制数据，你可以将数据进行base64编码之后再进行嵌入</font>。

**一些示例：**

- 简单的 text/plain 类型数据

  ```js
  data:,Hello%2C%20World!
  ```

- 上一条示例的 base64 编码版本

  ```js
  data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D
  ```

- 一个 HTML 文档源代码 \<h1>Hello, World\</h1>

  ```js
  data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E
  ```

- 一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭

  ```js
  data:text/html,<script>alert('hi');</script>
  ```

在 linux / macOS 中可以使用 uuencode 命令行工具来简单实现编码：

```sh
uuencode -m infile remotename
```

infile 参数表示要作 base64 编码的文件名称，remotename 参数表示输出的文件名称, 实际上并没有在 data 方案的URLs 中使用。

摘自：[MDN - Data URLs](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs)



#### SPDY

SPDY（发音如英语：speedy ），<font color=FF0000> 一种开放的网路传输协定</font>，<mark>由 Google 开发</mark>，<font color=FF0000> 用来传送网页内容</font>。<font color=FF0000> **基于传输控制协议 ( TCP ) 的应用层协议** </font>。<font color=FF0000> SPDY 也就是 HTTP/2 的前身</font>。Google 最早是在 Chromium 中提出的 SPDY 协议。被用于 Google Chrome 浏览器中来访问 Google 的 SSL 加密服务。SPDY 并不是首字母缩略字，而仅仅是 "speedy" 的缩写。SPDY 现为 Google 的商标。<font color=FF0000> HTTP/2 的关键功能主要来自 SPDY 技术，换言之，SPDY 的成果被采纳而最终演变为 HTTP/2</font>。

<mark>SPDY 并不是一个标准协议，但 SPDY 的开发组推动 SPDY 成为正式标准，而成为了互联网草案</mark>。后来 SPDY 未能单独成为正式标准，不过 SPDY 开发组的成员全程参与了 HTTP/2 的制定过程。Google Chrome、Mozilla Firefox、Safari、Opera、Internet Explorer 等主要浏览器均已经或曾经支持 SPDY 协议。<font color=FF0000> SPDY 协议类似于 HTTP ，但旨在缩短网页的加载时间和提高安全性。 SPDY 协议<font size=4>**通过压缩、多路复用和优先级来缩短加载时间**</font></font>。HTTP/2 协议完成之后，Google 认为 SPDY 可以功成身退了，于是最终 Google Chrome 淘汰对 SPDY 的支援，全面改为采用 HTTP/2

<font size=4>**设计**</font>
<font color=FF0000> 设计 SPDY 的**目的在于降低网页的加载时间**。通过**优先级**和**多路复用**，SPDY 使得<font size=4>**只需要建立一个 TCP 连接**</font>即可传送网页内容及图片等资源</font>。<font color=FF0000> SPDY 中**广泛应用了 TLS 加密**</font>，<font color=FF0000> **传输内容也均以 gzip 或 DEFLATE 格式压缩** </font>（与 HTTP 不同，<font color=FF0000> **HTTP 的头部并不会被压缩** </font>）。另外，除了像 HTTP 的网页服务器被动的等待浏览器发起请求外，<font color=FF0000> SPDY 的网页服务器 **还可以主动推送内容**</font>。

<font size=4>**与HTTP的关系**</font>
SPDY 并不用于取代 HTTP ，它<font color=FF0000> 只是修改了 HTTP  的请求与应答在网络上传输的方式</font>；这意味着<font color=FF0000> 只需增加一个SPDY 传输层，现有的所有服务端应用均不用做任何修改</font>。

当使用 SPDY 的方式传输，HTTP 请求会被处理、标记简化和压缩。比如，每一个 SPDY 端点会持续跟踪每一个在之前的请求中已经发送的 HTTP 报文头部，从而避免重复发送还未改变的头部。而还未发送的报文的数据部分将在被压缩后被发送。

**Chrome 移除 SPDY**
2015年9月，Google 宣布了计划，移除对 SPDY 的支持，改支援 HTTP/2 。此更动在 Chrome 51 中生效。

摘自：[wiki - SPDY](https://zh.wikipedia.org/wiki/SPDY)



#### WebSocket协议相关

// TODO



#### 一些细节

##### X-Requested-With

x-Requested-With 请求头 区分 ***Ajax 请求*** 还是 ***普通请求***

在服务器端判断request来自Ajax请求(异步)还是传统请求(同步)：两种请求在请求的 Header 不同，Ajax 异步请求比传统的同步请求多了一个头参数，即： 

```http
x-requested-with:  XMLHttpRequest
```

可以利用该特性，`request.getHeader("x-requested-with")` 为 null，则为传统同步请求；为 XMLHttpRequest，则为 Ajax 异步请求

摘自：[x-requested-with的作用以及用法详解](https://blog.csdn.net/jokeMqc/article/details/78739677)。另外，[X-Requested-With 这个Http请求头有什么作用? - 知乎](https://www.zhihu.com/question/30795602) 也有类似说法。

***





## 网络安全相关

#### 攻击方法

- XSS（跨站脚本攻击）
- CSRF（跨站请求伪造）
- Session Fixation Attack（会话固定攻击）
- Click Jacking（点击劫持攻击）
- Timing Attack（时序攻击）
- Challenge Collapsar Attack（CC攻击）
- Man-in-the-middle attack（MITM， 中间人攻击）
- Side Channel Attack（SCA，边信道攻击）
- Cross-Site Tracing（XST，跨站式追踪攻击）
- SQL Injection（SQL 注入攻击）
- OS Command Injection（OS 命令注入攻击）
- HTTP Header Injection（HTTP 首部注入攻击）
- Mail Header Injection （邮件首部注入攻击）
- Directory Traversal（目录遍历攻击）<font color=FF0000 size=4>**/**</font> Path Traversal（路径遍历攻击）

- 缓冲区溢出攻击



#### 对于 web 应用的攻击模式有两种

- **主动攻击：**具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击
- **被动攻击：**具有代表性的攻击是跨站脚本攻击 ( XSS ) 和 跨站点请求伪造 ( CSRF )；除此之外，还有 HTTP 首部注入攻击



MDN 中有 web 安全的一些知识总结，见：[MDN - Web 安全](https://developer.mozilla.org/zh-CN/docs/Web/Security)



### 常见的 安全 Header

文章 [HTTP 安全响应头（Security Response header）配置手册](https://sysin.org/blog/security-headers/) 中列举（总结）了一些 安全响应头，适合复习阅读。

#### HTTP Strict-Transport-Security ( HSTS )

HTTP Strict Transport Security（通常简称为 HSTS ）是一个安全功能，它<font color=FF0000>告诉浏览器只能通过 HTTPS 访问当前资源，而不是 HTTP</font>

| 属性               | 值       |
| :----------------- | -------- |
| 首部类型           | 响应类型 |
| 禁止修改的消息首部 | 否       |

##### 语法

```http
Strict-Transport-Security: max-age=<expire-time>
Strict-Transport-Security: max-age=<expire-time>; includeSubDomains
Strict-Transport-Security: max-age=<expire-time>; preload
```

##### 指令

- **max-age=\<expire-time>**：设置<font color=FF0000>在浏览器收到这个请求后的 \<expire-time> 秒的时间内，凡是访问这个域名下的请求都使用 HTTPS</font>
- **includeSubDomains**：**可选**。<font color=FF0000>如果这个可选的参数被指定，那么说明 **此规则也适用于该网站的所有子域名**</font>
- **preload**：**可选**，预加载 HSTS ；这不是标准的一部分，而是谷歌的功能，详见下面 [[#预加载 HSTS]]

##### 背景（痛点与需求）

一个网站接受一个 HTTP 的请求，然后跳转到 HTTPS；用户可能在开始跳转前，通过没有加密的方式和服务器对话。比如，用户输入 http://foo.com 或者直接 foo.com。这样可能存在 ***中间人攻击*** 潜在威胁，跳转过程可能被恶意网站利用来直接接触用户信息，而不是原来的加密信息。

网站通过 HTTP Strict Transport Security 通知浏览器，这个网站禁止使用 HTTP 方式加载，浏览器应该自动把所有尝试使用 HTTP 的请求自动替换为 HTTPS 请求。

**注意** ⚠️：Strict-Transport-Security 在通过 HTTP 访问时 <font color=FF0000>**会被浏览器忽略**</font>；因为攻击者可以通过中间人攻击的方式在连接中修改、注入或删除它。<font color=FF0000>只有在你的网站通过 HTTPS 访问并且没有证书错误时，**浏览器才认为你的网站支持 HTTPS，然后使用 Strict-Transport-Security 的值**</font>

##### 预加载 HSTS

谷歌维护着一个 [HSTS 预加载服务](https://hstspreload.appspot.com/)。<font color=FF0000>按照指示成功提交你的域名后，浏览器将会永不使用非安全的方式连接到你的域名</font>。虽然该服务是由谷歌提供的，但所有浏览器都有使用这份列表的意向（或者已经在用了）。但是，这不是 HSTS 标准的一部分，也不该被当作正式的内容

- Chrome & Chromium 的 HSTS 预加载列表： https://www.chromium.org/hsts
- Firefox 的 HSTS 预加载列表：[nsSTSPreloadList.inc](https://hg.mozilla.org/mozilla-central/raw-file/tip/security/manager/ssl/nsSTSPreloadList.inc)

摘自：[MDN - HTTP Strict Transport Security](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security#预加载_hsts)

> 输入 chrome://net-internals/#hsts ，进入 HSTS 管理界面，可以增加/删除/查询 HSTS 记录。
> 将网站加入预加载列表：https://hstspreload.org/
>
> 摘自：[HTTP 安全响应头（Security Response header）配置手册](https://sysin.org/blog/security-headers/)



#### HTTP Public Key Pinning ( HPKP )

HTTP 公钥锁定 ( HPKP ) <font color=FF0000>是一种安全功能</font>，它<font color=FF0000>告诉 Web 客户端 **将特定加密公钥与某个 Web 服务器相关联**</font>，以 <font color=FF0000 size=4>**降低使用伪造证书 *进行 MITM 攻击* 的风险**</font>。

为<font color=FF0000>**确保 TLS 会话中使用的服务器公钥的真实性**</font>，此公钥将包装到 ***X.509 证书*** （**注：**见下面引用中的解释）中，该证书通常由证书颁发机构 ( CA ) 签名。诸如浏览器之类的 Web 客户端信任许多这些 CA，它们都可以为任意域名创建证书。<mark>如果攻击者能够攻击单个 CA，则他们可以对各种 TLS 连接执行 MITM 攻击。HPKP 可以通过告知客户端哪个公钥属于某个 Web 服务器来规避 HTTPS 协议的这种威胁</mark>

> <font color=FF0000>**X.509 是密码学里公钥证书的格式标准**</font>。X.509 证书 已应用在包括 TLS/SSL 在内的众多网络协议里，同时它也用在很多非在线应用场景里，比如电子签名服务。<font color=FF0000>X.509 证书里含有公钥、身份信息</font>（ 比如网络主机名，组织的名称或个体名称等）和签名信息（可以是证书签发机构 CA 的签名，也可以是自签名 ）
>
> 摘自：[维基百科 - X.509](https://zh.m.wikipedia.org/wiki/X.509)

<font color=FF0000>HPKP 是 ***首次使用时信任*** ( TOFU / Trust On First Use ) 技术，Web 服务器第一次通过特殊的 HTTP 标头告诉客户端哪些公钥属于它，客户端会在给定的时间段内存储此信息</font>。当客户端再次访问服务器时，它希望证书链中至少有一个证书包含一个公钥，其指纹已通过 HPKP 已知。如果服务器提供未知的公钥，则客户端应向用户发出警告。

##### 启用 HPKP

<font color=FF0000>要为您的站点启用此功能，您需要在通过 HTTPS 访问站点时返回 `Public-Key-Pins` HTTP Header </font>：

```http
Public-Key-Pins: pin-sha256="base64=="; max-age=expireTime [; includeSubDomains][; report-uri="reportURI"]
```

- **pin-sha256**：引用的字符串是 Base64 编码的主题公钥信息 ( SPKI ) 指纹。 可以为不同的公钥指定多个引脚。 某些浏览器将来可能允许使用其他哈希算法，而不是 SHA-256 。 请参阅下文，了解如何从证书或密钥文件中提取此信息。
- **max-age**：<font color=FF0000>浏览器应记住仅使用其中一个已定义的密钥访问此站点的时间（以秒为单位）</font>
- **includeSubDomains**：可选，如果指定了此可选参数，则<font color=FF0000>此规则也适用于所有站点的子域</font>
- **report-uri**：可选，如果指定了此可选参数，则<font color=FF0000>会将引脚验证失败报告给给定的 URL</font>

原文下面还有 “提取 Base64 编码的公钥信息” 的方法，需要使用 openssl ，这里略。

摘自：[MDN - HTTP Public Key Pinning (HPKP)](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Public_Key_Pinning#启用_hpkp)



#### Content Security Policy

内容安全策略  ( CSP ) 是一个 <font color=FF0000>**额外的安全层**</font>，用于检测并削弱某些特定类型的攻击，包括 ***跨站脚本 ( XSS )*** 和 ***数据注入攻击*** 等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。

CSP 被设计成完全向后兼容（除 CSP2 在向后兼容有明确提及的不一致; 更多细节查看[这里](https://www.w3.org/TR/CSP2) 章节 1.1）。不支持 CSP 的浏览器也能与实现了 CSP 的服务器正常合作，反之亦然：不支持 CSP 的浏览器只会忽略它，如常运行，默认为网页内容使用标准的同源策略。如果网站不提供 CSP 头部，浏览器也使用标准的 同源策略

##### 跨站脚本攻击

**CSP 的主要目标是减少和报告 XSS 攻击** ，<font color=FF0000>XSS 攻击 利用了 **浏览器对于从服务器所获取的内容的信任**</font>。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。

<font color=FF0000>CSP 通过指定有效域，即浏览器认可的可执行脚本的有效来源，使服务器管理者有能力减少或消除 XSS 攻击所依赖的载体</font>。一个 <font color=FF0000>CSP 兼容的浏览器将会 **仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本**</font>（包括内联脚本和 HTML 的事件处理属性）

作为一种 **终极防护形式**，始终不允许执行脚本的站点可以选择全面禁止脚本执行。

摘自：[MDN - 内容安全策略 ( CSP )](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

摘自：[MDN - Content-Security-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy)

<mark>跨域脚本攻击 XSS 是最常见、危害最大的网页安全漏洞</mark>。<mark>为了防止它们，要采取很多编程措施，非常麻烦</mark>。<font color=FF0000> 很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？这就是"网页安全政策"</font>（<font color=FF0000> Content Security Policy</font>，缩写 <font color=FF0000> CSP</font>）的来历。

##### 简介

<font color=FF0000> CSP 的实质就是 ***白名单制度***，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单</font>。<font color=FF0000> **它的实现和执行全部由浏览器完成，开发者只需提供配置**</font>。<mark>CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机</mark>。

##### 两种方法可以启用 CSP

一种是<font color=FF0000> 通过 HTTP 头信息的 Content-Security-Policy 的字段</font>（首选）

```http
Content-Security-Policy: script-src 'self'; object-src 'none';
style-src cdn.example.org third-party.org; child-src https:
```

另一种是<font color=FF0000> 通过网页的 \<meta> 标签</font>，使用 http-equiv 即 ***http 等价物***

```html
<meta http-equiv="Content-Security-Policy" 
      content="script-src 'self'; 
               object-src 'none'; 
               style-src cdn.example.org third-party.org; 
               child-src https:">
```

**上面两种设置是等价的，CSP 做了如下配置：**

 - **脚本（script-src）：**只信任当前域名（self）
 - **\<object> 标签 ( object-src ) ：**不信任任何 URL，即不加载任何资源 ( none )
 - **样式表 ( style-src ) ：**只信任 cdn.example.org 和 third-party.org
 - **框架 frame ( child-src ) ：**必须使用 HTTPS 协议加载
 - **其他资源：**没有限制

启用后，不符合 CSP 的外部资源就会被阻止加载。

> 如果 HTTP 头与 Meta 定义同时存在，则<font color=FF0000>优先采用 HTTP 中的定义</font>。
>
> 摘自：[前端安全配置之Content-Security-Policy(csp)](https://blog.csdn.net/wulex/article/details/105405837)

##### 限制选项

CSP 提供了很多限制选项，涉及安全的各个方面：

- **资源加载限制**

  以下选项限制各类资源的加载

  - **script-src：**外部脚本

  - **style-src：**样式表

  - **img-src：**图像

  - **media-src：**媒体文件（音频和视频）

  - **font-src：**字体文件

  - **object-src：**<mark>插件（ 比如 Flash ）</mark>

  - **child-src：**<mark>框架</mark>

  - **frame-ancestors：**<mark>嵌入的外部资源（比如 \<frame>、\<iframe>、\<embed> 和 \<applet>）</mark>

  - **connect-src：**<mark>HTTP 连接（通过 XHR、WebSockets、EventSource 等）</mark>

  - **worker-src：**<mark>worker 脚本</mark>

  - **manifest-src：**manifest 文件

  > - **prefetch-src**：指定预加载或预渲染的允许源地址
  > - **webrtc-src**：🧪 实验性，指定WebRTC连接的合法源地址。
  >
  > 摘自：[MDN - Content-Security-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy)

- **default-src**

  default-src ：<font color=FF0000> 用来设置上面各个选项的默认值</font>。

  ```http
  Content-Security-Policy: default-src 'self'
  ```

  上面代码<font color=FF0000> 限制所有的外部资源，都只能从当前域名加载</font>。

  如果<font color=FF0000> 同时设置某个单项限制（比如 font-src ）和 default-src ，前者会覆盖后者</font>，即字体文件会采用 font-src 的值，其他资源依然采用 default-src 的值

- **URL 限制**

  有时，网页会跟其他 URL 发生联系，这时也可以加以限制

  - **frame-ancestors：**指定可能嵌入页面的有效父项 \<frame>, \<iframe>, \<object>, \<embed>, or \<applet>.
  - **base-uri：**限制在 DOM 中 \<base> 元素可以使用的 URL

  - **form-action：**限制能被用来作为给定上下文的表单提交的目标 URL（就是限制 form 的 action 属性的链接地址）


- **其他限制**

  其他一些安全相关的功能，也放在了 CSP 里面

  - **block-all-mixed-content：**HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）

  - **upgrade-insecure-requests：**自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议

  - **plugin-types：**限制可以使用的插件格式（类型）

  - **sandbox：**浏览器行为的限制，比如不能有弹出窗口等


##### report-uri

有时，我们<mark>不仅希望防止 XSS</mark>，<font color=FF0000> 还希望记录此类行为</font>。<font color=FF0000> **report-uri** 就用来告诉浏览器，应该把注入行为报告给哪个网址</font>。

```http
Content-Security-Policy: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;
```

上面代码指定，将注入行为报告给 /my_amazing_csp_report_parser 这个 URL

浏览器会使用 POST 方法，发送一个 JSON 对象，下面是一个例子。

```json
{
  "csp-report": {
    "document-uri": "http://example.org/page.html",
    "referrer": "http://evil.example.com/",
    "blocked-uri": "http://evil.example.com/evil.js",
    "violated-directive": "script-src 'self' https://apis.google.com",
    "original-policy": "script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser"
  }
}
```

这部分的内容实际上就是 Content-Security-Policy-Report-Only 返回的结果，可以参考 [[#Content-Security-Policy-Report-Only]]

##### Content-Security-Policy-Report-Only

除了 Content-Security-Policy ， 还有一个 <font color=FF0000>Content-Security-Policy-Report-Only 字段，**表示不执行限制选项，只是记录违反限制的行为**</font>。<font color=FF0000>它必须与 report-uri 选项配合使用</font>。

```http
Content-Security-Policy-Report-Only: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;
```

这部分的内容阮一峰的文章中没有讲的很细，细节可以参考 [[#Content-Security-Policy-Report-Only]]

##### CSP 的选项值

每个限制选项可以设置以下几种值，这些值就构成了白名单。

- **主机名：**example.org，https://example.com:443
- **路径名：**example.org/resources/js/
- **通配符：**\*.example.org ，\*://\*.example.com:\*（表示任意协议、任意子域名、任意端口）
- **协议名：**https: 、data:
- **关键字 'self' ：**当前域名，需要加引号
- **关键字 'none' ：**禁止加载任何外部资源，需要加引号

**多个值也可以并列，用空格分隔。**

```http
Content-Security-Policy: script-src 'self' https://apis.google.com
```

如果同一个限制选项使用多次，只有第一次会生效

```js
// 错误的写法
script-src https://host1.com; script-src https://host2.com

// 正确的写法
script-src https://host1.com https://host2.com
```

如果不设置某个限制选项，就是默认允许任何值。

##### script-src 的特殊值

<font color=FF0000> 除了常规值，script-src 还可以设置一些特殊值</font>。注意，<font color=FF0000> 下面这些值都必须放在 **单引号** 里面</font>。

- **'unsafe-inline'：**允许执行页面内嵌的 \<script> 标签和事件监听函数

- **'unsafe-eval'：**允许将字符串当作代码执行，比如使用 eval、setTimeout、setInterval 和 Function 等函数

- **'nonce值'：**每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行

  nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。

  ```http
  Content-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'
  ```

  页面内嵌脚本，必须有这个token才能执行。

  ```html
  <script nonce=EDNnf03nceIOfn39fn3e9h3sdfa>
    // some code
  </script>
  ```

- **'hash值' ：**列出允许执行的脚本代码的 Hash 值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。

  hash值的例子如下，服务器给出一个允许执行的代码的hash值。

  ```http
  Content-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='
  ```

  下面的代码就会允许执行，因为 hash 值相符

  ```html
  <script>alert('Hello, world.');</script>
  ```

  注意，计算hash值的时候，\<script>标签不算在内。

除了 script-src 选项，nonce 值 和 hash 值 还可以用在 style-src 选项，控制页面内嵌的样式表。

##### 注意点

- <font color=FF0000> **script-src 和 object-src 是必设的，除非设置了 default-src**</font>。<mark>因为攻击者只要能注入脚本，其他限制都可以规避</mark>。而 <mark>object-src 必设是因为 Flash 里面可以执行外部脚本</mark>。

- script-src 不能使用 unsafe-inline 关键字（除非伴随一个 nonce 值），也不能允许设置 data:URL

   下面是两个恶意攻击的例子：

  ```html
  <img src="x" onerror="evil()">
  <script src="data:text/javascript,evil()"></script>
  ```

- 必须特别注意 JSONP 的回调函数

  ```html
  <script src="/path/jsonp?callback=alert(document.domain)//"></script>
  ```

  上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。

摘自：[阮一峰 - Content Security Policy 入门教程](http://www.ruanyifeng.com/blog/2016/09/csp.html)

#### Content-Security-Policy-Report-Only

HTTP Content-Security-Policy-Report-Only 响应头允许 web 开发人员通过监测（但不强制执行）政策的影响来尝试政策。这些违反报告由 JSON 文档组成通过一个 HTTP POST 请求发送到指定的 URI。

| 属性                          | 值     |
| ----------------------------- | ------ |
| 报文类型                      | 响应头 |
| 禁用首部名称                  | 否     |
| 是否支持在 \<meta> 元素内定义 | 否     |

##### 语法

```http
Content-Security-Policy-Report-Only: <policy-directive>; <policy-directive>
```

##### 指令

<font color=FF0000>**Content-Security-Policy header 的指令也可应用于 Content-Security-Policy-Report-Only**</font> 。

CSP 的 report-uri 指令需要跟 Content-Security-Policy-Report-Only 一起用，否则 Content-Security-Policy-Report-Only 将会是一个昂贵却无操作（无作用）的机器（设置）

##### 违规报告的语法

报告的 JSON 对象包括下面的数据：

- **document-uri**：发生违规的文档 URI
- **referrer**：发生违规的文档 referrer。
- **blocked-uri**：被内容安全政策阻塞加载的资源的 URI。如果被阻塞的 URI 与文档 URI 不同源，则被阻塞的 URI 被截断为只包含 scheme（协议），host（域名），和 port（端口）
- **violated-directive**：被违反的策略名。
- **original-policy**：Content-Security-Policy HTTP 头部所指定的原始策略。
- **disposition**：“执行”或“报告”取决于是使用 Content-Security-Policy 头 还是使用 Content-Security-Header-Report-Only 头

摘自：[MDN -  Content-Security-Policy-Report-Only](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only)

<font color=FF0000>如果 Content-Security-Policy-Report-Only 头部和 Content-Security-Policy 同时出现在一个响应中，**两个策略均有效**</font>。在 Content-Security-Policy 头部中指定的策略有强制性 ，而 Content-Security-Policy-Report-Only 中的策略仅产生报告而不具有强制性。

摘自：[MDN - 内容安全策略 ( CSP )](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)



#### Referrer-Policy

Referrer-Policy 首部 <font color=FF0000>用来监管 **哪些访问来源信息**</font>（**会在 Referer  中发送**）<font color=FF0000>应该被包含在生成的请求当中</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

##### 语法

注意 Referer 实际上是单词 "referrer" 的错误拼写。Referrer-Policy 这个首部并没有延续这个错误拼写。

```http
Referrer-Policy: <directive>
```

##### 指令

- **no-referrer**：<font color=FF0000>整个 Referer  首部会被移除</font>。访问来源信息不随着请求一起发送
- **no-referrer-when-downgrade**：<font color=FF0000>**默认值**</font>，在没有指定任何策略的情况下用户代理的默认行为。<font color=FF0000>在同等安全级别的情况下，引用页面的地址会被发送  ( HTTPS -> HTTPS )</font> ，但是在降级的情况下不会被发送 ( HTTPS -> HTTP )
- **origin**：在<font color=FF0000>任何情况下，**仅发送 文件的源 作为引用地址**</font>（没读懂的话，见后面的示例）。例如  https://example.com/page.html 会将 https://example.com/ 作为引用地址
- **origin-when-cross-origin**：对于<font color=FF0000>同源的请求，会发送完整的 URL 作为引用地址</font>；但<font color=FF0000>对于非同源请求仅发送文件的源</font>。
- **same-origin**：对于同源的请求会发送引用地址，但是对于非同源请求则不发送引用地址信息。
- **strict-origin**：<font color=FF0000>在同等安全级别的情况下，发送文件的源作为引用地址 ( HTTPS -> HTTPS )</font>，但在降级的情况下不会发送 ( HTTPS -> HTTP )
- **strict-origin-when-cross-origin**：对于同源的请求，会发送完整的 URL 作为引用地址；在同等安全级别的情况下，发送文件的源作为引用地址 ( HTTPS -> HTTPS )；在降级的情况下不发送此首部 ( HTTPS -> HTTP )
- **unsafe-url**：无论是同源请求还是非同源请求，都发送完整的 URL（移除参数信息之后）作为引用地址。

**注意 ⚠️**：这项设置会将 **受 TLS 安全协议保护的资源的源和路径信息** 泄露给非安全的源服务器，进行此项设置的时候要慎重考虑。

##### 集成到 HTML

可以在 HTML 内设置 referrer 策略。例如，<font color=FF0000>可以用一个 name 为 referrer 的 \<meta> 元素为整个文档设置 referrer 策略</font>。

```html
<meta name="referrer" content="origin">
```

<font color=FF0000>**或者用 \<a>、\<area>、\<img>、\<iframe>、\<script> 或者 \<link> 元素上的 referrerpolicy 属性为其设置独立的请求策略**</font>。

```html
<a href="http://example.com" referrerpolicy="origin">
```

<font color=FF0000>**也可以在 \<a>、\<area> 或者 \<link> 元素上将 rel 属性设置为 noreferrer**</font>

```html
<a href="http://example.com" rel="noreferrer">
```

##### 集成到 CSS

CSS 可以从样式表获取引用的资源，这些资源也可以遵从 referrer 策略：

- <font color=FF0000>外部 CSS 样式表使用默认策略 ( no-referrer-when-downgrade )</font>，除非 CSS 样式表的响应消息通过 Referrer-Policy 首部覆盖该策略
- 对于 \<style> 元素或 style 属性，则遵从文档的 referrer 策略

摘自：[MDN - Referrer-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy)



#### Expect-CT

**注：**CT 即 ***证书透明度*** Certificate Transparency

Expect-CT 头允许 站点 选择性报告 和/或（**注：**取决于是否使用 enforce？） 执行 ***证书透明度*** ( Certificate Transparency ) 要求，来 <font color=FF0000 size=4>**防止 错误签发 的网站证书的使用不被察觉**</font>。当 <font color=FF0000>站点启用 Expect-CT 头，就是在 **请求浏览器检查该网站的任何证书是否出现在公共证书透明度日志之中**</font>。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 是     |

##### 语法

```http
Expect-CT: report-uri="<uri>";
           enforce;
           max-age=<age>
```

##### 指令

- **max-age**：该指令 <font color=FF0000>指定接收到 Expect-CT 头后的秒数</font>。**在此期间，用户代理应将收到消息的主机视为已知的 Expect-CT 主机**。

  如果缓存接收到的值大于它可以表示的值，或者如果其随后计算溢出，则缓存将认为该值为 2147483648（2 的 31 次幂）或其可以方便表示的最大正整数。

- **report-uri="\<uri>"**：可选，该指令 <font color=FF0000>指定用户代理应向其报告 Expect-CT 失效的 URI</font> 。

  当 enforce 指令和 report-uri 指令共同存在时，这种配置被称为“强制执行和报告”配置，示意 <mark>用户代理既应该强制遵守证书透明度政策，也应当报告违规行为</mark>。

- **enforce**：可选，该指令 <font color=FF0000>示意用户代理应强制遵守证书透明度政策（而不是只报告合规性），并且用户代理应拒绝违反证书透明度政策的之后连接</font>。

  当 enforce 指令和 report-uri 指令共同存在，见上面。

##### 示例

以下示例指定 24 小时的证书透明度执行，并向 foo.example 报告违规行为。

```http
Expect-CT: max-age=86400; enforce; report-uri="https://foo.example/report"
```

摘自：[MDN - Expect-CT](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expect-CT)



#### X-Frame-Options

X-Frame-Options HTTP <font color=FF0000>响应头</font> 是<font color=FF0000>用来给浏览器 指示允许一个页面 **可否在 \<frame>, \<iframe>, \<embed> 或者 \<object> 中展现的标记**</font>。站点可以通过 <font color=FF0000>**确保网站没有被嵌入到别人的站点里面**</font>，从而<font color=FF0000>**避免 Click Jacking 攻击**</font>。

仅当访问文档的用户使用支持 X-Frame-Options 的浏览器时才提供附加的安全性。<mark> Content-Security-Policy HTTP 头中的 frame-ancestors 指令会替代这个非标准的 header。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用</mark>。

> 备注 ⚠️： Content-Security-Policy HTTP 响应头有一个 frame-ancestors 指令，<font color=FF0000>支持这一指令的浏览器已经废弃了 X-Frame-Options 响应头</font>

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

##### 语法

X-Frame-Options 有三个可能的值：

- **deny：**<font color=FF0000>表示该页面不允许在 frame 中展示</font>，即便是 **在相同域名的页面中嵌套也不允许**。

- **sameorigin：**<font color=FF0000>表示该页面可以在相同域名页面的 frame 中展示</font>。

- **allow-from uri**：已废弃 🗑，不再适用于现代浏览器。表示该页面可以在指定来源的 frame 中展示。<font color=FF0000>Content-Security-Policy HTTP 首部有一个 frame-ancestors 指令，你可以使用这一指令来代替</font>。

<font size=4>**注意：**</font><font color=FF0000> **在 meta 标签中设置 X-Frame-Options 是无效的！**</font>例如 `<meta http-equiv="X-Frame-Options" content="deny">` 没有任何效果。不要这样用！<font color=FF0000>**只有在服务器中配置 http 才有效**</font>。 不同的服务器配置，详见原文

摘自：[MDN - X-Frame-Options](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options)



#### X-XSS-Protection

X-XSS-Protection 响应头<font color=FF0000> 是 Internet Explorer，Chrome 和 Safari 的一个特性</font>，<font color=FF0000> **当检测到跨站脚本攻击  ( XSS ) 时，浏览器将停止加载页面** </font>。<mark>若网站设置了良好的 Content-Security-Policy 来禁用内联 JavaScript （ 'unsafe-inline'</mark> ，见 [[#Content Security Policy#script-src 的特殊值]]），<mark>现代浏览器不太需要这些保护</mark>， 但其仍然可以为尚不支持 CSP 的旧版浏览器的用户提供保护。**注：**CSP 主要目的是 解决 XSS 的

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

##### 语法

```http
X-XSS-Protection: 0
X-XSS-Protection: 1
X-XSS-Protection: 1; mode=block
X-XSS-Protection: 1; report=<reporting-uri>
```

- **X-XSS-Protection: 0**： <font color=FF0000> 禁止 XSS 过滤</font>

- **X-XSS-Protection: 1** ：<font color=FF0000> **启用 XSS 过滤**</font>（通常<font color=FF0000>**浏览器是默认**</font>）。 <font color=FF0000>如果检测到跨站脚本攻击，浏览器将**清除页面**</font>，删除不安全的部分

- **X-XSS-Protection: 1; mode=block** ：<font color=FF0000> 启用 XSS 过滤</font>。 如果<font color=FF0000> 检测到攻击，浏览器将 **不会清除页面**，**而是阻止页面加载**</font>。

- **X-XSS-Protection: 1; report=\<reporting-uri>** 只适用于 chromium，<font color=FF0000> 启用 XSS 过滤</font>。 如果<font color=FF0000> 检测到跨站脚本攻击，浏览器将**清除页面**，并使用 CSP report-uri 指令的功能发送违规报告</font>。

摘自：[MDN - X-XSS-Protection](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-XSS-Protection)



#### X-Content-Type-Options

X-Content-Type-Options HTTP 消息头<font color=FF0000> 相当于一个提示标志</font>，<font color=FF0000> 被服务器用来 **提示客户端 一定要遵循在 Content-Type 首部中对  MIME 类型 的设定，而不能对其进行修改** </font>。<font color=FF0000> **这就禁用了客户端的 MIME 类型嗅探行为**，换句话说，**也就是意味着网站管理员确定自己的设置没有问题** </font>。

该消息头最初是由微软在 IE8 浏览器中引入的，<mark> 提供给网站管理员用作禁用内容嗅探的手段，内容嗅探技术可能会把不可执行的 MIME 类型转变为可执行的 MIME 类型</mark>。<font color=FF0000> 在此之后，其他浏览器也相继引入了这个消息头，尽管它们的 MIME 嗅探算法没有那么有侵略性</font>。

安全测试人员通常期望站点设置了该消息头。

**注意** ⚠️：<font color=FF0000> **nosniff 只应用于 "script" 和 "style" 两种类型**</font>。事实证明，将其应用于图片类型的文件会导致与现有的站点冲突。

| 属性         | 值     |
| ------------ | ------ |
| 报文类型     | 响应头 |
| 禁用首部名称 | 否     |

##### 语法

```http
X-Content-Type-Options: nosniff
```

##### 指令

**nosniff：**<font color=FF0000> 下面两种情况的请求将被阻止 </font>

- 请求类型是 "style"， 但是 MIME 类型不是 "text/css"
- 请求类型是 "script"， 但是 MIME 类型不是  JavaScript MIME 类型

摘自：[MDN - X-Content-Type-Options](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options)



#### 彩虹表

彩虹表是一个<font color=FF0000> 用于加密散列函数逆运算的**预先计算好的表**</font>，常<font color=FF0000> 用于破解加密过的密码散列</font>。 彩虹表常常用于破解长度固定且包含的字符范围固定的密码（如信用卡、数字等）。这<font color=FF0000> 是以空间换时间的典型实践</font>，比暴力破解（Brute-force attack）使用的时间更少，空间更多；但与储存密码空间中的每一个密码及其对应的哈希值（Hash）实现的查找表相比，其花费的时间更多，空间更少。<font color=FF0000> 使用加盐的密钥派生函数可以使这种攻击难以实现</font>。

摘自：[wiki - 彩虹表](https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%99%B9%E8%A1%A8)



## HTTP 面试问题



##### HTTP/1.1 的优点

- **简单：**HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛

- **灵活和易于扩展：**<font color=FF0000>HTTP 协议里的各类请求方法、URI / URL、状态码、头字段等每个组成要求都没有被固定死，都**允许开发人员自定义和扩充**</font>。

  同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。

- **应用广泛和跨平台：**互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。



##### HTTP缺点

- **无状态双刃剑：**

  - **无状态的好处：**因为<font color=FF0000>服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务</font>。

  - **无状态的坏处：**既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。这样每操作一次，都要验证信息。

  对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。

- **明文传输双刃剑：**明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取。

- **不安全：**HTTP 比较严重的缺点就是不安全

  - 通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。
  - 不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。
  - 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。

  HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL / TLS 层，使得在安全上达到了极致。



##### HTTP 与 HTTPS 有哪些区别？

1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL / TLS 安全协议，使得报文能够加密传输。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 <font color=FF0000>HTTPS 在 TCP 三次握手之后，**还需进行 SSL / TLS 的握手过程**，才可进入加密报文传输</font>。
3. HTTP 的端口号是 80，<font color=FF0000>HTTPS 的端口号是 443</font>。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。



##### HTTPS 解决了 HTTP 的哪些问题？

HTTP 由于是明文传输，所以安全上存在以下三个风险：

- <mark>**窃听风险**</mark>：比如通信链路上可以获取通信内容，用户号容易没。
- <mark style="background:aqua">**篡改风险**</mark>：比如强制入垃圾广告，视觉污染，用户眼容易瞎。
- <mark style="background:fuchsia">**冒充风险**</mark>：比如冒充淘宝网站，用户钱容易没。

HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。可以很好的解决了上述的风险：

- <mark>**信息加密**</mark>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。
- <mark style="background: aqua">**校验机制**</mark>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。
- <mark style="background: fuchsia">**身份证书**</mark>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。

##### HTTPS 是如何解决上面的三个（窃听、篡改、冒充）风险的？

- <font color=FF0000>**混合加密的方式实现信息的机密性**</font>，解决了窃听的风险。

  **对称、非对称结合的 混合加密：**

  - <font color=FF0000>**在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密**</font>。

  - 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。

  **采用「混合加密」的方式的原因：**

  - 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
  - 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

- <font color=FF0000 size=4>**摘要算法的方式来实现完整性**</font>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。

- <font color=FF0000>**将服务器公钥放入到数字证书中**</font>，解决了冒充的风险



##### HTTPS  是如何建立连接的？其间交互了什么？

**SSL / TLS 协议基本流程：**

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL / TLS 的建立过程，也就是握手阶段。

**SSL/TLS 的「握手阶段」涉及四次通信，可见下图：**

![图片](https://s2.loli.net/2022/03/18/fVQAb4M7WrzksYn.jpg)

**SSL/TLS 协议建立的详细流程：**

1. **ClientHello**

   首先，<font color=FF0000>由客户端向服务器发起加密通信请求，也就是 ClientHello 请求</font>。在这一步，**客户端主要向服务器发送以下信息**：

   1. <mark><font color=FF0000>**客户端支持的 SSL / TLS 协议版本**</font></mark>，如 TLS 1.2 版本。

   2. <mark style="background: aqua">**客户端生产的随机数（Client Random）**</mark>，<font color=FF0000>后面 <font size=4>**用于生产「会话秘钥」**</font></font>。

   3. <mark style="background: fuchsia">**客户端支持的密码套件列表**</mark>，如 RSA 加密算法。

2. **SeverHello**

   <font color=FF0000>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello</font>。**服务器回应的内容有如下内容**：

   1. <mark>**确认 SSL/ TLS 协议版本**</mark>，<font color=FF0000 size=4>**如果浏览器不支持，则关闭加密通信**</font>。
   2. <mark style="background: aqua">**服务器生产的随机数（Server Random）**</mark>，<font color=FF0000>后面 <font size=4>**用于生产「会话秘钥」**</font></font>。
   3. <mark style="background: fuchsia">**确认的密码套件列表**</mark>，如 RSA 加密算法。
   4. <font color=FF0000>**服务器的数字证书**</font>。

3. **客户端回应**

   <font color=FF0000>客户端收到服务器的回应之后，**首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性**</font>。如果证书没有问题，客户端会<font color=FF0000>从数字证书中取出服务器的公钥，然后使用它加密报文</font>，向服务器发送如下信息：

   1. <font color=FF0000>一个随机数 ( pre-master key )</font>，该随机数会被服务器 <font size=4>**公钥加密**</font>。
   2. <font color=FF0000>加密通信算法改变通知，<font size=4>**表示随后的信息都将用「会话秘钥」加密通信**</font></font>。
   3. <font color=FF0000>**客户端握手结束通知**，表示客户端的握手阶段已经结束</font>。这一项<font color=FF0000>同时把之前所有内容的发生的数据做个摘要，用来供服务端校验</font>

   <mark>上面第一项的随机数是整个握手阶段的第三个随机数</mark>，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

4. **服务器的最后回应**

   <font color=FF0000>服务器收到客户端的第三个随机数 ( pre-master key ) 之后，通过协商的加密算法，计算出本次通信的「会话秘钥」</font>。然后，**向客户端发生最后的信息**：

   1. <font color=FF0000>加密通信算法改变通知，<font size=4>**表示随后的信息都将用「会话秘钥」加密通信**</font></font>。
   2. <font color=FF0000>**服务器握手结束通知**，表示服务器的握手阶段已经结束</font>。这一项<font color=FF0000>同时把之前所有内容的发生的数据做个摘要，用来供客户端校验</font>

<font color=FF0000 size=4>至此，整个 SSL/TLS 的握手阶段全部结束</font>。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

摘自：[硬核！30 张图解 HTTP 常见的面试题](https://mp.weixin.qq.com/s/qzzEgRpt9f-UlTLnWGrJEw)
