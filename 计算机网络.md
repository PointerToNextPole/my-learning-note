# 计算机网络



### **网关**

随便打开一本HTTP的书，都会提到网关的概念。通常意识中，网关一词更多的是硬件层面的概念，但其实与CGI的网关二字之含义也是不谋而合的。称CGI为软件网关也不为过。

网关，<mark>更形象的叫法是“**协议翻译机**”</mark>。<mark>通常与网关输入输出两端通信使用的是不同的协议。即一方是HTTP协议，另一方可能是其他协议</mark>，比如企业内部的自定义协议。

摘自：[万法归宗——CGI](https://zhuanlan.zhihu.com/p/25013398)



## HTTP

#### HTTP概述

HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。



#### options方法

HTTP 的 OPTIONS 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。

**属性：**

- 请求是否有主体：否
- 成功的响应是否有主体：是
- 安全：是
- 幂等：是
- 可缓存：是
- HTML 表单是否支持：是

**语法**

```http
OPTIONS /index.html HTTP/1.1
OPTIONS * HTTP/1.1
```

摘自：[MDN - OPTIONS]()

#### HEAD

HTTP HEAD 方法 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源.

HEAD 方法的响应不应包含响应正文. 即使包含了正文也必须忽略掉. 虽然描述正文信息的 entity headers, 例如 Content-Length 可能会包含在响应中, 但它们并不是用来描述 HEAD 响应本身的, 而是用来描述同样情况下的 GET 请求应该返回的响应.

如果 HEAD 请求的结果显示在上一次 GET 请求后缓存的资源已经过期了, 即使没有发出GET请求，缓存也会失效

**属性：**

- 请求是否有正文：否
- 成功的响应是否有正文：否
- 安全：是
- 幂等：是
- 可缓存：是
- HTML 表单 是否支持：否

**语法**

```http
HEAD /index.html
```



#### Content-Type

Content-Type 实体头部<font color=FF0000>用于指示资源的MIME类型 media type </font>。

在响应中，Content-Type标头<font color=FF0000>告诉客户端实际返回的内容的内容类型</font>。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。

- **属性：**
  - 相应头属性：实体报头
  - 禁止修改的消息首部：不是
  - 简易响应头：是

- **句法：**

  ```http
  Content-Type: text/html; charset=utf-8
  Content-Type: multipart/form-data; boundary=something
  ```

- **指令：**

  - **media-type：**<font color=FF0000>资源或数据的 MIME type</font> 。如：上面的 text/html
  - **charset：**<font color=FF0000>字符编码标准</font>。如：上面的 charset=utf-8
  - **boundary：**<font color=FF0000>对于多部分实体，boundary 是必需的</font>，其包括来自一组字符的1到70个字符，已知通过电子邮件网关是非常健壮的，而不是以空白结尾。它用于封装消息的多个部分的边界。

摘自：[MDN - Content-Type](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type)

#### Content-Length

Content-Length 是一个实体消息首部，<font color=FF0000>用来**指明发送给接收方的消息主体的大小**</font>，即<font color=FF0000>用十进制数字表示的八位元组的数目（**即字节bit的数目**）</font>。

**属性：**

- 头属性：实体报头

- 禁止修改的消息首部：是

**语法：**

```http
Content-Length: <length>
```

摘自：[MDN - Content-Length](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Length)



#### HTTP cookies

HTTP Cookie（也叫 Web Cookie 或浏览器 Cookie）<font color=FF0000>是 <font size=4>**服务器发送到用户浏览器**</font>并保存在本地的一小块数据</font>，<font color=FF0000>它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上</font>。<mark style=background-color:hotpink>通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态</mark>。<font color=FF0000>Cookie 使 <font size=4>**基于无状态的HTTP协议**</font> 记录稳定的状态信息成为了可能</font>。

**Cookie 主要用于以下三个方面：**

- <font color=FF0000>会话状态管理</font>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- <font color=FF0000>个性化设置</font>（如用户自定义设置、主题等）
- <font color=FF0000>浏览器行为跟踪</font>（如跟踪分析用户行为等）

**创建Cookie**

<font color=FF0000>当服务器收到 HTTP 请求时，**服务器可以在响应头里面添加一个 Set-Cookie 选项**</font>。<font color=FF0000>浏览器收到响应后通常会保存下 Cookie，之后对该服务器每一次请求中都通过  Cookie 请求头部将 Cookie 信息发送给服务器</font>。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。

**Set-Cookie响应头部和Cookie请求头部**

<font color=FF0000 size=4>**服务器使用 Set-Cookie 响应头部向用户代理（一般是浏览器）发送 Cookie信息**</font>。一个简单的 Cookie 可能像这样：

```http
Set-Cookie: <cookie名>=<cookie值>
```

<font color=FF0000>服务器通过该头部告知客户端保存 Cookie 信息</font>。

```http
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[页面内容]
```

<font color=FF0000>**现在，对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 Cookie 请求头部再发送给服务器**</font>。

```http
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

**定义 Cookie 的生命周期**

Cookie 的生命周期可以通过<font color=FF0000>**两种方式定义**</font>：

- **会话期 Cookie 是最简单的 Cookie：**<font color=FF0000>浏览器关闭之后它会被自动删除</font>，<font color=FF0000>也就是说它仅在会话期内有效</font>。<font color=FF0000>会话期Cookie**不需要指定过期时间（Expires）或者有效期（Max-Age）**</font>。<mark>需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie 也会被保留下来，就好像浏览器从来没有关闭一样，这会导致 Cookie 的生命周期无限期延长</mark>。
- **持久性 Cookie** 的生命周期取决于过期时间（Expires）或有效期（Max-Age）指定的一段时间。

例如：

```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

<mark>如果您的站点对用户进行身份验证，则每当用户进行身份验证时</mark>，<font color=FF0000>它都应重新生成并重新发送会话 Cookie，甚至是已经存在的会话 Cookie</font>。<mark>此技术有助于防止会话固定攻击（session fixation attacks），在该攻击中第三方可以重用用户的会话</mark>。

**限制访问 Cookie**

<font color=FF0000>有两种方法可以确保 Cookie 被安全发送</font>，并且不会被意外的参与者或脚本访问：<font color=FF0000>**Secure 属性和HttpOnly 属性**</font>。

- <font color=FF0000>**标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端**</font>，因此可以预防 man-in-the-middle 攻击者的攻击。<font color=FF0000>但**即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输**</font>，<mark style=background-color:hotpink>因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它</mark>。

- <font color=FF0000>JavaScript Document.cookie API 无法访问带有 HttpOnly 属性的cookie</font>；<font color=FF0000>此类 Cookie 仅作用于服务器</font>。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性。此预防措施有助于缓解跨站点脚本（XSS）攻击。

**Cookie 的作用域**

<font color=FF0000>Domain 和 Path 标识定义了Cookie的作用域：**即允许 Cookie 应该发送给哪些URL**</font>。

- **Domain 属性：**<font color=FF0000>**Domain 指定了哪些主机可以接受 Cookie**</font>。<font color=FF0000>如果不指定，默认为 origin，不包含子域名</font>。<font color=FF0000>如果指定了Domain，则一般包含子域名</font>。<mark style=background-color:hotpink>因此，指定 Domain 比省略它的限制要少</mark>。但是，当子域需要共享有关用户的信息时，这可能会有所帮助。 

  例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如developer.mozilla.org）。

- **Path 属性：**<font color=FF0000>**Path 标识指定了主机下的<font size=4>哪些路径</font>可以接受 Cookie**</font>（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。
  <mark style=background-color:hotpink>例如，设置 Path=/docs，则以下地址都会匹配：</mark>

  ```
  /docs
  /docs/Web/
  /docs/Web/HTTP
  ```

**SameSite attribute**

SameSite Cookie 允许服务器要求<font color=FF0000>某个 cookie 在**跨站请求**时不会被发送</font>，（其中Site由可注册域定义），<mark style=background-color:hotpink>从而可以阻止跨站请求伪造攻击（CSRF）</mark>。

SameSite cookies 是相对较新的一个字段，所有主流浏览器都已经得到支持。

下面是例子：

```http
Set-Cookie: key=value; SameSite=Strict
```

**SameSite 可以有下面三种值：**

- **None：**<font color=FF0000>浏览器会在同站请求、跨站请求下继续发送 cookies</font>，不区分大小写。
- **Strict：**<font color=FF0000>浏览器将只在**访问相同站点**时发送 cookie</font>。（在原有 Cookies 的限制条件上的加强）
- **Lax：**<font color=FF0000>与 Strict 类似</font>，<font color=FF0000>但**用户从外部站点导航至URL时（例如通过链接）除外**</font>。 <font color=FF0000>**在新版本浏览器中，为默认选项**</font>，Same-site cookies 将会为一些跨站子请求保留，如图片加载或者 frames 的调用，但只有当用户从外部站点导航到URL时才会发送。如 link 链接

**Cookie prefixes**

<font color=FF0000>cookie 机制的使得服务器无法确认 cookie 是在安全来源上设置的，甚至无法确定 cookie 最初是在哪里设置的</font>。

子域上的易受攻击的应用程序可以使用 Domain 属性设置 cookie，从而可以访问所有其他子域上的该 cookie。会话固定攻击中可能会滥用此机制。有关主要缓解方法，请参阅会话劫持（ session fixation）。

**但是，作为深度防御措施，可以使用 cookie 前缀来断言有关 cookie 的特定事实**。有两个前缀可用：

- **\_\_Host-：**如果 cookie 名称具有此前缀，则仅当它也用 Secure 属性标记，是从安全来源发送的，不包括 Domain 属性，并将 Path 属性设置为 / 时，它才在 Set-Cookie 标头中接受。这样，这些 cookie 可以被视为 "domain-locked”。
- **\_\_Secure-：**如果 cookie 名称具有此前缀，则仅当它也用 Secure 属性标记，是从安全来源发送的，它才在 Set-Cookie 标头中接受。该前缀限制要弱于 \__Host- 前缀。
  带有这些前缀点 Cookie， 如果不符合其限制的会被浏览器拒绝。请注意，这确保了如果子域要创建带有前缀的 cookie，那么它将要么局限于该子域，要么被完全忽略。由于应用服务器仅在确定用户是否已通过身份验证或 CSRF 令牌正确时才检查特定的 cookie 名称，因此，这有效地充当了针对会话劫持的防御措施。

**安全**

信息被存在 Cookie 中时，需要明白 cookie 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 JSON Web Tokens 之类的替代身份验证/机密机制。

<font color=FF0000>**当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息**</font>。

**缓解涉及Cookie的攻击的方法：**

- <font color=FF0000>使用 HttpOnly 属性</font>可防止通过 JavaScript 访问 cookie 值。
- <font color=FF0000>用于敏感信息（例如指示身份验证）的 Cookie 的生存期应较短</font>，<font color=FF0000>并且 SameSite 属性设置为Strict 或 Lax</font>。在支持 SameSite 的浏览器中，这样做的作用是确保不与跨域请求一起发送身份验证 cookie，因此，这种请求实际上不会向应用服务器进行身份验证。

摘自：[MDN - HTTP cookies](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies)

#### Set-Cookie

<font color=FF0000>响应首部 Set-Cookie **被用来由服务器端向客户端发送 cookie**</font>。

**属性：**

- **头属性：**响应报头
- **禁止修改的消息首部：**是

**语法：**

```http
Set-Cookie: <cookie-name>=<cookie-value>
Set-Cookie: <cookie-name>=<cookie-value>; Expires=<date>
Set-Cookie: <cookie-name>=<cookie-value>; Max-Age=<non-zero-digit>
Set-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>
Set-Cookie: <cookie-name>=<cookie-value>; Path=<path-value>
Set-Cookie: <cookie-name>=<cookie-value>; Secure
Set-Cookie: <cookie-name>=<cookie-value>; HttpOnly

Set-Cookie: <cookie-name>=<cookie-value>; SameSite=Strict
Set-Cookie: <cookie-name>=<cookie-value>; SameSite=Lax

// Multiple directives are also possible, for example:
Set-Cookie: <cookie-name>=<cookie-value>; Domain=<domain-value>; Secure; HttpOnly
```

**指令**

- **\<cookie-name>=\<cookie-value>：**<font color=FF0000>一个 cookie 开始于一个名称/值对</font>：
  - **\<cookie-name>：** <mark style=background-color:hotpink>可以是除了控制字符 (CTLs)、空格 (spaces) 或制表符 (tab)之外的任何 US-ASCII 字符</mark>。同时不能包含以下分隔字符： ( ) < > @ , ; : \ " /  [ ] ? = { }.
  - **\<cookie-value>：** <mark style=background-color:hotpink>是可选的</mark>，<font color=FF0000>如果存在的话，那么需要包含在双引号里面</font>。支持除了控制字符（CTLs）、空格（whitespace）、双引号（double quotes）、逗号（comma）、分号（semicolon）以及反斜线（backslash）之外的任意 US-ASCII 字符。关于编码：许多应用会对 cookie 值按照URL编码（URL encoding）规则进行编码，但是按照 RFC 规范，这不是必须的。不过满足规范中对于 \<cookie-value> 所允许使用的字符的要求是有用的。
  - **\_\_Secure- 前缀：**<font color=FF0000>以 \_\_Secure- 为前缀的 cookie（其中连接符是前缀的一部分），必须与 secure 属性一同设置</font>，同时必须应用于安全页面（即使用 HTTPS 访问的页面）。
  - **\_\_Host- 前缀：**<font color=FF0000>以 __Host- 为前缀的 cookie，必须与 secure 属性一同设置</font>，必须应用于安全页面（即使用 HTTPS 访问的页面），<font color=FF0000>必须不能设置 domain 属性 （也就不会发送给子域），同时 path 属性的值必须为“/”</font>。
- **Expires=\<date>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>cookie 的最长有效时间</font>，<font color=FF0000>形式为符合 HTTP-date 规范的时间戳</font>。参考 Date 可以获取详细信息。如果没有设置这个属性，那么表示这是一个会话期 cookie 。一个会话结束于客户端被关闭时，这意味着会话期 cookie 在彼时会被移除。然而，很多Web浏览器支持会话恢复功能，这个功能可以使浏览器保留所有的tab标签，然后在重新打开浏览器的时候将其还原。与此同时，cookie 也会恢复，就跟从来没有关闭浏览器一样。

- **Max-Age=\<non-zero-digit>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>在 cookie 失效之前需要经过的秒数</font>。<font color=FF0000>**秒数为 0 或 -1 将会使 cookie 直接过期**</font>。一些老的浏览器（ie6、ie7 和 ie8）不支持这个属性。对于其他浏览器来说，<font color=FF0000>假如二者 （指 Expires 和Max-Age） 均存在，那么 **Max-Age 优先级更高**</font>。
- **Domain=\<domain-value>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>指定 cookie 可以送达的主机名</font>。<font color=FF0000>假如没有指定，那么默认值为当前文档访问地址中的主机部分（但是不包含子域名）</font>。与之前的规范不同的是，域名之前的点号会被忽略。假如指定了域名，那么相当于各个子域名也包含在内了。
- **Path=\<path-value>：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部</font>。字符  %x2F ("/") 可以解释为文件目录分隔符，此目录的下级目录也满足匹配的条件（例如，如果 path=/docs，那么 "/docs", "/docs/Web/" 或者 "/docs/Web/HTTP" 都满足匹配的条件）。
- **Secure：**<mark style=background-color:hotpink>可选</mark>，<font color=FF0000>一个带有安全属性的 cookie 只有在请求使用SSL和HTTPS协议的时候才会被发送到服务器</font>。然而，<mark style=background-color:hotpink>保密或敏感信息永远不要在 HTTP cookie 中存储或传输，因为整个机制从本质上来说都是不安全的</mark>，比如前述协议并不意味着所有的信息都是经过加密的。
  注意：非安全站点（http:）已经不能再在 cookie 中设置 secure 指令了（在Chrome 52+ and Firefox 52+ 中新引入的限制）。

- **HttpOnly：**<mark style=background-color:hotpink>可选</mark>，设置了 <font color=FF0000>HttpOnly 属性的 cookie 不能使用 JavaScript 经由  Document.cookie 属性、XMLHttpRequest 和  Request APIs 进行访问，以防范跨站脚本攻击</font>。
- **SameSite=Strict / Lax：** <mark style=background-color:hotpink>可选</mark>，🧪 <font color=FF0000>允许服务器设定一则 cookie **不随着跨域请求一起发送**</font>，这样可以在一定程度上防范跨站请求伪造攻击（CSRF）。

摘自：[MDN - Set-Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie)

#### Cookie

Cookie <font color=FF0000>是一个请求首部</font>，<font color=FF0000>**其中含有先前由服务器通过 Set-Cookie  首部投放并存储到客户端的 HTTP cookies**</font>。
这个首部<font color=FF0000>可能会被完全移除</font>，<mark>例如在浏览器的隐私设置里面设置为禁用cookie</mark>。

**属性：**

- **头属性：**请求报头

- **禁止修改的消息首部：**是

**语法**

```http
Cookie: <cookie-list>
Cookie: name=value
Cookie: name=value; name2=value2; name3=value3
```

**\<cookie-list>：**一系列的名称/值对，形式为 \<cookie-name>=\<cookie-value>。<font color=FF0000>名称/值对之间用分号和空格 ('; ')隔开</font>。

**示例**

```http
Cookie: PHPSESSID=298zf09hf012fh2; csrftoken=u32t4o3tb3gg43; _gat=1;
```

摘自：[MDN - Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cookie)



#### X-Frame-Options

The X-Frame-Options HTTP <font color=FF0000>响应头</font>是<font color=FF0000>用来给浏览器 指示允许一个页面 **可否在 \<frame>, \<iframe>, \<embed> 或者 \<object> 中展现的标记**</font>。<mark style=background-color:hotpink>站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免 Click Jacking 攻击</mark>。

仅当访问文档的用户使用支持 X-Frame-Options 的浏览器时才提供附加的安全性。<mark> Content-Security-Policy HTTP 头中的 frame-ancestors 指令会替代这个非标准的 header。CSP 的 frame-ancestors 会在 Gecko 4.0 中支持，但是并不会被所有浏览器支持。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用</mark>。

**属性：**

- **头类型：**响应头
- **禁止修改的消息首部：**否

**语法**
**X-Frame-Options 有三个可能的值：**

- **deny：**<font color=FF0000>表示该页面不允许在 frame 中展示</font>，<mark style=background-color:hotpink>即便是在相同域名的页面中嵌套也不允许</mark>。

  如果设置为 deny，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载

- **sameorigin：**<font color=FF0000>表示该页面可以在相同域名页面的 frame 中展示</font>。

  如果设置为sameorigin，那么页面就可以在同域名页面的 frame 中嵌套

- **allow-from uri：**<font color=FF0000>表示该页面可以在指定来源的 frame 中展示</font>。

摘自：[MDN - X-Frame-Options](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options)



#### Content-Disposition

在常规的 HTTP 应答中，<font color=FF0000>Content-Disposition 响应头指示回复的内容该以何种形式展示</font>，<font color=FF0000>是以**内联的形式**（即网页或者页面的一部分），还是以**附件的形式**下载并保存到本地</font>。

<mark style=background-color:hotpink>在 multipart/form-data 类型的应答消息体中，Content-Disposition 消息头可以被用在 multipart 消息体的子部分中，用来给出其对应字段的相关信息</mark>。各个子部分由在Content-Type 中定义的分隔符分隔。用在消息体自身则无实际意义。

Content-Disposition 消息头最初是在 MIME 标准中定义的，HTTP 表单及 POST 请求只用到了其所有参数的一个子集。只有 form-data 以及可选的 name 和 filename 三个参数可以应用在HTTP场景中。

**属性：**

- **头类型：**请求头 / 通用头
  - 请求头：for the main body
  - 通用头：for a subpart of a multipart body
- **禁止修改的消息首部：**否

**语法**

- **作为消息主体中的消息头**

  在 HTTP 场景中，第一个参数或者是 inline（默认值，表示回复中的消息体会以页面的一部分或者整个页面的形式展示），或者是 attachment（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将 filename 的值预填为下载后的文件名，假如它存在的话）。

  ```http
  Content-Disposition: inline
  Content-Disposition: attachment
  Content-Disposition: attachment; filename="filename.jpg"
  ```

- **作为multipart body中的消息头**

  在 HTTP 场景中。第一个参数总是固定不变的 form-data；附加的参数不区分大小写，并且拥有参数值，参数名与参数值用等号('=')连接，参数值用双引号括起来。参数之间用分号(';')分隔。

  ```http
  Content-Disposition: form-data
  Content-Disposition: form-data; name="fieldName"
  Content-Disposition: form-data; name="fieldName"; filename="filename.jpg"
  ```

**指令**

- **name：**<font color=FF0000>后面是一个表单字段名的字符串</font>，每一个字段名会对应一个子部分。在同一个字段名对应多个文件的情况下（例如，带有 multiple 属性的 \<input type=file> 元素），则多个子部分共用同一个字段名。如果 name 参数的值为 '\_charset\_' ，意味着这个子部分表示的不是一个 HTML 字段，而是在未明确指定字符集信息的情况下各部分使用的默认字符集。
- **filename：**后面是要传送的文件的初始名称的字符串。这个参数总是可选的，而且不能盲目使用：路径信息必须舍掉，同时要进行一定的转换以符合服务器文件系统规则。这个参数主要用来提供展示性信息。当与 Content-Disposition: attachment 一同使用的时候，它被用作"保存为"对话框中呈现给用户的默认文件名。
- filename\*："filename" 和 "filename\*" 两个参数的唯一区别在于，"filename\*" 采用了  RFC 5987 中规定的编码方式。当 "filename" 和 "filename\*" 同时出现的时候，应该优先采用 "filename\*"，假如二者都支持的话。



#### Data URLs

Data URLs，即<font color=FF0000>前缀为 data: 协议的URL</font>，其<font color=FF0000>允许内容创建者向文档中嵌入小文件</font>。

**语法：**

```http
data:[<mediatype>][;base64],<data>
```

<font color=FF0000>Data URLs **由四个部分组成**</font>：

- 前缀(data:)
- <font color=FF0000>指示数据类型的MIME类型</font>
- <font color=FF0000>如果非文本则为可选的base64标记</font>
- <font color=FF0000>**数据本身**</font>

mediatype 是个 MIME 类型的字符串，例如 "image/jpeg" 表示 JPEG 图像文件。<font color=FF0000>如果被省略，则默认值为 text/plain;charset=US-ASCII</font>

<font color=FF0000>如果数据是文本类型，你可以直接将文本嵌入</font> (根据文档类型，使用合适的实体字符或转义字符)。<font color=FF0000>如果是二进制数据，你可以将数据进行base64编码之后再进行嵌入</font>。

**一些示例：**

- ```http
  data:,Hello%2C%20World!
  ```

  简单的 text/plain 类型数据

- ```http
  data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D
  ```

  上一条示例的 base64 编码版本

- ```http
  data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E
  ```

  一个HTML文档源代码 \<h1>Hello, World\</h1>

- ```htp
  data:text/html,<script>alert('hi');</script>
  ```

  一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。

摘自：[MDN - Data URLs](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URIs)



#### 攻击类型

- XSS（跨站脚本攻击）
- CSRF（跨站请求伪造）
- Session Fixation Attack（会话固定攻击）
- Click Jacking（点击劫持攻击）
- Timing Attack（时序攻击）
- Challenge Collapsar Attack（CC攻击）
- Man-in-the-middle attack（MITM， 中间人攻击）
- SCA（边信道攻击）



> ### HTTP协议原理+实践 Web开发工程师必学



#### 浏览器输入URL后HTTP请求返回的完整过程

![](https://i.loli.net/2020/12/31/QDMc6sTUqFjyNCg.png)

- 判断是否需要Redirect，以及要Redirect到哪里
- 查看在App Cache中是否有请求资源的缓存，如果没有就要去服务器请求资源 



#### TCP/IP五层结构

- **物理层：**主要作用是定义物理设备如何传输数据

- **数据链路层：**在通信的实体间建立数据链路连接

- **网络层：**为数据在结点之间传输创建逻辑链路
- **传输层：**向用户提供可靠的端到端(End-to- End)服务，传输层向高层屏蔽了下层数据通信的细节
- **应用层：**为应用软件提供了很多服务，构建于TCP协议之上，屏蔽网络传输相关细节